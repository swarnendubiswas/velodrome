diff -rupN workspace/jikesrvm-3.1.3/build/checkstyle/text-output.xsl workspace/velodrome-sound/build/checkstyle/text-output.xsl
--- workspace/jikesrvm-3.1.3/build/checkstyle/text-output.xsl	2014-04-03 18:29:58.441445255 -0400
+++ workspace/velodrome-sound/build/checkstyle/text-output.xsl	2014-04-03 17:43:39.452658810 -0400
@@ -1,29 +1,29 @@
-<?xml version="1.0"?>
-<!--
- ~  This file is part of the Jikes RVM project (http://jikesrvm.org).
- ~
- ~  This file is licensed to You under the Eclipse Public License (EPL);
- ~  You may not use this file except in compliance with the License. You
- ~  may obtain a copy of the License at
- ~
- ~      http://www.opensource.org/licenses/eclipse-1.0.php
- ~
- ~  See the COPYRIGHT.txt file distributed with this work for information
- ~  regarding copyright ownership.
- -->
-<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
-<xsl:output method="text"/>
-
-<xsl:template match="checkstyle">
-Checkstyle Results
-==================<xsl:for-each select="file[error]">
-
-File: <xsl:value-of select="@name"/>
-<xsl:for-each select="error">
- at line <xsl:value-of select="@line"/>,<xsl:value-of select="@column"/> : <xsl:value-of select="@message"/> 
-</xsl:for-each>
-</xsl:for-each>
-
-Found <xsl:value-of select="count(file/error)"/> errors in <xsl:value-of select="count(file[error])"/> of <xsl:value-of select="count(file)"/> files.
-</xsl:template>
-</xsl:stylesheet>
+<?xml version="1.0"?>
+<!--
+ ~  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ ~
+ ~  This file is licensed to You under the Eclipse Public License (EPL);
+ ~  You may not use this file except in compliance with the License. You
+ ~  may obtain a copy of the License at
+ ~
+ ~      http://www.opensource.org/licenses/eclipse-1.0.php
+ ~
+ ~  See the COPYRIGHT.txt file distributed with this work for information
+ ~  regarding copyright ownership.
+ -->
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+<xsl:output method="text"/>
+
+<xsl:template match="checkstyle">
+Checkstyle Results
+==================<xsl:for-each select="file[error]">
+
+File: <xsl:value-of select="@name"/>
+<xsl:for-each select="error">
+ at line <xsl:value-of select="@line"/>,<xsl:value-of select="@column"/> : <xsl:value-of select="@message"/> 
+</xsl:for-each>
+</xsl:for-each>
+
+Found <xsl:value-of select="count(file/error)"/> errors in <xsl:value-of select="count(file[error])"/> of <xsl:value-of select="count(file)"/> files.
+</xsl:template>
+</xsl:stylesheet>
diff -rupN workspace/jikesrvm-3.1.3/build/components/classpath.xml workspace/velodrome-sound/build/components/classpath.xml
--- workspace/jikesrvm-3.1.3/build/components/classpath.xml	2014-04-03 18:21:45.487740373 -0400
+++ workspace/velodrome-sound/build/components/classpath.xml	2014-04-03 17:43:39.921660352 -0400
@@ -198,7 +198,8 @@
   <target name="build" depends="fetch,patch" description="Download Classpath and build.">
     <test-file name="make.exe" location="${host.file}"/>
 
-    <condition property="cp.enable.gtk-peer" value=" --enable-gtk-peer" else=" --disable-gtk-peer">
+    <!-- Octet: TODO: we're disabling gtk because it doesn't seem to work in our cases -->
+    <condition property="cp.enable.gtk-peer" value=" --disable-gtk-peer" else=" --disable-gtk-peer">
       <and>
         <not>
           <or>
diff -rupN workspace/jikesrvm-3.1.3/build/configs/BaseAdaptiveImmix.properties workspace/velodrome-sound/build/configs/BaseAdaptiveImmix.properties
--- workspace/jikesrvm-3.1.3/build/configs/BaseAdaptiveImmix.properties	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/build/configs/BaseAdaptiveImmix.properties	2014-04-03 17:43:40.431662029 -0400
@@ -0,0 +1,16 @@
+#
+#  This file is part of the Jikes RVM project (http://jikesrvm.org).
+#
+#  This file is licensed to You under the Eclipse Public License (EPL);
+#  You may not use this file except in compliance with the License. You
+#  may obtain a copy of the License at
+#
+#      http://www.opensource.org/licenses/eclipse-1.0.php
+#
+#  See the COPYRIGHT.txt file distributed with this work for information
+#  regarding copyright ownership.
+#
+config.mmtk.plan=org.mmtk.plan.immix.Immix
+config.include.aos=true
+config.runtime.compiler=opt
+config.default-heapsize.initial=50
diff -rupN workspace/jikesrvm-3.1.3/build/configs/config.properties.defaults workspace/velodrome-sound/build/configs/config.properties.defaults
--- workspace/jikesrvm-3.1.3/build/configs/config.properties.defaults	2013-02-12 13:28:46.000000000 -0500
+++ workspace/velodrome-sound/build/configs/config.properties.defaults	2014-04-03 17:43:40.438662050 -0400
@@ -25,3 +25,6 @@ config.default-heapsize.maximum=100
 config.bootimage.compiler.args=
 config.stress-gc-interval=0
 config.alignment-checking=false
+
+# Octet: build-time option: default configuration class
+config.config-class=org.jikesrvm.config.BaseConfig
diff -rupN workspace/jikesrvm-3.1.3/build/hosts/x86_64-linux.properties workspace/velodrome-sound/build/hosts/x86_64-linux.properties
--- workspace/jikesrvm-3.1.3/build/hosts/x86_64-linux.properties	2013-02-12 13:28:46.000000000 -0500
+++ workspace/velodrome-sound/build/hosts/x86_64-linux.properties	2014-04-03 17:43:39.503658978 -0400
@@ -12,7 +12,8 @@
 #
 bison.exe=/usr/bin/bison
 c++.exe=/usr/bin/g++
-c++.args=-w -pipe -ggdb3 -O -fPIC -m32
+# Octet: added --no-as-needed here
+c++.args=-Wl,--no-as-needed -w -pipe -ggdb3 -O -fPIC -m32
 c.exe=/usr/bin/gcc
 c.args=${c++.args}
 shld.args=${c++.args} -shared
diff -rupN workspace/jikesrvm-3.1.3/build/primordials/RVM.txt workspace/velodrome-sound/build/primordials/RVM.txt
--- workspace/jikesrvm-3.1.3/build/primordials/RVM.txt	2013-02-12 13:28:46.000000000 -0500
+++ workspace/velodrome-sound/build/primordials/RVM.txt	2014-04-03 17:43:40.043660753 -0400
@@ -80,3 +80,8 @@ Lorg/jikesrvm/scheduler/Lock;
 
 [Lorg/vmmagic/pragma/Inline$When;
 Lsun/misc/Unsafe;
+
+# Octet: array types that need to be in boot image
+[Lorg/jikesrvm/octet/Stats$ThreadSafeCounter;
+[Lorg/jikesrvm/octet/Site;
+[Lorg/jikesrvm/octet/Stats$UnsyncCounter;
diff -rupN workspace/jikesrvm-3.1.3/build/targets/x86_64-linux.properties workspace/velodrome-sound/build/targets/x86_64-linux.properties
--- workspace/jikesrvm-3.1.3/build/targets/x86_64-linux.properties	2013-02-12 13:28:46.000000000 -0500
+++ workspace/velodrome-sound/build/targets/x86_64-linux.properties	2014-04-03 17:43:39.424658718 -0400
@@ -12,10 +12,20 @@
 #
 target.arch=ia32
 target.os=Linux
-target.bootimage.code.address=0x64000000
-target.bootimage.data.address=0x60000000
-target.bootimage.rmap.address=0x67000000
-target.max-mappable.address=0xb0000000
+# Octet: Increasing virtual memory space.
+# Note that the boot image data & code boundaries should match the sizes in HeapLayoutConstants. However, now you 
+# no longer need to make changes to that file to keep both consistent. Making changes only here should be good enough.
+# Octet: TODO: the lower and upper boundaries might not work in all cases (e.g., they can conflict with native libraries for the Jikes process)
+target.bootimage.data.address=0x40000000
+# Octet: 80 MB for data
+target.bootimage.code.address=0x45000000
+# Octet: 32 MB for code
+target.bootimage.rmap.address=0x47000000
+target.max-mappable.address=0xc0000000
+#target.bootimage.code.address=0x64000000
+#target.bootimage.data.address=0x60000000
+#target.bootimage.rmap.address=0x67000000
+#target.max-mappable.address=0xb0000000
 target.address.size=32
 target.dll-ext=.so
 target.dll-prefix=lib
diff -rupN workspace/jikesrvm-3.1.3/build.xml workspace/velodrome-sound/build.xml
--- workspace/jikesrvm-3.1.3/build.xml	2013-02-12 13:28:46.000000000 -0500
+++ workspace/velodrome-sound/build.xml	2014-04-03 17:43:39.422658710 -0400
@@ -1052,6 +1052,9 @@ Check to make sure all required properti
         <filter token="_PORTABLE_NATIVE_SYNC_" value="${config.portable-native-sync}"/>
         <filter token="_RVM_WITH_HARMONY_" value="${pp_RVM_WITH_HARMONY}"/>
         <filter token="_RVM_WITH_GNU_CLASSPATH_" value="${pp_RVM_WITH_GNU_CLASSPATH}"/>
+
+      	<!-- Octet: build-time option: configuration class -->
+      	<filter token="_RVM_WITH_CONFIG_CLASS_" value="${config.config-class}"/>
       </filterset>
     </copy>
 
@@ -1563,9 +1566,10 @@ Check to make sure all required properti
 
     <echo message="Building bootimage. Output redirected to : ${build.base}/BootImageWriterOutput.txt"/>
     <echo message="MMTk properties = ${mmtk.properties}"/>
+  	<!-- Octet: need more heap space to build some configs (Octet + stats + FullAdaptive); was 500M -->
     <java classname="org.jikesrvm.tools.bootImageWriter.BootImageWriter"
           fork="yes"
-          maxmemory="500M"
+          maxmemory="800M"
           failonerror="false"
           resultproperty="bootimage-writer.result"
           dir="${basedir}/tools/bootImageWriter/src">
diff -rupN workspace/jikesrvm-3.1.3/.hgignore workspace/velodrome-sound/.hgignore
--- workspace/jikesrvm-3.1.3/.hgignore	2013-02-12 13:28:43.000000000 -0500
+++ workspace/velodrome-sound/.hgignore	2014-04-03 17:43:55.513711594 -0400
@@ -1,9 +1,15 @@
 syntax:glob
 jikesrvm.iml
+results
+generated
+dist
+target
+components
 .ant.properties
 .project
 .settings
 .classpath
+eclipse
 .pmd
 .checkstyle
 MMTk/harness/src-generated/org/mmtk/harness/lang/parser/*.java
@@ -23,12 +29,3 @@ tools/bootImageRunner/Classes.tmp
 testing/tests/jni/cp
 testing/tests/jni/out.*
 testing/tests/SPECjbb2000/results
-
-syntax:regexp
-^components
-^dist
-^eclipse
-^generated
-^results
-^target
-
diff -rupN workspace/jikesrvm-3.1.3/.hgtags workspace/velodrome-sound/.hgtags
--- workspace/jikesrvm-3.1.3/.hgtags	2013-02-12 13:28:43.000000000 -0500
+++ workspace/velodrome-sound/.hgtags	2014-04-03 17:43:56.633715272 -0400
@@ -32,4 +32,3 @@ a2b297f5f9dd5bf524471894a9311ce2b1fbdafd
 a79fd6bdd8bfab83ef7e65f2525bc90f7370774c 3.1.0
 a065d00f225cf96643df659f87aa1579d059fdbd 3.1.1
 c03a67f405f8b99c88fec2a16da17024bbf81336 3.1.2
-c951b3ea1d7e66219fcfc260a3f6666cc7d78a78 3.1.3
diff -rupN workspace/jikesrvm-3.1.3/libraryInterface/Common/src/java/lang/Class.java workspace/velodrome-sound/libraryInterface/Common/src/java/lang/Class.java
--- workspace/jikesrvm-3.1.3/libraryInterface/Common/src/java/lang/Class.java	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/libraryInterface/Common/src/java/lang/Class.java	2014-04-03 17:43:55.656712062 -0400
@@ -12,6 +12,9 @@
  */
 package java.lang;
 
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+
 import java.io.InputStream;
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
@@ -37,20 +40,27 @@ import java.util.ArrayList;
 
 import org.jikesrvm.Callbacks;
 import org.jikesrvm.UnimplementedError;
+import org.jikesrvm.VM;
 import org.jikesrvm.classloader.Atom;
 import org.jikesrvm.classloader.BootstrapClassLoader;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMClassLoader;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.compilers.common.CompiledMethod;
+import org.jikesrvm.compilers.common.CompiledMethods;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.Reflection;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
 import org.jikesrvm.runtime.StackBrowser;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.NoInline;
 import org.vmmagic.pragma.Pure;
+import org.vmmagic.unboxed.Address;
 
 /**
  * Implementation of java.lang.Class for JikesRVM.
@@ -699,6 +709,26 @@ public final class Class<T> implements S
     }
     return this.defaultConstructor;
   }
+  
+  // Velodrome: Context: Helper method to search for default ctor with given "context". We cannot cache the default
+  // constructor in "this.defaultConstructor" since the resolved contexts could be different in different scenarios.
+  @Pure
+  private RVMMethod getDefaultConstructor(RVMClass cls, int context) {
+    if (VM.VerifyAssertions) { VM._assert(Context.isApplicationPrefix(cls.getTypeRef())); }
+    if (VM.VerifyAssertions) { VM._assert(this.defaultConstructor == null); } 
+    RVMMethod defaultConstructor = null;
+    RVMMethod[] methods = type.asClass().getConstructorMethods();
+    for (RVMMethod method : methods) {
+      if (method.getParameterTypes().length == 0) {
+        if (method.getResolvedContext() == context) {
+          defaultConstructor = method;
+          break;
+        }
+      }
+    }
+    if (VM.VerifyAssertions) { VM._assert(defaultConstructor != null); }
+    return defaultConstructor;
+  }
 
   public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
     checkMemberAccess(Member.PUBLIC);
@@ -858,7 +888,33 @@ public final class Class<T> implements S
     }
 
     // Find the defaultConstructor
-    RVMMethod defaultConstructor = getDefaultConstructor();
+    // Velodrome: Context: The call here can come from a library method, so basically we will walk up the stack to find
+    // out which RVMMethod version of <init> to use depending on the computed context. We can't blindly use the 
+    // static context of the caller. We will do this exercise only for application methods.
+    RVMMethod defaultConstructor;
+    if (Context.isApplicationPrefix(cls.getTypeRef())) {
+      Address fp = Magic.getFramePointer();
+      int context = Context.TRANS_CONTEXT;
+      fp = Magic.getCallerFramePointer(fp);
+      // Search till the topmost application frame/method
+      while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+        int compiledMethodId = Magic.getCompiledMethodID(fp);
+        if (compiledMethodId != INVISIBLE_METHOD_ID) {
+          CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+          RVMMethod method = compiledMethod.getMethod();
+          if (!method.isNative() && Octet.shouldInstrumentMethod(method)) {
+            context = method.getStaticContext();
+            break;
+          }
+        }
+        fp = Magic.getCallerFramePointer(fp);
+      }
+      defaultConstructor = getDefaultConstructor(cls, context);
+      if (VM.VerifyAssertions) { VM._assert(context == defaultConstructor.getResolvedContext()); }
+    } else {
+      defaultConstructor = getDefaultConstructor();
+    }
+       
     if (defaultConstructor == null)
       throw new InstantiationException();
 
diff -rupN workspace/jikesrvm-3.1.3/libraryInterface/Common/src/java/lang/reflect/VMCommonLibrarySupport.java workspace/velodrome-sound/libraryInterface/Common/src/java/lang/reflect/VMCommonLibrarySupport.java
--- workspace/jikesrvm-3.1.3/libraryInterface/Common/src/java/lang/reflect/VMCommonLibrarySupport.java	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/libraryInterface/Common/src/java/lang/reflect/VMCommonLibrarySupport.java	2014-04-03 17:43:55.617711934 -0400
@@ -227,7 +227,8 @@ final class VMCommonLibrarySupport {
 
     // find the right method to call
     RVMClass C = Magic.getObjectType(receiver).asClass();
-    method = C.findVirtualMethod(method.getName(), method.getDescriptor());
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+    method = C.findVirtualMethod(method.getName(), method.getDescriptor(), method.getResolvedContext());
 
     // Invoke method
     try {
diff -rupN workspace/jikesrvm-3.1.3/libraryInterface/Common/src/sun/misc/Unsafe.java workspace/velodrome-sound/libraryInterface/Common/src/sun/misc/Unsafe.java
--- workspace/jikesrvm-3.1.3/libraryInterface/Common/src/sun/misc/Unsafe.java	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/libraryInterface/Common/src/sun/misc/Unsafe.java	2014-04-03 17:43:55.670712108 -0400
@@ -14,6 +14,7 @@ package sun.misc;
 
 import java.lang.reflect.Field;
 
+import org.jikesrvm.VM;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.runtime.Magic;
@@ -55,6 +56,13 @@ public final class Unsafe {
   }
 
   public boolean compareAndSwapLong(Object obj,long offset,long expect,long update) {
+
+    // Octet: Verifying that applications don't call this method.
+    // Octet: TODO: We need more assertions like this in this class,
+    // to figure out which methods are called by our benchmarks and
+    // thus need barriers.
+    if (VM.VerifyAssertions) { VM._assert(false); }
+    
     Offset off = Offset.fromIntSignExtend((int)offset);
     return Synchronization.tryCompareAndSwap(obj, off, expect, update);
   }
@@ -170,6 +178,10 @@ public final class Unsafe {
   }
 
   public void putObject(Object obj,long offset,Object value) {
+    
+    // Octet: TODO: We would like to invoke an Octet barrier here, but there's no clear mechanism for calling a barrier, since the client analysis might have overridden it.
+    //OctetBarriers.writeObject(obj, 0, -1);
+    
     Offset off = longToOffset(offset);
     if (NEEDS_OBJECT_PUTFIELD_BARRIER) {
       objectFieldWrite(obj, value, off, 0);
diff -rupN workspace/jikesrvm-3.1.3/libraryInterface/GNUClasspath/EPL/src/gnu/classpath/VMStackWalker.java workspace/velodrome-sound/libraryInterface/GNUClasspath/EPL/src/gnu/classpath/VMStackWalker.java
--- workspace/jikesrvm-3.1.3/libraryInterface/GNUClasspath/EPL/src/gnu/classpath/VMStackWalker.java	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/libraryInterface/GNUClasspath/EPL/src/gnu/classpath/VMStackWalker.java	2014-04-03 17:43:55.763712414 -0400
@@ -73,7 +73,9 @@ public final class VMStackWalker {
     b.up(); // skip VMStackWalker.getClassContext (this call)
 
     boolean reflected;  // Were we invoked by reflection?
-    if (b.getMethod() == Entrypoints.java_lang_reflect_Method_invokeMethod){
+    // Octet: Static cloning: Match on the method reference here for simplicity
+    if (b.getMethod().getMemberRef() == Entrypoints.java_lang_reflect_Method_invokeMethodReference){
+    //if (b.getMethod() == Entrypoints.java_lang_reflect_Method_invokeMethod){
       reflected = true;
       b.up();         // Skip Method.invoke, (if we were called by reflection)
     } else {
@@ -142,7 +144,9 @@ public final class VMStackWalker {
       b.up();
 
     /* Skip Method.invoke, (if the caller was called by reflection) */
-    if (b.getMethod() == Entrypoints.java_lang_reflect_Method_invokeMethod){
+    // Octet: Static cloning: Match on the method reference here for simplicity
+    if (b.getMethod().getMemberRef() == Entrypoints.java_lang_reflect_Method_invokeMethodReference){
+    //if (b.getMethod() == Entrypoints.java_lang_reflect_Method_invokeMethod){
       b.up();
     }
     /* skip past another frame, whatever getClassContext()[0] would be. */
diff -rupN workspace/jikesrvm-3.1.3/libraryInterface/GNUClasspath/EPL/src/java/lang/VMSystem.java workspace/velodrome-sound/libraryInterface/GNUClasspath/EPL/src/java/lang/VMSystem.java
--- workspace/jikesrvm-3.1.3/libraryInterface/GNUClasspath/EPL/src/java/lang/VMSystem.java	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/libraryInterface/GNUClasspath/EPL/src/java/lang/VMSystem.java	2014-04-03 17:43:55.841712671 -0400
@@ -25,7 +25,16 @@ import org.jikesrvm.runtime.Time;
  */
 public final class VMSystem {
 
+  // Octet: TODO: try to add this
+  //static int arraycopySiteID = Site.newSite(Atom.findOrCreateAsciiAtom("VMSystem"), Atom.findOrCreateAsciiAtom("arraycopy"), -1);
   static void arraycopy(Object src, int srcPos, Object dst, int dstPos, int len) {
+    /*
+    if (Octet.instrAccess()) {
+      Instr.arrayReadBarrier(src, 0, arraycopySiteID);
+      Instr.arrayWriteBarrier(dst, 0, arraycopySiteID);
+    }
+    */
+    
     VMCommonLibrarySupport.arraycopy(src, srcPos, dst, dstPos, len);
   }
 
@@ -57,6 +66,11 @@ public final class VMSystem {
     VMCommonLibrarySupport.setSystemStreamField("err", err);
   }
 
+  // Octet: The VM's versions of these streams, which (unlike System.*) can't be changed by the application.
+  public static InputStream in;
+  public static PrintStream out;
+  public static PrintStream err;
+
   static InputStream makeStandardInputStream() { return null; }
 
   static PrintStream makeStandardOutputStream() { return null; }
diff -rupN workspace/jikesrvm-3.1.3/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Memory.java workspace/velodrome-sound/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Memory.java
--- workspace/jikesrvm-3.1.3/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Memory.java	2013-02-12 13:28:43.000000000 -0500
+++ workspace/velodrome-sound/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Memory.java	2014-04-03 17:43:53.251704161 -0400
@@ -13,6 +13,7 @@
 package org.jikesrvm.mm.mmtk;
 
 import org.mmtk.policy.ImmortalSpace;
+import org.mmtk.policy.Space;
 import org.mmtk.utility.Constants;
 import org.mmtk.utility.heap.VMRequest;
 
@@ -34,7 +35,10 @@ import org.vmmagic.pragma.*;
   @Override
   protected final Address getHeapEndConstant() { return MAXIMUM_MAPPABLE; }
   @Override
-  protected final Address getAvailableStartConstant() { return BOOT_IMAGE_CODE_END; }
+  // Octet: Changed to reflect the true end of the boot image.  It seems to be a Jikes bug that turns out to be benign (for now).
+  // Octet: TODO: Report (and possibly fix) this Jikes bug.  Also report/fix the related unnecessary dependences between boot image layout values.
+  protected final Address getAvailableStartConstant() { return BOOT_IMAGE_END; }
+  //protected final Address getAvailableStartConstant() { return BOOT_IMAGE_CODE_END; }
   @Override
   protected final Address getAvailableEndConstant() { return MAXIMUM_MAPPABLE; }
   @Override
@@ -58,7 +62,9 @@ import org.vmmagic.pragma.*;
 
   /* FIXME the following was established via trial and error :-( */
   //  private static int BOOT_SEGMENT_MB = 4+(BOOT_IMAGE_SIZE.toInt()>>LOG_BYTES_IN_MBYTE);
-  private static int BOOT_SEGMENT_MB = (0x10000000>>LOG_BYTES_IN_MBYTE);
+  // Octet: Making this space reflect the actual size of the boot image.
+  private static int BOOT_SEGMENT_MB = org.jikesrvm.runtime.Memory.alignUp(BOOT_IMAGE_END.diff(BOOT_IMAGE_DATA_START).toInt(), Space.BYTES_IN_CHUNK) >>> LOG_BYTES_IN_MBYTE;
+  //private static int BOOT_SEGMENT_MB = (0x10000000>>LOG_BYTES_IN_MBYTE);
 
   /**
    * Return the space associated with/reserved for the VM.  In the
diff -rupN workspace/jikesrvm-3.1.3/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java workspace/velodrome-sound/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java
--- workspace/jikesrvm-3.1.3/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java	2013-02-12 13:28:43.000000000 -0500
+++ workspace/velodrome-sound/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java	2014-04-03 17:43:53.256704179 -0400
@@ -12,22 +12,38 @@
  */
 package org.jikesrvm.mm.mmtk;
 
-import org.mmtk.plan.CollectorContext;
-import org.mmtk.utility.alloc.Allocator;
-import org.mmtk.vm.VM;
+import static org.jikesrvm.classloader.RVMType.REFARRAY_OFFSET_ARRAY;
 
-import org.jikesrvm.runtime.Magic;
-import org.jikesrvm.objectmodel.JavaHeaderConstants;
-import org.jikesrvm.objectmodel.TIB;
+import org.jikesrvm.SizeConstants;
 import org.jikesrvm.classloader.Atom;
 import org.jikesrvm.classloader.RVMArray;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.mm.mminterface.DebugUtil;
 import org.jikesrvm.mm.mminterface.MemoryManager;
-
-import org.vmmagic.unboxed.*;
-import org.vmmagic.pragma.*;
+import org.jikesrvm.mm.mminterface.Selected;
+import org.jikesrvm.objectmodel.JavaHeader;
+import org.jikesrvm.objectmodel.JavaHeaderConstants;
+import org.jikesrvm.objectmodel.MiscHeader;
+import org.jikesrvm.objectmodel.TIB;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.velodrome.ReadHashMap;
+import org.jikesrvm.velodrome.ReadHashMapElement;
+import org.jikesrvm.velodrome.Velodrome;
+import org.mmtk.plan.CollectorContext;
+import org.mmtk.plan.ParallelCollector;
+import org.mmtk.plan.TraceLocal;
+import org.mmtk.plan.generational.Gen;
+import org.mmtk.utility.alloc.Allocator;
+import org.mmtk.vm.VM;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.OffsetArray;
+import org.vmmagic.unboxed.Word;
 
 @Uninterruptible public final class ObjectModel extends org.mmtk.vm.ObjectModel implements org.mmtk.utility.Constants,
                                                                                            org.jikesrvm.Constants {
@@ -39,6 +55,8 @@ import org.vmmagic.pragma.*;
   @Inline
   public ObjectReference copy(ObjectReference from, int allocator) {
     TIB tib = org.jikesrvm.objectmodel.ObjectModel.getTIB(from);
+    // Velodrome: Included this assertion
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(tib != null); }
     RVMType type = Magic.objectAsType(tib.getType());
 
     if (type.isClassType())
@@ -297,5 +315,330 @@ import org.vmmagic.pragma.*;
   public void dumpObject(ObjectReference object) {
     DebugUtil.dumpRef(object);
   }
-}
+  
+  // Velodrome: Trace lock access metadata
+  @Override
+  public void traceLockMetadata(ObjectReference object, TraceLocal trace) {
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(NOT_REACHED); }
+    if (Velodrome.addMiscHeader()) {
+      Address slot = object.toAddress().plus(MiscHeader.VELODROME_OFFSET);
+      trace.processEdge(object, slot);
+    }
+  }
+  
+  // Velodrome: Add lock metadata slot to weak reference queue
+  @Override
+  public void traceLockMetadata(ObjectReference object) {
+    if (Velodrome.addMiscHeader()) {
+      Address slot = object.toAddress().plus(MiscHeader.VELODROME_OFFSET);
+      if (!slot.loadObjectReference().isNull()) {
+        TraceLocal trace = ((ParallelCollector) VM.activePlan.collector()).getCurrentTrace();
+        trace.metadataSlots.insert(slot);
+      }
+    }
+  }
+  
+  // Velodrome: Add all object-level metadata references to the weak reference queue
+  // for later processing
+  @Override
+  public void traceObjectLevelMetadata(ObjectReference object) {
+    TraceLocal trace = ((ParallelCollector) VM.activePlan.collector()).getCurrentTrace();
+    Address slot;
+    if (Velodrome.addMiscHeader()) {
+      slot = object.toAddress().plus(MiscHeader.VELODROME_OFFSET);
+      if (!slot.loadObjectReference().isNull()) {
+        trace.metadataSlots.insert(slot);
+      }
+    }
+    if (Velodrome.instrumentArrays()) {
+      slot = object.toAddress().plus(MiscHeader.VELODROME_WRITE_OFFSET);
+      if (!slot.loadObjectReference().isNull()) {
+        trace.metadataSlots.insert(slot);
+      }
+      slot = object.toAddress().plus(MiscHeader.VELODROME_READ_OFFSET);
+      if (!slot.loadObjectReference().isNull()) {
+        trace.metadataSlots.insert(slot);
+      }
+    }
+  }
 
+  // Velodrome: Add metadata reference addresses to a queue for later processing
+  @Override
+  public void addMetadataSlotsToQueue(ObjectReference objRef) {
+    if (Velodrome.addPerFieldVelodromeMetadata()) {
+      TraceLocal trace = ((ParallelCollector) VM.activePlan.collector()).getCurrentTrace();
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(trace.isLive(objRef)); }
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(DebugUtil.validRef(objRef)); }
+      // The gray object "objRef" should have already moved by now, so it cannot be in the nursery anymore
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(!Gen.inNursery(objRef)); }
+
+      RVMType type = org.jikesrvm.objectmodel.ObjectModel.getObjectType(objRef.toObject());
+      int[] velodromeOffsets = type.getVelodromeMetadataOffsets();
+      if (velodromeOffsets == null) {
+        return;
+      }
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(velodromeOffsets.length % 2 == 0); }
+      
+      Address addr = null;
+      if (velodromeOffsets != REFARRAY_OFFSET_ARRAY) {
+        if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(type.isClassType() || (type.isArrayType() && !type.asArray().getElementType().isReferenceType()));
+        for (int i = 0; i < velodromeOffsets.length; i++) {
+          addr = objRef.toAddress().plus(velodromeOffsets[i]);
+          if (VM.VERIFY_ASSERTIONS) {
+            if (!DebugUtil.validRef(addr.loadObjectReference())) {
+              VM.assertions._assert(NOT_REACHED); }
+          }
+          if (!addr.loadObjectReference().isNull()) { 
+            // push() adds to the head of the deque, while insert() adds it to the tail. pop() dequeues elements from the head.
+            // It seems an insert() will be more efficient than a push().
+            trace.metadataSlots.insert(addr);
+          }
+        }
+      } else {
+        if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(NOT_REACHED); }
+        if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(type.isArrayType() && type.asArray().getElementType().isReferenceType());
+        for(int i=0; i < org.jikesrvm.objectmodel.ObjectModel.getArrayLength(objRef.toObject()); i++) {
+          addr = objRef.toAddress().plus(i << SizeConstants.LOG_BYTES_IN_ADDRESS);
+          if (VM.VERIFY_ASSERTIONS) {
+            if (!DebugUtil.validRef(addr.loadObjectReference())) {
+              VM.assertions._assert(NOT_REACHED); }
+          }
+          if (!addr.loadObjectReference().isNull()) {
+            // push() adds to the head of the deque, while insert() adds it to the tail. pop() dequeues elements from the head.
+            // It seems an insert() will be more efficient than a push().
+            trace.metadataSlots.insert(addr);
+          }
+        }
+      }
+      // Probably not necessary, since the local buffer would be automatically flushed when it is full
+      //VM.activePlan.collector().metadataSlots.flushLocal(); 
+    }
+  }
+  
+  // Velodrome: Treat metadata references as weak references. This method is only invoked for full heap GCs. 
+  // For a full heap GC, we don't expect metadata references that point to read maps to be live. 
+  /** @param mdSlot This is the address of a particular metadata slot (either write or read) for a field in an object or 
+   *                could be for statics */
+  @Override
+  public void traceMetadataReferencesDuringFullHeap(TraceLocal trace, Address mdSlot) {
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(Velodrome.addPerFieldVelodromeMetadata()); }
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(!VM.activePlan.global().isCurrentGCNursery()); }
+    ObjectReference oldObjRef = mdSlot.loadObjectReference(); // This is the referent
+    
+    // It seems that mdSlots are getting added to the weak reference queue multiple times, so in that case, it is 
+    // possible that mdSlot has already been processed and nulled out
+    if (oldObjRef.isNull()) {
+      return;
+    }
+    
+    if (trace.isLive(oldObjRef)) {
+      ObjectReference newObjRef = trace.getForwardedReference(oldObjRef); // This is the new referent
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(!newObjRef.isNull()); }
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(DebugUtil.validRef(newObjRef)); }
+      
+      if (newObjRef.toAddress().NE(oldObjRef.toAddress())) {
+        VM.activePlan.global().storeObjectReference(mdSlot, newObjRef);
+      }
+      return;      
+    }
+    
+    // 1. Object reference is a transaction, or
+    // 2. Object reference is a read map (shouldn't already be marked live)    
+    
+    // Expecting the TIB to be well formed since the object is probably not yet touched or moved
+    Address tib = oldObjRef.toAddress().loadAddress(JavaHeader.getTibOffset());
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(tib.NE(Address.zero())); }
+    boolean isReadmap = tib.EQ(Velodrome.tibForReadHashMap);
+    
+    if (!isReadmap) { // Metadata slot points to a transaction which is not already marked live
+      VM.activePlan.global().storeObjectReference(mdSlot, ObjectReference.nullReference());
+      return;
+    } 
+    
+    // Metadata slot points to a read map
+    
+    // Iterate over all the elements in the read map and check for liveness of each reference. 
+    ReadHashMap map = (ReadHashMap) oldObjRef.toObject();
+    boolean oneBucketLive = false; 
+    for (int j = 0; j < ReadHashMap.INITIAL_NUMBER_THREADS; j++) {
+      ReadHashMapElement rdMapElem = map.getBucketHead(j); // tmp is the start pointer to the bucket indexed by j
+      ReadHashMapElement next = null;
+      while (rdMapElem != null) {
+        ObjectReference tRef = ObjectReference.fromObject(rdMapElem.getTransaction());
+        next = map.getNext(rdMapElem);
+        if (!trace.isLive(tRef)) { // Reference object is dead
+          // Velodrome: TODO: Why does this assertion fail, mostly for xalan9 and eclipse6?
+          map.remove(map.getKey(rdMapElem), false);
+        } else {
+          oneBucketLive = true;
+        }
+        rdMapElem = next;
+      }
+    }
+    
+    if (!oneBucketLive) { // Not even a single bucket has a live transaction
+      VM.activePlan.global().storeObjectReference(mdSlot, ObjectReference.nullReference());
+      return;
+    }
+    
+    // This should add the read map reference to the gray list. A later CLOSURE phase should then trace all 
+    // objects reachable from the read map reference. 
+    ObjectReference newObjRef = trace.traceObject(oldObjRef, false);
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(DebugUtil.validRef(newObjRef)); }
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(newObjRef.toAddress().loadAddress(JavaHeader.getTibOffset()).EQ(Velodrome.tibForReadHashMap)); }
+    VM.activePlan.global().storeObjectReference(mdSlot, newObjRef);
+  }
+  
+  public boolean checkForReadmap(ObjectReference newObject, ObjectReference oldObject) {
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(!newObject.isNull()); }
+    Address tib = newObject.toAddress().loadAddress(JavaHeader.getTibOffset());
+    if (tib.EQ(Velodrome.tibForReadHashMap)) {
+      Address dMap = ObjectReference.fromObject(Velodrome.dummyMap).toAddress();
+      if (VM.VERIFY_ASSERTIONS && oldObject.toAddress().NE(dMap)) { VM.assertions._assert(false); }
+      return true;
+    }
+    return false;
+  }
+  
+  /**
+   * @param source Source object whose slot {@code slot} is being traced
+   * @param slot Actual slot of {@code source} being traced
+   * @param newObj Object reference stored at {@code slot}
+   */
+  public boolean checkForReadmapDuringTracing(ObjectReference source, Address slot, ObjectReference newObj) {
+    if (!newObj.isNull()) {
+      Address tib = newObj.toAddress().loadAddress(JavaHeader.getTibOffset());
+      if (tib.EQ(Velodrome.tibForReadHashMap)) {
+        RVMType type = org.jikesrvm.objectmodel.ObjectModel.getObjectType(source.toObject());
+        org.jikesrvm.VM.sysWriteln("RVM Type:", type.getDescriptor());
+        return true;
+      }
+    }
+    return false;
+  }
+  
+  /**
+   * @param slot Address of root reference
+   * @param newObj Object reference stored at {@code slot} after being traced
+   * @param oldObj Object reference stored at {@code slot} before being traced
+   */
+  public boolean checkForReadmapFromRoot(Address slot, ObjectReference newObj, ObjectReference oldObj) {
+    if (!newObj.isNull()) {
+      Address tib = newObj.toAddress().loadAddress(JavaHeader.getTibOffset());
+      if (tib.EQ(Velodrome.tibForReadHashMap)) {
+        return true;
+      }
+    }
+    return false;
+  }  
+  
+  public void flushRememberedSets() {
+    Selected.Mutator.get().flushRememberedSets();
+  }
+  
+  // This is called during nursery GC to just update the contents of metadata reference slots if the referent is live and 
+  // has moved. If the referent is live, we expect that its TIB either be of Transaction or ReadHashMap type.
+  // We don't need to recursively check for liveness and moving of objects internal to the read map, since a CLOSURE should 
+  // be performed after our Velodrome phase.
+  // For a nursery GC, it is possible that metadata references that point to read maps be live because of inter-generational 
+  // pointers.
+  public void updateMetadataSlotsDuringNursery(TraceLocal trace, Address mdSlot) {
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(VM.activePlan.global().isCurrentGCNursery()); }
+    ObjectReference oldObjRef = mdSlot.loadObjectReference(); // This is the referent
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(!oldObjRef.isNull()); } // We don't add null references to the queue
+
+    ObjectReference newObjRef;
+    if (trace.isLive(oldObjRef)) {
+      newObjRef = trace.getForwardedReference(oldObjRef); // This is the new referent
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(!newObjRef.isNull()); }
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(DebugUtil.validRef(newObjRef)); }
+      if (VM.VERIFY_ASSERTIONS) {
+        Address tib = newObjRef.toAddress().loadAddress(JavaHeader.getTibOffset());
+        VM.assertions._assert(tib.EQ(Velodrome.tibForReadHashMap) || tib.EQ(Velodrome.tibForTransaction));
+      }
+      if (newObjRef.toAddress().NE(oldObjRef.toAddress())) {
+        VM.activePlan.global().storeObjectReference(mdSlot, newObjRef);
+      }
+    } else {
+      VM.activePlan.global().storeObjectReference(mdSlot, ObjectReference.nullReference());
+    }
+  }
+  
+  @Override
+  public boolean testOctetThreadsBeforeGCStarts() {
+    boolean flag = true;
+    for (int i = RVMThread.numThreads - 1; i >= 0; i--) {
+      Magic.sync();
+      RVMThread t = RVMThread.threads[i];
+      if (!t.isOctetThread()) {
+        continue;
+      }
+      if (t.betweenPreAndPost) {
+        org.jikesrvm.VM.sysWrite("Thread id:", t.octetThreadID);
+        org.jikesrvm.VM.sysWriteln(" between pre and post");
+        org.jikesrvm.VM.sysWrite("Locked object reference:");
+        org.jikesrvm.VM.sysWriteln(t.lockedMetadata);
+        t.dump();
+        if (t.contextRegisters != null && !t.ignoreHandshakesAndGC()) {
+          RVMThread.dumpStack(t.contextRegisters.getInnermostFramePointer());
+        }
+        flag = false;
+      }
+    }
+    return flag;
+  }
+  
+  public boolean validRef(ObjectReference objRef) {
+    return DebugUtil.validRef(objRef);
+  }
+  
+  public boolean addPerFieldVelodromeMetadata() {
+    return Velodrome.addPerFieldVelodromeMetadata();
+  }
+  
+  public int getNumStaticMetadataSlots() {
+    return Velodrome.jtocMetadataReferencesIndex;
+  }
+  
+  public void traceStaticMetadataSlots() {
+    TraceLocal trace = ((ParallelCollector) VM.activePlan.collector()).getCurrentTrace();
+    // This thread as a collector
+    final CollectorContext cc = RVMThread.getCurrentThread().getCollectorContext();
+    // The number of collector threads
+    final int numberOfCollectors = cc.parallelWorkerCount();
+    int numberOfSlots = VM.objectModel.getNumStaticMetadataSlots();
+    // The size to give each thread
+    final int chunkSize = (numberOfSlots / numberOfCollectors);
+    // The number of this collector thread (1...n)
+    final int threadOrdinal = cc.parallelWorkerOrdinal();
+    
+    // Start and end of statics region to be processed
+    final int start = threadOrdinal * chunkSize;
+    final int leftovers = numberOfSlots - numberOfCollectors * chunkSize;
+    final int end = (threadOrdinal + 1 == numberOfCollectors) ? (threadOrdinal + 1) * chunkSize - 1 + leftovers 
+                                                              : (threadOrdinal + 1) * chunkSize - 1;
+    OffsetArray array = Velodrome.jtocMetadataReferences;
+    ObjectReference oldObj;
+    ObjectReference newObj;
+    
+    for (int i = start; i <= end; i++) {
+      Offset off = array.get(i);
+      Address addr = Magic.getJTOC().plus(off);
+      oldObj = addr.loadObjectReference();
+      if (!oldObj.isNull()) {
+        if (trace.isLive(oldObj)) {
+          newObj = trace.getForwardedReference(oldObj);
+          if (VM.VERIFY_ASSERTIONS) {
+            Address tib = newObj.toAddress().loadAddress(JavaHeader.getTibOffset());
+            VM.assertions._assert(tib.EQ(Velodrome.tibForTransaction) || tib.EQ(Velodrome.tibForReadHashMap)); 
+          }
+          VM.activePlan.global().storeObjectReference(addr, newObj);
+        } else {
+          VM.activePlan.global().storeObjectReference(addr, ObjectReference.nullReference());
+        }
+      }
+    }
+    
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/TraceInterface.java workspace/velodrome-sound/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/TraceInterface.java
--- workspace/jikesrvm-3.1.3/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/TraceInterface.java	2013-02-12 13:28:43.000000000 -0500
+++ workspace/velodrome-sound/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/TraceInterface.java	2014-04-03 17:43:53.254704173 -0400
@@ -158,7 +158,8 @@ import org.vmmagic.unboxed.Word;
               for (int j = iei; j >= 0 && allocCall;
                    j = OptEncodedCallSiteTree.getParent(j,inlineEncoding)) {
                 int mid = OptEncodedCallSiteTree.getMethodID(j, inlineEncoding);
-                m = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember();
+                // Octet: Static cloning: Support multiple resolved methods for every method reference.
+                m = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember(compiledMethod.getMethod().getStaticContext());
                 if (!isAllocCall(m.getName().getBytes()))
                   allocCall = false;
                 if (j > 0)
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/ControllerCollectorContext.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/ControllerCollectorContext.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/ControllerCollectorContext.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/ControllerCollectorContext.java	2014-04-03 17:43:52.543701837 -0400
@@ -84,6 +84,9 @@ public class ControllerCollectorContext 
       // Stop all mutator threads
       if (Options.verbose.getValue() >= 5) Log.writeln("[STWController: Stopping the world...]");
       VM.collection.stopAllMutators();
+      
+      // Velodrome: Debugging method
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(VM.objectModel.testOctetThreadsBeforeGCStarts()); }
 
       // Was this user triggered?
       boolean userTriggeredCollection = Plan.isUserTriggeredCollection();
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/generational/Gen.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/generational/Gen.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/generational/Gen.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/generational/Gen.java	2014-04-03 17:43:52.932703115 -0400
@@ -15,7 +15,6 @@ package org.mmtk.plan.generational;
 import org.mmtk.plan.*;
 import org.mmtk.policy.CopySpace;
 import org.mmtk.policy.Space;
-
 import org.mmtk.utility.deque.*;
 import org.mmtk.utility.heap.Map;
 import org.mmtk.utility.heap.VMRequest;
@@ -23,9 +22,7 @@ import org.mmtk.utility.Log;
 import org.mmtk.utility.options.Options;
 import org.mmtk.utility.sanitychecker.SanityChecker;
 import org.mmtk.utility.statistics.*;
-
 import org.mmtk.vm.VM;
-
 import org.vmmagic.pragma.*;
 import org.vmmagic.unboxed.*;
 
@@ -65,9 +62,18 @@ public abstract class Gen extends StopTh
   public static final boolean USE_OBJECT_BARRIER_FOR_PUTFIELD = false; // choose between slot and object barriers
   public static final boolean USE_OBJECT_BARRIER = USE_OBJECT_BARRIER_FOR_AASTORE || USE_OBJECT_BARRIER_FOR_PUTFIELD;
 
+  // Octet: Get more virtual memory by decreasing the fixed amount of virtual memory for the nursery
+  // (This may cause problems if GC is deferred a lot.  Note that GC will get triggered by default when the nursery fills to 32 MB.)
   /** Fraction of available virtual memory to give to the nursery (if contiguous) */
-  protected static final float NURSERY_VM_FRACTION = 0.15f;
-
+  //protected static final float NURSERY_VM_FRACTION = 0.15f;
+  private static final int NURSERY_VM_MB = 64;
+  protected static final float NURSERY_VM_FRACTION = Space.getFracForMB(NURSERY_VM_MB);
+  static {
+    if (VM.VERIFY_ASSERTIONS) {
+      VM.assertions._assert(Space.getFracAvailable(NURSERY_VM_FRACTION).toInt() == NURSERY_VM_MB << LOG_BYTES_IN_MBYTE);  
+    }
+  }
+  
   /** Switch between a contiguous and discontiguous nursery (experimental) */
   static final boolean USE_DISCONTIGUOUS_NURSERY = false;
 
@@ -347,7 +353,7 @@ public abstract class Gen extends StopTh
    * @return {@code true} if the object resides within the nursery
    */
   @Inline
-  static boolean inNursery(ObjectReference obj) {
+  public static boolean inNursery(ObjectReference obj) { // Velodrome: Made the method public
     return inNursery(obj.toAddress());
   }
 
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/generational/GenMutator.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/generational/GenMutator.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/generational/GenMutator.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/generational/GenMutator.java	2014-04-03 17:43:52.855702861 -0400
@@ -12,19 +12,27 @@
  */
 package org.mmtk.plan.generational;
 
-import org.mmtk.plan.*;
+import static org.mmtk.plan.generational.Gen.USE_OBJECT_BARRIER_FOR_AASTORE;
+import static org.mmtk.plan.generational.Gen.USE_OBJECT_BARRIER_FOR_PUTFIELD;
+
+import org.mmtk.plan.MutatorContext;
+import org.mmtk.plan.StopTheWorldMutator;
 import org.mmtk.policy.CopyLocal;
 import org.mmtk.policy.Space;
 import org.mmtk.utility.HeaderByte;
-import org.mmtk.utility.deque.*;
 import org.mmtk.utility.alloc.Allocator;
+import org.mmtk.utility.deque.AddressPairDeque;
+import org.mmtk.utility.deque.ObjectReferenceDeque;
+import org.mmtk.utility.deque.WriteBuffer;
 import org.mmtk.utility.statistics.Stats;
 import org.mmtk.vm.VM;
-import static org.mmtk.plan.generational.Gen.USE_OBJECT_BARRIER_FOR_AASTORE;
-import static org.mmtk.plan.generational.Gen.USE_OBJECT_BARRIER_FOR_PUTFIELD;
-
-import org.vmmagic.pragma.*;
-import org.vmmagic.unboxed.*;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
 
 /**
  * This abstract class implements <i>per-mutator thread</i> behavior
@@ -156,6 +164,13 @@ import org.vmmagic.unboxed.*;
     VM.barriers.objectReferenceWrite(src, tgt, metaDataA, metaDataB, mode);
   }
 
+  /** Octet: "pre-barrier" that performs just the barrier without actually doing the write */
+  @Inline
+  public final void objectReferencePreWrite(ObjectReference src, Address slot,
+      ObjectReference tgt, Word metaDataA,
+      Word metaDataB, int mode) {
+    fastPath(src, slot, tgt, mode);
+  }
 
   /**
    * Perform the root write barrier fast path, which may involve remembering
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/MutatorContext.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/MutatorContext.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/MutatorContext.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/MutatorContext.java	2014-04-03 17:43:53.049703500 -0400
@@ -1113,6 +1113,13 @@ public abstract class MutatorContext imp
     if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(false);
   }
 
+  /** Octet: support for "pre-barriers" that don't actually perform the write. */
+  public void objectReferencePreWrite(ObjectReference src, Address slot, ObjectReference value, Word metaDataA, Word metaDataB, int mode) {
+    // Either: write barriers are used and this is overridden, or
+    // write barriers are not used and this is never called
+    if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(false);
+  }
+
   /**
    * Read an object reference. Take appropriate read barrier action, and
    * return the value that was read.<p> This is a <b>substituting<b>
@@ -1245,6 +1252,30 @@ public abstract class MutatorContext imp
     // write barriers are not used and this is a no-op
   }
 
+  // Octet: Support for indicating allocation in uninterruptible code (so GC knows it shouldn't happen immediately).
+  // Octet: TODO: Name these better.
+
+  private int allocatingInUninterruptibleCodeDepth;
+
+  @Inline
+  public final boolean isAllocatingInUninterruptibleCode() {
+    return allocatingInUninterruptibleCodeDepth > 0;
+  }
+  
+  @Inline
+  public final void startAllocatingInUninterruptibleCode() {
+    // This assertion would disallow nesting.  Nesting should be fine, but it could be interesting to know if nesting never happens.
+    //if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(allocatingInUninterruptibleCodeDepth == 0); }
+    ++allocatingInUninterruptibleCodeDepth;
+  }
+  
+  @Inline
+  public final void stopAllocatingInUninterruptibleCode() {
+    int depth = --allocatingInUninterruptibleCodeDepth;
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(depth >= 0); }
+    // As of Jikes 3.1.2, we apparently don't need to check explicitly if an asynchronous collection has been triggered.
+  }
+  
   /***********************************************************************
    *
    * Miscellaneous
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/Plan.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/Plan.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/Plan.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/Plan.java	2014-04-03 17:43:52.542701834 -0400
@@ -648,7 +648,8 @@ public abstract class Plan implements Co
   /**
    *
    */
-  protected static boolean insideHarness = false;
+  // Octet: made public (to help stats that need to know)
+  public static boolean insideHarness = false;
 
   /**
    * Generic hook to allow benchmarks to be harnessed.  A plan may use
@@ -855,7 +856,9 @@ public abstract class Plan implements Co
    */
   public final boolean poll(boolean spaceFull, Space space) {
     if (collectionRequired(spaceFull, space)) {
-      if (space == metaDataSpace) {
+      // Octet: support allocation in uninterruptible code by deferring GC
+      if (space == metaDataSpace ||
+          VM.activePlan.mutator().isAllocatingInUninterruptibleCode()) {
         /* In general we must not trigger a GC on metadata allocation since
          * this is not, in general, in a GC safe point.  Instead we initiate
          * an asynchronous GC, which will occur at the next safe point.
@@ -870,7 +873,9 @@ public abstract class Plan implements Co
     }
 
     if (concurrentCollectionRequired()) {
-      if (space == metaDataSpace) {
+      // Octet: support allocation in uninterruptible code by deferring GC
+      if (space == metaDataSpace ||
+          VM.activePlan.mutator().isAllocatingInUninterruptibleCode()) {
         logPoll(space, "Triggering async concurrent collection");
         triggerInternalCollectionRequest();
         return false;
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/SimpleCollector.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/SimpleCollector.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/SimpleCollector.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/SimpleCollector.java	2014-04-03 17:43:53.050703503 -0400
@@ -12,13 +12,14 @@
  */
 package org.mmtk.plan;
 
+import org.mmtk.plan.generational.Gen;
 import org.mmtk.utility.Log;
 import org.mmtk.utility.options.Options;
 import org.mmtk.utility.sanitychecker.SanityCheckerLocal;
-
 import org.mmtk.vm.VM;
-
-import org.vmmagic.pragma.*;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
 
 /**
  * This class (and its sub-classes) implement <i>per-collector thread</i>
@@ -138,6 +139,29 @@ public abstract class SimpleCollector ex
       // Nothing to do
       return;
     }
+    
+    // Velodrome: Added a phase for processing metadata references
+    if (phaseId == Gen.VELODROME_METADATA) {
+      TraceLocal trace = ((ParallelCollector) VM.activePlan.collector()).getCurrentTrace();
+      if (!global().isCurrentGCNursery()) {
+        while (!trace.metadataSlots.isEmpty()) {
+          Address mdSlot = trace.metadataSlots.pop();
+          VM.objectModel.traceMetadataReferencesDuringFullHeap(trace, mdSlot);
+        }
+      } else {
+        while (!trace.metadataSlots.isEmpty()) {
+          Address mdSlot = trace.metadataSlots.pop();
+          VM.objectModel.updateMetadataSlotsDuringNursery(trace, mdSlot);
+        }
+      } 
+      VM.objectModel.traceStaticMetadataSlots(); // Scan statics
+      
+      // Velodrome: LATER: Is this required? Mike says that only the mutator generates remset entries.
+      // Flush out any remset entries generated during the above activities
+      VM.objectModel.flushRememberedSets();
+      if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(trace.metadataSlots.isFlushed()); }
+      return;
+    }
 
     if (Options.sanityCheck.getValue() && sanityLocal.collectionPhase(phaseId, primary)) {
       return;
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/Simple.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/Simple.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/Simple.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/Simple.java	2014-04-03 17:43:52.989703302 -0400
@@ -16,11 +16,11 @@ import org.mmtk.policy.Space;
 import org.mmtk.utility.Constants;
 import org.mmtk.utility.Log;
 import org.mmtk.utility.alloc.Allocator;
-import org.mmtk.utility.options.*;
+import org.mmtk.utility.options.Options;
 import org.mmtk.utility.statistics.Timer;
 import org.mmtk.vm.VM;
-
-import org.vmmagic.pragma.*;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
 
 /**
  * This abstract class implements the core functionality for
@@ -63,6 +63,8 @@ public abstract class Simple extends Pla
   public static final short FORWARD_FINALIZABLE = Phase.createSimple("forward-finalize", finalizeTime);
   public static final short RELEASE             = Phase.createSimple("release");
   public static final short COMPLETE            = Phase.createSimple("complete", null);
+  // Velodrome: Added a phase to scan metadata references as weak references
+  public static final short VELODROME_METADATA  = Phase.createSimple("velodrome-metadata-trace", refTypeTime);
 
   /* Sanity placeholder */
   public static final short PRE_SANITY_PLACEHOLDER  = Phase.createSimple("pre-sanity-placeholder", null);
@@ -131,10 +133,17 @@ public abstract class Simple extends Pla
       Phase.scheduleCollector  (CLOSURE),
       Phase.scheduleCollector  (WEAK_REFS),
       Phase.scheduleCollector  (FINALIZABLE),
+      // Velodrome: Added a phase for processing metadata references. It is important to be after the 
+      // FINALIZABLE phase since new objects are marked gray, that are then added to the Velodrome queue.      
+      Phase.scheduleCollector  (VELODROME_METADATA),
       Phase.scheduleGlobal     (CLOSURE),
       Phase.scheduleCollector  (CLOSURE),
       Phase.schedulePlaceholder(WEAK_TRACK_REFS),
-      Phase.scheduleCollector  (PHANTOM_REFS));
+      Phase.scheduleCollector  (PHANTOM_REFS),
+      // Velodrome: Added a phase for processing metadata references. It is important to be after the 
+      // FINALIZABLE phase since new objects are marked gray, that are then added to the Velodrome queue.
+      Phase.scheduleCollector  (VELODROME_METADATA)
+      );
 
   /**
    * Ensure that all references in the system are correct.
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/Trace.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/Trace.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/Trace.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/Trace.java	2014-04-03 17:43:52.542701834 -0400
@@ -14,8 +14,8 @@ package org.mmtk.plan;
 
 import org.mmtk.utility.Constants;
 import org.mmtk.utility.deque.SharedDeque;
+import org.mmtk.vm.VM;
 import org.mmtk.policy.RawPageSpace;
-
 import org.vmmagic.pragma.*;
 
 /**
@@ -29,13 +29,20 @@ public class Trace implements Constants 
   // Global pools for load-balancing deques
   final SharedDeque valuePool;
   final SharedDeque rootLocationPool;
-
+  
+  // Velodrome: Global pool to store metadata slot addresses
+  final SharedDeque metadataSlotsPool; 
+  
   /**
    * Constructor
    */
   public Trace(RawPageSpace metaDataSpace) {
     valuePool = new SharedDeque("valuePool",metaDataSpace, 1);
     rootLocationPool = new SharedDeque("rootLocations", metaDataSpace, 1);
+    
+    // Velodrome: Global pool to store metadata slot addresses
+    metadataSlotsPool = new SharedDeque("metadataSlotsPool", metaDataSpace, 1); 
+    
   }
 
   /**
@@ -44,6 +51,10 @@ public class Trace implements Constants 
   public void prepareNonBlocking() {
     valuePool.prepareNonBlocking();
     rootLocationPool.prepareNonBlocking();
+    
+    // Velodrome: Global pool to store metadata slot addresses
+    metadataSlotsPool.prepareNonBlocking();
+    
   }
 
   /**
@@ -53,6 +64,10 @@ public class Trace implements Constants 
   public void prepare() {
     valuePool.prepare();
     rootLocationPool.prepareNonBlocking();
+    
+    // Velodrome: Global pool to store metadata slot addresses
+    metadataSlotsPool.prepareNonBlocking();
+    
   }
 
   /**
@@ -61,12 +76,21 @@ public class Trace implements Constants 
   public void release() {
     valuePool.reset();
     rootLocationPool.reset();
+    
+    // Velodrome: Global pool to store metadata slot addresses
+    //metadataSlotsPool.clearDeque(1);
+    metadataSlotsPool.reset(); // Velodrome: TODO: Why does a reset() fail?
+    
   }
 
   /**
    * Is there any work outstanding in this trace. That is are there any pages in the pools.
    */
   public boolean hasWork() {
+    
+    // Velodrome: I don't think we need to add metadataSlotsPool here, for now. This is only for concurrent collectors.
+    if (VM.VERIFY_ASSERTIONS) { VM.assertions._assert(false); }
+    
     return (valuePool.enqueuedPages() + rootLocationPool.enqueuedPages()) > 0;
   }
 }
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/TraceLocal.java workspace/velodrome-sound/MMTk/src/org/mmtk/plan/TraceLocal.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/plan/TraceLocal.java	2013-02-12 13:28:44.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/plan/TraceLocal.java	2014-04-03 17:43:52.820702747 -0400
@@ -15,13 +15,15 @@ package org.mmtk.plan;
 import org.mmtk.policy.Space;
 import org.mmtk.utility.Constants;
 import org.mmtk.utility.Log;
-import org.mmtk.utility.deque.*;
+import org.mmtk.utility.deque.AddressDeque;
+import org.mmtk.utility.deque.ObjectReferenceDeque;
 import org.mmtk.utility.options.Options;
-
 import org.mmtk.vm.VM;
-
-import org.vmmagic.pragma.*;
-import org.vmmagic.unboxed.*;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
 
 /**
  * This abstract class and its global counterpart implement the core
@@ -43,6 +45,9 @@ public abstract class TraceLocal extends
   protected final ObjectReferenceDeque values;
   /** delayed root slots */
   protected final AddressDeque rootLocations;
+  
+  // Velodrome: Per-collector thread queue to store metadata slot addresses
+  public AddressDeque metadataSlots;
 
   /****************************************************************************
    *
@@ -68,6 +73,10 @@ public abstract class TraceLocal extends
     super(specializedScan);
     values = new ObjectReferenceDeque("value", trace.valuePool);
     rootLocations = new AddressDeque("roots", trace.rootLocationPool);
+    
+    // Velodrome: Global pool to store metadata slot addresses
+    metadataSlots = new AddressDeque("metadataSlots", trace.metadataSlotsPool);
+    
   }
 
   /****************************************************************************
@@ -200,6 +209,21 @@ public abstract class TraceLocal extends
   @Inline
   public final void processNode(ObjectReference object) {
     values.push(object);
+    
+    // Velodrome: The objects have been moved by now if required, and for both nursery and full heap GC, they have not 
+    // yet been scanned. See CopySpace or GenImmixMatureTraceLocal.traceObject(). 
+    // We obviously need to populate the queue for full heap GCs. We need to do so for nursery GCs as well, although we 
+    // are continuing to use generational barriers for stores. Consider the following scenario: the metadata slot and 
+    // the referent could both be in nursery. So the metadata slot is not added to the remset, and the referent gets 
+    // moved to the mature space.
+    
+    if (VM.objectModel.addPerFieldVelodromeMetadata() /*&& !Options.sanityCheck.getValue()*/) { // Ignore sanity checking
+      VM.objectModel.addMetadataSlotsToQueue(object); // Add object to MMTk queue so that metadata references can be traced later
+    }    
+    //VM.objectModel.traceLockMetadata(object); // Velodrome: Add lock metadata slot to weak reference queue
+    // Velodrome: Add object-level reference slots to weak reference queue
+    VM.objectModel.traceObjectLevelMetadata(object);
+    
   }
 
   /**
@@ -208,6 +232,10 @@ public abstract class TraceLocal extends
   public final void flush() {
     values.flushLocal();
     rootLocations.flushLocal();
+    
+    // Velodrome: Global pool to store metadata slot addresses
+    metadataSlots.flushLocal();
+    
   }
 
   /**
@@ -463,6 +491,10 @@ public abstract class TraceLocal extends
   public void release() {
     values.reset();
     rootLocations.reset();
+    
+    // Velodrome: Per-collector thread queue to store metadata slot addresses
+    metadataSlots.reset();
+    
   }
 
   /**
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/policy/immix/ImmixConstants.java workspace/velodrome-sound/MMTk/src/org/mmtk/policy/immix/ImmixConstants.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/policy/immix/ImmixConstants.java	2013-02-12 13:28:45.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/policy/immix/ImmixConstants.java	2014-04-03 17:43:51.412698121 -0400
@@ -68,7 +68,8 @@ public class ImmixConstants {
          static final short MAX_CONSV_SPILL_COUNT = (short) (LINES_IN_BLOCK/2);
   public static final short SPILL_HISTOGRAM_BUCKETS = (short) (MAX_CONSV_SPILL_COUNT + 1);
   public static final short MARK_HISTOGRAM_BUCKETS = (short) (LINES_IN_BLOCK + 1);
-         static final short MAX_COLLECTORS = 16; // nothing special here---we can increase this at the cost of a few hundred bites at build time.
+  // Octet: increment the maximum number of collectors from 16 to 64.
+  static final short MAX_COLLECTORS = 64; // nothing special here---we can increase this at the cost of a few hundred bites at build time.
 
   public static final Word RECYCLE_ALLOC_CHUNK_MASK = Word.fromIntZeroExtend(BYTES_IN_RECYCLE_ALLOC_CHUNK - 1);
   protected static final Word CHUNK_MASK = Word.fromIntZeroExtend(BYTES_IN_CHUNK - 1);
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/policy/Space.java workspace/velodrome-sound/MMTk/src/org/mmtk/policy/Space.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/policy/Space.java	2013-02-12 13:28:45.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/policy/Space.java	2014-04-03 17:43:51.409698112 -0400
@@ -765,4 +765,10 @@ public abstract class Space implements C
     Extent rtn = mb.lsh(LOG_BYTES_IN_MBYTE).toExtent();
     return chunkAlign(rtn, false);
   }
+  
+  /** Octet: helps us specify a virtual memory fraction that will yield a desired number of MBs */
+  public static float getFracForMB(int mb) {
+    return (float)(mb << LOG_BYTES_IN_MBYTE) / AVAILABLE_BYTES.toLong();
+  }
+  
 }
diff -rupN workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/vm/ObjectModel.java workspace/velodrome-sound/MMTk/src/org/mmtk/vm/ObjectModel.java
--- workspace/jikesrvm-3.1.3/MMTk/src/org/mmtk/vm/ObjectModel.java	2013-02-12 13:28:45.000000000 -0500
+++ workspace/velodrome-sound/MMTk/src/org/mmtk/vm/ObjectModel.java	2014-04-03 17:43:51.651698905 -0400
@@ -12,6 +12,7 @@
  */
 package org.mmtk.vm;
 
+import org.mmtk.plan.TraceLocal;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.*;
 
@@ -255,4 +256,26 @@ public abstract class ObjectModel {
   static Offset arrayBaseOffsetTrapdoor(ObjectModel o) {
     return o.getArrayBaseOffset();
   }
+  
+  // Velodrome: Methods to implement weak tracing of metadata references
+  
+  public abstract void addMetadataSlotsToQueue(ObjectReference objRef);
+  public abstract void traceMetadataReferencesDuringFullHeap(TraceLocal trace, Address mdSlot);
+  public abstract void updateMetadataSlotsDuringNursery(TraceLocal trace, Address mdSlot);
+  public abstract void traceStaticMetadataSlots();
+  // Velodrome: Trace lock access metadata
+  public abstract void traceLockMetadata(ObjectReference object, TraceLocal trace); 
+  public abstract void traceLockMetadata(ObjectReference object);
+  public abstract void traceObjectLevelMetadata(ObjectReference object);
+  
+  // Velodrome: Helper methods
+  public abstract boolean checkForReadmap(ObjectReference newObject, ObjectReference oldObject);
+  public abstract boolean checkForReadmapDuringTracing(ObjectReference source, Address slot, ObjectReference newObj);
+  public abstract boolean checkForReadmapFromRoot(Address slot, ObjectReference newObj, ObjectReference oldObj);
+  public abstract void flushRememberedSets();
+  public abstract boolean testOctetThreadsBeforeGCStarts();
+  public abstract boolean validRef(ObjectReference objRef);
+  public abstract boolean addPerFieldVelodromeMetadata();
+  public abstract int getNumStaticMetadataSlots();
+
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/adaptive/database/callgraph/PartialCallGraph.java workspace/velodrome-sound/rvm/src/org/jikesrvm/adaptive/database/callgraph/PartialCallGraph.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/adaptive/database/callgraph/PartialCallGraph.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/adaptive/database/callgraph/PartialCallGraph.java	2014-04-03 17:43:41.959667051 -0400
@@ -111,7 +111,8 @@ public final class PartialCallGraph impl
       unresolvedTargets.visitTargets(new UnResolvedWeightedCallTargets.Visitor() {
         @Override
         public void visit(MethodReference calleeRef, double weight) {
-          RVMMethod callee = calleeRef.getResolvedMember();
+          // Octet: Static cloning: Support multiple resolved methods for every method reference.
+          RVMMethod callee = calleeRef.getResolvedMember(fCaller.getStaticContext());
           if (callee != null) {
             pg.incrementEdge(fCaller, fBcIndex, callee, (float) weight);
           }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/adaptive/recompilation/BulkCompile.java workspace/velodrome-sound/rvm/src/org/jikesrvm/adaptive/recompilation/BulkCompile.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/adaptive/recompilation/BulkCompile.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/adaptive/recompilation/BulkCompile.java	2014-04-03 17:43:42.019667249 -0400
@@ -18,6 +18,7 @@ import org.jikesrvm.adaptive.controller.
 import org.jikesrvm.adaptive.util.AOSLogging;
 import org.jikesrvm.adaptive.util.CompilerAdvice;
 import org.jikesrvm.adaptive.util.CompilerAdviceAttribute;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMClassLoader;
 import org.jikesrvm.classloader.RVMMethod;
@@ -122,7 +123,9 @@ public class BulkCompile implements Call
         }
 
         // Find the method
-        RVMMethod method = cls.findDeclaredMethod(value.getMethodName(), value.getMethodSig());
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
+        // Velodrome: Context: Blindly using TRANS_CONTEXT for now
+        RVMMethod method = cls.findDeclaredMethod(value.getMethodName(), value.getMethodSig(), Context.TRANS_CONTEXT);
 
 
         // If found, compile it
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/adaptive/util/DynamicCallFileInfoReader.java workspace/velodrome-sound/rvm/src/org/jikesrvm/adaptive/util/DynamicCallFileInfoReader.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/adaptive/util/DynamicCallFileInfoReader.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/adaptive/util/DynamicCallFileInfoReader.java	2014-04-03 17:43:41.846666682 -0400
@@ -20,6 +20,7 @@ import java.util.StringTokenizer;
 import org.jikesrvm.VM;
 import org.jikesrvm.adaptive.controller.Controller;
 import org.jikesrvm.adaptive.database.callgraph.PartialCallGraph;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClassLoader;
 import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMMethod;
@@ -131,10 +132,17 @@ public class DynamicCallFileInfoReader {
    * @param ref The MethodReference
    * @return The RVMMethod, or {@code null} on failure.
    */
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
   private static RVMMethod getMethod(MethodReference ref) {
+    // Velodrome: Context: Pass the appropriate context based on whether a method reference is supposed to be non-atomic
+    int context = Context.TRANS_CONTEXT;
+    if (ref.isNonAtomic) {
+      context = Context.NONTRANS_CONTEXT;
+    }
+
     if (ref.getType().getClassLoader() == RVMClassLoader.getApplicationClassLoader()) {
       try {
-        return ref.resolve();
+        return ref.resolve(context);
       } catch (NoClassDefFoundError e) {
         if (Controller.options.BULK_COMPILATION_VERBOSITY >= 1)
           VM.sysWriteln("Warning: could not define class: " + ref.getType());
@@ -145,7 +153,7 @@ public class DynamicCallFileInfoReader {
         return null;
       }
     } else {
-      return ref.getResolvedMember();
+      return ref.getResolvedMember(context);
     }
   }
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/AbstractMethod.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/AbstractMethod.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/AbstractMethod.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/AbstractMethod.java	2014-04-03 17:43:50.078693737 -0400
@@ -20,6 +20,8 @@ import org.jikesrvm.runtime.Entrypoints;
  */
 public final class AbstractMethod extends RVMMethod {
 
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+
   /**
    * Construct abstract method information
    *
@@ -34,7 +36,7 @@ public final class AbstractMethod extend
    */
   AbstractMethod(TypeReference declaringClass, MemberReference memRef, short modifiers,
                     TypeReference[] exceptionTypes, Atom signature, RVMAnnotation[] annotations,
-                    RVMAnnotation[][] parameterAnnotations, Object annotationDefault) {
+                    RVMAnnotation[][] parameterAnnotations, Object annotationDefault, int resolvedContext) {
     super(declaringClass,
           memRef,
           modifiers,
@@ -42,9 +44,18 @@ public final class AbstractMethod extend
           signature,
           annotations,
           parameterAnnotations,
-          annotationDefault);
+          annotationDefault,
+          resolvedContext);
   }
 
+  AbstractMethod(AbstractMethod method, int resolvedContext) {
+    super(method, resolvedContext);
+  }
+  
+  RVMMethod cloneMethod(int resolvedContext) {
+    return new AbstractMethod(this, resolvedContext);
+  }
+  
   /**
    * By definition, abstract methods do not have associated code. Therefore,
    * this method will return an error handling method from
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/AnnotatedElement.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/AnnotatedElement.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/AnnotatedElement.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/AnnotatedElement.java	2014-04-03 17:43:50.080693745 -0400
@@ -57,6 +57,12 @@ public abstract class AnnotatedElement i
     }
   }
 
+  /** Octet: Static cloning: Support multiple resolved methods for every method reference. */
+  protected AnnotatedElement(AnnotatedElement ae) {
+    this.declaredAnnotations = ae.declaredAnnotations;
+    this.declaredAnnotationDatas = ae.declaredAnnotationDatas;
+  }
+
   /**
    * Read annotations from a class file and package in an array
    * @param constantPool the constantPool of the RVMClass object
@@ -167,6 +173,15 @@ public abstract class AnnotatedElement i
    */
   @Override
   public final boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
+    // Octet: Avoid triggering classloading unnecessarily. Otherwise the opt compiler
+    // might call a custom classloader, violating the invariant that VM threads don't call application context code.
+    if (hasAnnotations() && // Has annotations,
+        declaredAnnotations == null && // but those annotations haven't been loaded yet.
+        Context.isVMPrefix(TypeReference.findOrCreate(annotationClass)) && // Annotation is VM context,
+        //((RVMMember)this).getDeclaringClass().getClassLoader() 
+        true /*((RVMMethod)this).getStaticContext() == Context.APP_CONTEXT*/) { // but method is application context.
+      return isAnnotationDeclared(TypeReference.findOrCreate(annotationClass));
+    }
     return getAnnotation(annotationClass) != null;
   }
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/Atom.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/Atom.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/Atom.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/Atom.java	2014-04-03 17:43:50.085693761 -0400
@@ -783,6 +783,23 @@ public final class Atom {
     return false;
   }
 
+  /** Octet: Static cloning: Help decision-making for deciding static contexts. */
+  @Uninterruptible
+  @Pure
+  public boolean isPrefix(byte[][] prefixes) {
+    outer:
+      for (final byte[] test : prefixes) {
+        if (test.length > val.length) continue;
+        for (int j = 0; j < test.length; j++) {
+          if (val[j] != test[j]) {
+            continue outer;
+          }
+        }
+        return true;
+      }
+    return false;
+  }
+  
   /**
    * @return true if this is a class descriptor of a RVM core class.  This is
    * defined as one that it would be unwise to invalidate, since invalidating
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/ClassFileReader.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/ClassFileReader.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/ClassFileReader.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/ClassFileReader.java	2014-04-03 17:43:50.081693749 -0400
@@ -310,15 +310,28 @@ public class ClassFileReader implements 
     if (numMethods == 0) {
       declaredMethods = RVMType.emptyVMMethod;
     } else {
-      declaredMethods = new RVMMethod[numMethods];
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      // Velodrome: Context: Different categories of methods may have different number of static contexts
+      if (Context.hasMultipleStaticContexts(typeRef)) {
+        declaredMethods = new RVMMethod[numMethods * Context.getNumberOfStaticContexts(typeRef)];
+      } else {
+        declaredMethods = new RVMMethod[numMethods];
+      }
+      int numMethodsInclContexts = 0;
       for (int i = 0; i < numMethods; i++) {
         short mmodifiers = input.readShort();
         Atom methodName = getUtf(constantPool, input.readUnsignedShort());
         Atom methodDescriptor = getUtf(constantPool, input.readUnsignedShort());
         MemberReference memRef = MemberReference.findOrCreate(typeRef, methodName, methodDescriptor);
-        RVMMethod method = RVMMethod.readMethod(typeRef, constantPool, memRef, mmodifiers, input);
-        declaredMethods[i] = method;
+        int[] staticContexts = Context.getStaticContexts(memRef.asMethodReference());
+        RVMMethod method = RVMMethod.readMethod(typeRef, constantPool, memRef, mmodifiers, input, staticContexts[0]);
+        declaredMethods[numMethodsInclContexts++] = method;
+        // Velodrome: Context: Create additional RVMMethods as necessary 
+        for (int j = 1; j < staticContexts.length; j++) {
+          declaredMethods[numMethodsInclContexts++] = method.cloneMethod(staticContexts[j]);
+        }
       }
+      if (VM.VerifyAssertions) { VM._assert(numMethodsInclContexts == declaredMethods.length); } 
     }
     return declaredMethods;
   }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/Context.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/Context.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/Context.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/Context.java	2014-04-03 17:43:50.090693776 -0400
@@ -0,0 +1,294 @@
+package org.jikesrvm.classloader;
+
+import org.jikesrvm.Callbacks;
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+// Velodrome: Context: Changed this class extensively to support two static contexts (transactional and non-transactional) 
+// for application methods. VM and library methods are not instrumented by AVD or Velodrome, so it is not required to 
+// distinguish their contexts. Hence they currently have only one VM context. Application methods which override VM or
+// library methods will have an additional RVMMethod with VM context as resolved context.
+
+/** Octet: Static cloning: Represent context statically, e.g., application versus VM context. */
+@Uninterruptible
+public final class Context implements Constants {
+
+  public static final int VM_CONTEXT = 0;
+  public static final int TRANS_CONTEXT = 1;
+  public static final int NONTRANS_CONTEXT = 2;
+  public static final int INVALID_CONTEXT = -1;
+  
+  // This seems to work okay, but maybe the stack-walking isn't checking JNI calls correctly.
+  // Octet: TODO: trying this -- it seems like the right thing to do
+  public static final int JNI_CONTEXT = VM_CONTEXT; //APP_CONTEXT;
+
+  // Not clear what we should do about finalizers.
+  public static final int FINALIZER_CONTEXT = VM_CONTEXT;
+
+  private static final int[] LIBRARY_CONTEXT_ONLY = { VM_CONTEXT }; // Library methods
+  private static final int[] VM_CONTEXT_ONLY = { VM_CONTEXT }; // VM methods
+  // Most application methods, certain application methods can also possibly override library methods
+  private static final int[] APP_CONTEXTS = { TRANS_CONTEXT, NONTRANS_CONTEXT }; 
+  
+  @Inline
+  public static boolean isTRANSContext(int context) {
+    return (context == TRANS_CONTEXT);
+  }
+  
+  @Inline
+  public static boolean isNONTRANSContext(int context) {
+    return (context == NONTRANS_CONTEXT);
+  }
+  
+  @Pure
+  static int getLoneStaticContext(MethodReference methodRef) {
+    int[] contexts = getStaticContexts(methodRef);
+    if (VM.VerifyAssertions) { VM._assert(contexts.length == 1); }
+    return contexts[0];
+  }
+  
+  @Pure
+  static int[] getStaticContexts(MethodReference methodRef) {
+    return getStaticContexts(methodRef.getType());
+  }
+
+  @Pure
+  static int[] getStaticContexts(TypeReference typeRef) {
+    if (isLibraryPrefix(typeRef)) {
+      return LIBRARY_CONTEXT_ONLY;
+    } else if (isVMPrefix(typeRef)) {
+      return VM_CONTEXT_ONLY;
+    } else {
+      return APP_CONTEXTS;
+    }
+  }
+
+  @Pure
+  public static boolean isLibraryPrefix(TypeReference typeRef) {
+    return typeRef.getName().isPrefix(LIBRARY_PREFIXES);
+  }
+
+  @Pure
+  public static boolean isVMPrefix(TypeReference typeRef) {
+    return typeRef.getName().isPrefix(VM_PREFIXES);
+  }
+
+  @Pure
+  public static boolean isApplicationPrefix(TypeReference typeRef) {
+    return !isLibraryPrefix(typeRef) && !isVMPrefix(typeRef);
+  }
+
+  /* Velodrome: There is a complicated relationship between few packages. For example, gnu/javax packages extend
+   * javax.* packages. Again javax.xml.* like javax.xml.* files call org.xml.sax.* methods directly.
+   * Another example is in HEDC: Lgnu/java/net/protocol/http/HTTPURLConnection; which is considered to be a library 
+   * method extends Ljavax/net/ssl/HttpsURLConnection; which is an application method.
+   * */
+  private static final byte[][] LIBRARY_PREFIXES =
+  {"Ljava/".getBytes(),
+   "Lgnu/java/".getBytes(), // There is a gnu/javax package also.
+   "Lgnu/classpath/".getBytes(),
+   "Lsun/misc/Unsafe".getBytes(),
+   //"Ljavax/".getBytes(), // Velodrome: Many benchmarks like sunflow9, xalan9 make use of this package
+   //"Lorg/xml/".getBytes(),
+  };
+
+  private static final byte[][] VM_PREFIXES = {
+    "Lorg/jikesrvm/".getBytes(),
+    "Lorg/mmtk/".getBytes(),
+    "Lorg/vmutil/".getBytes(),
+    "Lorg/vmmagic/".getBytes(),
+    "Lcom/ibm/tuningfork/".getBytes(),
+    "L$Proxy".getBytes(),
+  };
+
+  @Pure
+  public static boolean hasMultipleStaticContexts(TypeReference typeRef) {
+    return getStaticContexts(typeRef).length > 1;
+  }
+  
+  @Pure
+  public static int getNumberOfStaticContexts(TypeReference typeRef) {
+    return getStaticContexts(typeRef).length;
+  }
+
+  @Pure
+  public static boolean hasMultipleStaticContexts(MethodReference methodRef) {
+    return hasMultipleStaticContexts(methodRef.getType());
+  }
+
+  static boolean isMatch(RVMMethod rvmMethod, int context, boolean resolve) {
+    if (rvmMethod.getMemberRef().asMethodReference().hasMultipleResolvedContexts()) { // Application methods
+      return rvmMethod.getResolvedContext() == context;
+    } else if (!hasMultipleStaticContexts(rvmMethod.getMemberRef().asMethodReference())) { // Library and VM methods
+      if (resolve) { // We wan't to have precise checks over here so as to be able to clone methods
+        return rvmMethod.getStaticContext() == context;
+      } else { // Otherwise it doesn't matter which context library/VM methods get called from 
+        return true;
+      }
+    } else {
+      // Velodrome: There could be application classes that implement interfaces, but don't override an abstract method. In
+      // such cases, the application class will have only one virtual method, with resolved context set to VM_CONTEXT, 
+      // and static context depending on the meet() operation.
+      // Example: Lhedc/MetaSearchResultIterator;.next() which does not implement Ljava/util/Iterator;.next() 
+      if (hasMultipleStaticContexts(rvmMethod.getMemberRef().asMethodReference())) {
+        return true;
+      } else {
+        if (VM.VerifyAssertions) { VM._assert(NOT_REACHED); }
+        return false;
+      }
+    }
+  }
+
+  @Pure
+  static int getOtherContext(RVMMethod method, int context) {
+    if (VM.VerifyAssertions) { VM._assert(context != VM_CONTEXT); }
+    if (context == TRANS_CONTEXT) {
+      return NONTRANS_CONTEXT;
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(context == NONTRANS_CONTEXT); }
+      return TRANS_CONTEXT;
+    }
+  }
+
+  @Pure
+  static int getStaticContext(MethodReference methodRef, int resolvedContext) {
+    if (hasMultipleStaticContexts(methodRef)) {
+      return resolvedContext;
+    } else {
+      return getLoneStaticContext(methodRef);
+    }
+  }
+
+  @Pure
+  static String getName(int context) {
+    switch (context) {
+      case VM_CONTEXT: return "VM";
+      case TRANS_CONTEXT: return "TRANS";
+      case NONTRANS_CONTEXT: return "NONTRANS";
+      case INVALID_CONTEXT: return "INVALID";
+      default:
+        if (VM.VerifyAssertions) { VM._assert(NOT_REACHED); }
+        return "null";
+    }
+  }
+  
+  // Rest of this class is for debugging:
+
+  /** If enabled, dynamic instrumentation at every library method prologue checks that the contexts of the caller and callee match. */
+  public static final boolean DEBUG = VM.VerifyAssertions && false; // true
+
+//  private static final Atom reflectionBase = Atom.findOrCreateAsciiAtom("Lorg/jikesrvm/classloader/ReflectionBase;");
+//  private static final Atom invokeInternal = Atom.findOrCreateAsciiAtom("invokeInternal");
+
+  @NoInline
+  @Entrypoint
+  public static void checkLibraryContext() {
+//    if (VM.VerifyAssertions) { VM._assert(Context.DEBUG); }
+//    Address calleeFP = Magic.getCallerFramePointer(Magic.getFramePointer());
+//    Address ip = Magic.getReturnAddress(calleeFP);
+//    Address callerFP = Magic.getCallerFramePointer(calleeFP);
+//    RVMMethod callee = CompiledMethods.getCompiledMethod(Magic.getCompiledMethodID(calleeFP)).method;
+//    int callerCMID = Magic.getCompiledMethodID(callerFP);
+//    if (callerCMID == StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+//      ip = Magic.getReturnAddress(callerFP);
+//      callerFP = Magic.getCallerFramePointer(callerFP);
+//      callerCMID = Magic.getCompiledMethodID(callerFP);
+//    }
+//    CompiledMethod callerCM = CompiledMethods.getCompiledMethod(callerCMID);
+//    RVMMethod caller = null;
+//    if (VM.BuildForOptCompiler && callerCM.getCompilerType() == CompiledMethod.OPT) {
+//      OptCompiledMethod optInfo = (OptCompiledMethod)callerCM;
+//      // Opt stack frames may contain multiple inlined methods.
+//      OptMachineCodeMap map = optInfo.getMCMap();
+//      Offset instructionOffset = callerCM.getInstructionOffset(ip);
+//      int iei = map.getInlineEncodingForMCOffset(instructionOffset);
+//      if (iei >= 0) {
+//        MethodReference callerRef = null;
+//        int context = INVALID_CONTEXT;
+//        int[] inlineEncoding = map.inlineEncoding;
+//        for (; iei >= 0 && context == INVALID_CONTEXT; iei = OptEncodedCallSiteTree.getParent(iei, inlineEncoding)) {
+//          int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
+//          // Set callerRef to the leaf method 
+//          MethodReference methodRef = MemberReference.getMemberRef(mid).asMethodReference();
+//          if (callerRef == null) {
+//            callerRef = methodRef;
+//          }
+//          // Keep going until we find a lone context (i.e., a non-library method)
+//          if (!Context.hasMultipleStaticContexts(methodRef)) {
+//            context = Context.getLoneStaticContext(methodRef);
+//          }
+//        }
+//        if (context == INVALID_CONTEXT) {
+//          context = callerCM.method.getStaticContext();
+//        }
+//        caller = callerRef.getResolvedMember(context);
+//      }
+//    }
+//    if (caller == null) {
+//      caller = callerCM.method;
+//    }
+//    VM._assert(hasMultipleStaticContexts(callee.getMemberRef().asMethodReference()));
+//    if (hasMultipleStaticContexts(caller.getMemberRef().asMethodReference())) {
+//      if (caller.getStaticContext() != callee.getStaticContext()) {
+//        VM.sysWrite("caller = ");
+//        VM.sysWrite(caller);
+//        VM.sysWrite(", callee = ");
+//        VM.sysWrite(callee);
+//        VM.sysWriteln();
+//        VM.sysWrite("caller.context = ", getName(caller.getStaticContext()));
+//        VM.sysWriteln("; callee.context = ", getName(callee.getStaticContext()));
+//        VM.sysWrite("caller.contextMatters = ", Context.hasMultipleStaticContexts(caller.getMemberRef().asMethodReference()));
+//        VM.sysWriteln("; callee.contextMatters = ", Context.hasMultipleStaticContexts(callee.getMemberRef().asMethodReference()));
+//        VM._assert(false);
+//      }
+//      if (caller.getStaticContext() == VM_CONTEXT) {
+//        libCalledByLibInVmContext++;
+//      } else {
+//        VM._assert(caller.getStaticContext() == APP_CONTEXT);
+//        libCalledByLibInAppContext++;
+//      }
+//    } else {
+//      if (getLoneStaticContext(caller.getMemberRef().asMethodReference()) == APP_CONTEXT) {
+//        VM._assert(callee.getStaticContext() == APP_CONTEXT);
+//        VM._assert(caller.getStaticContext() == APP_CONTEXT);
+//        libCalledByApp++;
+//      } else {
+//        // Ignore reflection, at least for now
+//        if (caller.getDeclaringClass().getResolvedClassForType() == org.jikesrvm.runtime.Reflection.class ||
+//            caller.getDeclaringClass().getResolvedClassForType() == org.jikesrvm.runtime.ReflectionBase.class ||
+//            (caller.getDeclaringClass().getEnclosingClass() != null &&
+//             caller.getDeclaringClass().getEnclosingClass().getName() == reflectionBase) ||
+//            caller.getName() == invokeInternal) {
+//        } else {
+//          VM._assert(callee.getStaticContext() == VM_CONTEXT);
+//          VM._assert(caller.getStaticContext() == VM_CONTEXT);
+//        }
+//        libCalledByVm++;
+//      }
+//    }
+  }
+
+  static long libCalledByLibInVmContext;
+  static long libCalledByLibInAppContext;
+  static long libCalledByVm;
+  static long libCalledByApp;
+  
+  static {
+    if (DEBUG) {
+      Callbacks.addExitMonitor(new Callbacks.ExitMonitor() {      
+        public void notifyExit(int value) {
+          System.out.println("libCalledByLibInVmContext: " + libCalledByLibInVmContext);
+          System.out.println("libCalledByLibInAppContext: " + libCalledByLibInAppContext);
+          System.out.println("libCalledByVm: " + libCalledByVm);
+          System.out.println("libCalledByApp: " + libCalledByApp);
+        }
+      });
+    }
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/FieldReference.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/FieldReference.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/FieldReference.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/FieldReference.java	2014-04-03 17:43:50.086693764 -0400
@@ -108,6 +108,12 @@ public final class FieldReference extend
     resolvedMember = it;
   }
 
+  /** Octet: added this method to get resolved field without doing any resolving */
+  @Uninterruptible
+  public RVMField getResolvedField() {
+    return resolvedMember;
+  }
+  
   /**
    * Find the RVMField that this field reference refers to using
    * the search order specified in JVM spec 5.4.3.2.
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/InterfaceInvocation.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/InterfaceInvocation.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/InterfaceInvocation.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/InterfaceInvocation.java	2014-04-03 17:43:50.077693733 -0400
@@ -14,8 +14,8 @@ package org.jikesrvm.classloader;
 
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.ArchitectureSpecific.InterfaceMethodConflictResolver;
-import org.jikesrvm.VM;
 import org.jikesrvm.SizeConstants;
+import org.jikesrvm.VM;
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.objectmodel.IMT;
 import org.jikesrvm.objectmodel.ITable;
@@ -55,20 +55,21 @@ public class InterfaceInvocation impleme
    * @param mid id of the MemberReference for the target interface method.
    * @return machine code corresponding to desired interface method
    */
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
   @Entrypoint
-  public static CodeArray invokeInterface(Object target, int mid) throws IncompatibleClassChangeError {
+  public static CodeArray invokeInterface(Object target, int mid, int context) throws IncompatibleClassChangeError {
 
     MethodReference mref = MemberReference.getMemberRef(mid).asMethodReference();
-    RVMMethod sought = mref.resolveInterfaceMethod();
+    RVMMethod sought = mref.resolveInterfaceMethod(context);
     RVMClass I = sought.getDeclaringClass();
     RVMClass C = Magic.getObjectType(target).asClass();
     if (VM.BuildForITableInterfaceInvocation) {
       TIB tib = C.getTypeInformationBlock();
       ITable iTable = findITable(tib, I.getInterfaceId());
-      return iTable.getCode(getITableIndex(I, mref.getName(), mref.getDescriptor()));
+      return iTable.getCode(getITableIndex(I, mref.getName(), mref.getDescriptor(), context));
     } else {
       if (!RuntimeEntrypoints.isAssignableWith(I, C)) throw new IncompatibleClassChangeError();
-      RVMMethod found = C.findVirtualMethod(sought.getName(), sought.getDescriptor());
+      RVMMethod found = C.findVirtualMethod(sought.getName(), sought.getDescriptor(), context);
       if (found == null) throw new IncompatibleClassChangeError();
       return found.getCurrentEntryCodeArray();
     }
@@ -131,10 +132,11 @@ public class InterfaceInvocation impleme
    * @param mid     Dictionary id of the {@link MemberReference} for the target interface method.
    * @param rhsObject  The object on which we are attempting to invoke the interface method
    */
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
   @Entrypoint
-  public static void unresolvedInvokeinterfaceImplementsTest(int mid, Object rhsObject)
+  public static void unresolvedInvokeinterfaceImplementsTest(int mid, Object rhsObject, int context)
       throws IncompatibleClassChangeError {
-    RVMMethod sought = MemberReference.getMemberRef(mid).asMethodReference().resolveInterfaceMethod();
+    RVMMethod sought = MemberReference.getMemberRef(mid).asMethodReference().resolveInterfaceMethod(context);
     RVMClass LHSclass = sought.getDeclaringClass();
     if (!LHSclass.isResolved()) {
       LHSclass.resolve();
@@ -195,8 +197,9 @@ public class InterfaceInvocation impleme
       for (RVMMethod im : interfaceMethods) {
         if (im.isClassInitializer()) continue;
         if (VM.VerifyAssertions) VM._assert(im.isPublic() && im.isAbstract());
-        InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(im.getMemberRef());
-        RVMMethod vm = klass.findVirtualMethod(im.getName(), im.getDescriptor());
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
+        InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(im.getMemberRef(), im.getResolvedContext());
+        RVMMethod vm = klass.findVirtualMethod(im.getName(), im.getDescriptor(), im.getResolvedContext());
         // NOTE: if there is some error condition, then we are playing a dirty trick and
         //       pretending that a static method of RuntimeEntrypoints is a virtual method.
         //       Since the methods in question take no arguments, we can get away with this.
@@ -257,6 +260,7 @@ public class InterfaceInvocation impleme
   /**
    * Build a single ITable for the pair of class C and interface I
    */
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
   private static ITable buildITable(RVMClass C, RVMClass I) {
     RVMMethod[] interfaceMethods = I.getDeclaredMethods();
     TIB tib = C.getTypeInformationBlock();
@@ -265,7 +269,7 @@ public class InterfaceInvocation impleme
     for (RVMMethod im : interfaceMethods) {
       if (im.isClassInitializer()) continue;
       if (VM.VerifyAssertions) VM._assert(im.isPublic() && im.isAbstract());
-      RVMMethod vm = C.findVirtualMethod(im.getName(), im.getDescriptor());
+      RVMMethod vm = C.findVirtualMethod(im.getName(), im.getDescriptor(), im.getResolvedContext());
       // NOTE: if there is some error condition, then we are playing a dirty trick and
       //       pretending that a static method of RuntimeEntrypoints is a virtual method.
       //       Since the methods in question take no arguments, we can get away with this.
@@ -276,9 +280,9 @@ public class InterfaceInvocation impleme
       }
       if (vm.isStatic()) {
         vm.compile();
-        iTable.set(getITableIndex(I, im.getName(), im.getDescriptor()), vm.getCurrentEntryCodeArray());
+        iTable.set(getITableIndex(I, im.getName(), im.getDescriptor(), im.getResolvedContext()), vm.getCurrentEntryCodeArray());
       } else {
-        iTable.set(getITableIndex(I, im.getName(), im.getDescriptor()), tib.getVirtualMethod(vm.getOffset()));
+        iTable.set(getITableIndex(I, im.getName(), im.getDescriptor(), im.getResolvedContext()), tib.getVirtualMethod(vm.getOffset()));
       }
     }
     return iTable;
@@ -291,15 +295,21 @@ public class InterfaceInvocation impleme
   /**
    * Return the index of the interface method m in the itable
    */
-  public static int getITableIndex(RVMClass klass, Atom mname, Atom mdesc) {
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+  public static int getITableIndex(RVMClass klass, Atom mname, Atom mdesc, int context) {
     if (VM.VerifyAssertions) VM._assert(VM.BuildForITableInterfaceInvocation);
     if (VM.VerifyAssertions) VM._assert(klass.isInterface());
     RVMMethod[] methods = klass.getDeclaredMethods();
+    boolean foundSomething = false;
     for (int i = 0; i < methods.length; i++) {
       if (methods[i].getName() == mname && methods[i].getDescriptor() == mdesc) {
-        return i + 1;
+        foundSomething = true;
+        if (Context.isMatch(methods[i], context, /*resolve = */ false)) { // Velodrome: Context: Added a parameter
+          return i + 1;
+        }
       }
     }
+    if (VM.VerifyAssertions) { VM._assert(!foundSomething); }
     return -1;
   }
 
@@ -336,7 +346,8 @@ public class InterfaceInvocation impleme
             RVMMethod[] interfaceMethods = I.getDeclaredMethods();
             for (RVMMethod im : interfaceMethods) {
               if (im.getName() == name && im.getDescriptor() == desc) {
-                iTable.set(getITableIndex(I, name, desc), m.getCurrentEntryCodeArray());
+                // Octet: Static cloning: Support multiple resolved methods for every method reference.
+                iTable.set(getITableIndex(I, name, desc, m.getResolvedContext()), m.getCurrentEntryCodeArray());
               }
             }
           }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/InterfaceMethodSignature.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/InterfaceMethodSignature.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/InterfaceMethodSignature.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/InterfaceMethodSignature.java	2014-04-03 17:43:50.089693773 -0400
@@ -18,6 +18,8 @@ import org.jikesrvm.objectmodel.TIBLayou
 import org.jikesrvm.util.ImmutableEntryHashSetRVM;
 import org.vmmagic.unboxed.Offset;
 
+// Octet: Static cloning: Add context as part of an interface method signature.
+
 /**
  *  An interface method signature is a pair of atoms:
  *  interfaceMethodName + interfaceMethodDescriptor.
@@ -50,10 +52,13 @@ public final class InterfaceMethodSignat
    */
   private final int id;
 
-  private InterfaceMethodSignature(Atom name, Atom descriptor, int id) {
+  private final int context;
+  
+  private InterfaceMethodSignature(Atom name, Atom descriptor, int context, int id) {
     this.name = name;
     this.descriptor = descriptor;
     this.id = id;
+    this.context = context;
   }
 
   /**
@@ -62,8 +67,8 @@ public final class InterfaceMethodSignat
    * @param ref     A reference to a supposed interface method
    * @return the interface method signature
    */
-  public static synchronized InterfaceMethodSignature findOrCreate(MemberReference ref) {
-    InterfaceMethodSignature key = new InterfaceMethodSignature(ref.getName(), ref.getDescriptor(), nextId+1);
+  public static synchronized InterfaceMethodSignature findOrCreate(MemberReference ref, int resolvedContext) {
+    InterfaceMethodSignature key = new InterfaceMethodSignature(ref.getName(), ref.getDescriptor(), resolvedContext, nextId+1);
     InterfaceMethodSignature val = dictionary.get(key);
     if (val != null) return val;
     nextId++;
@@ -97,14 +102,14 @@ public final class InterfaceMethodSignat
 
   @Override
   public int hashCode() {
-    return name.hashCode() + descriptor.hashCode();
+    return name.hashCode() + descriptor.hashCode() + context;
   }
 
   @Override
   public boolean equals(Object other) {
     if (other instanceof InterfaceMethodSignature) {
       InterfaceMethodSignature that = (InterfaceMethodSignature) other;
-      return name == that.name && descriptor == that.descriptor;
+      return name == that.name && descriptor == that.descriptor && context == that.context;
     } else {
       return false;
     }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/MemberReference.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/MemberReference.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/MemberReference.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/MemberReference.java	2014-04-03 17:43:50.090693776 -0400
@@ -13,6 +13,7 @@
 package org.jikesrvm.classloader;
 
 import java.util.StringTokenizer;
+
 import org.jikesrvm.VM;
 import org.jikesrvm.util.ImmutableEntryHashSetRVM;
 import org.vmmagic.pragma.Uninterruptible;
@@ -243,11 +244,12 @@ public abstract class MemberReference {
    * @return the RVMMember this reference resolves to if it is already known
    * or {@code null} if it cannot be resolved without risking class loading.
    */
-  public final RVMMember peekResolvedMember() {
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+  public final RVMMember peekResolvedMember(int context) {
     if (isFieldReference()) {
       return this.asFieldReference().peekResolvedField();
     } else {
-      return this.asMethodReference().peekResolvedMethod();
+      return this.asMethodReference().peekResolvedMethod(context);
     }
   }
 
@@ -255,11 +257,12 @@ public abstract class MemberReference {
    * Force resolution and return the resolved member.
    * Will cause classloading if necessary
    */
-  public final RVMMember resolveMember() {
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+  public final RVMMember resolveMember(int context) {
     if (isFieldReference()) {
       return this.asFieldReference().resolve();
     } else {
-      return this.asMethodReference().resolve();
+      return this.asMethodReference().resolve(context);
     }
   }
 
@@ -268,7 +271,19 @@ public abstract class MemberReference {
    * referenced from "that" method?
    */
   public final boolean needsDynamicLink(RVMMethod that) {
-    RVMMember resolvedThis = this.peekResolvedMember();
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+    // Velodrome: Context: Compute context if call is from library/VM to application
+    int context = that.getStaticContext();
+    if (isMethodReference()) {
+      if (Context.isApplicationPrefix(this.getType()) && !Context.isApplicationPrefix(that.getDeclaringClass().getTypeRef())) {
+        if (this.asMethodReference().isNonAtomic) {
+          context = Context.NONTRANS_CONTEXT;
+        } else {
+          context = Context.TRANS_CONTEXT;  
+        }
+      }
+    }
+    RVMMember resolvedThis = this.peekResolvedMember(context);
 
     if (resolvedThis == null) {
       // can't tell because we haven't resolved the member reference
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/MethodReference.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/MethodReference.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/MethodReference.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/MethodReference.java	2014-04-03 17:43:50.083693755 -0400
@@ -13,9 +13,15 @@
 package org.jikesrvm.classloader;
 
 import org.jikesrvm.VM;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.Pure;
 import org.vmmagic.pragma.Uninterruptible;
 
+// Octet: Static cloning: We've modified this whole class to support multiple resolved methods for each member reference.
+
+// Velodrome: Context: Changed this class to support two static contexts for application methods (possibly 3 resolved contexts), 
+// and only one static context for VM/library methods.
+
 /**
  * A class to represent the reference in a class file to a method of
  * that class or interface.
@@ -31,12 +37,40 @@ public final class MethodReference exten
    * types of parameters (not including "this", if virtual)
    */
   private final TypeReference[] parameterTypes;
+  
+  // Velodrome: Adding a flag to track whether this method is supposed to be non-atomic
+  // This variable should be true if/when the method is added to the exclusion list 
+  public boolean isNonAtomic;
 
   /**
    * The RVMMethod that this method reference resolved to (null if not yet resolved).
    */
-  private RVMMethod resolvedMember;
+  @Uninterruptible
+  private RVMMethod resolvedMember(int context) {
+    if (context == Context.VM_CONTEXT) {
+      return resolvedMemberVM;
+    } else if (context == Context.NONTRANS_CONTEXT) {
+      return resolvedMemberNonTrans;
+    } else if (context == Context.TRANS_CONTEXT) {
+      return resolvedMemberTrans;
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(VM.NOT_REACHED); }
+      return null;
+    }
+  }
+
+  // Velodrome: Context: References to different versions of RVMMethod depending on the resolved context
+  private RVMMethod resolvedMemberVM;
+  private RVMMethod resolvedMemberTrans;
+  private RVMMethod resolvedMemberNonTrans;
 
+  // Velodrome: This now is meaningful only for application methods
+  /** This method is weird because there's a possible race -- but these variables should be set by the time it's called. */
+  @Uninterruptible
+  public boolean hasMultipleResolvedContexts() {
+    return resolvedMemberTrans != null && resolvedMemberNonTrans != null && resolvedMemberTrans != resolvedMemberNonTrans;
+  }
+  
   /**
    * Find or create a method reference
    * @see MemberReference#findOrCreate(TypeReference, Atom, Atom)
@@ -58,6 +92,14 @@ public final class MethodReference exten
     ClassLoader cl = tr.getClassLoader();
     returnType = d.parseForReturnType(cl);
     parameterTypes = d.parseForParameterTypes(cl);
+    
+    // Velodrome: Check and store the fact whether the given method is supposed to be non-atomic
+    Atom at = Velodrome.constructMethodSignature(this);
+    if (Velodrome.notTransactions.contains(at)) {
+      isNonAtomic = true;
+    } else {
+      isNonAtomic = false;
+    }
   }
 
   /**
@@ -90,6 +132,7 @@ public final class MethodReference exten
   /**
    * Do this and that definitely refer to the different methods?
    */
+  /* Unused method:
   public boolean definitelyDifferent(MethodReference that) {
     if (this == that) return false;
     if (name != that.name || descriptor != that.descriptor) return true;
@@ -98,10 +141,12 @@ public final class MethodReference exten
     if (mine == null || theirs == null) return false;
     return mine != theirs;
   }
+  */
 
   /**
    * Do this and that definitely refer to the same method?
    */
+  /* Unused method:
   public boolean definitelySame(MethodReference that) {
     if (this == that) return true;
     if (name != that.name || descriptor != that.descriptor) return false;
@@ -110,29 +155,39 @@ public final class MethodReference exten
     if (mine == null || theirs == null) return false;
     return mine == theirs;
   }
+  */
 
   /**
    * Has the method reference already been resolved into a target method?
    */
+  /* Unused method:
   public boolean isResolved() {
-    return resolvedMember != null;
+    return resolvedMember() != null;
   }
+  */
 
   /**
    * Get the member this reference has been resolved to, if
    * it has already been resolved. Does NOT force resolution.
    */
   @Uninterruptible
-  public RVMMethod getResolvedMember() {
-    return resolvedMember;
+  public RVMMethod getResolvedMember(int context) {
+    return resolvedMember(context);
   }
 
   /**
    * For use by RVMMethod constructor
    */
-  void setResolvedMember(RVMMethod it) {
-    if (VM.VerifyAssertions) VM._assert(resolvedMember == null || resolvedMember == it);
-    resolvedMember = it;
+  void setResolvedMember(RVMMethod it, boolean checkAssertion) {
+    if (it.getResolvedContext() == Context.TRANS_CONTEXT) {
+      resolvedMemberTrans = it;
+    } else if (it.getResolvedContext() == Context.NONTRANS_CONTEXT) {
+      resolvedMemberNonTrans = it;
+    } else if (it.getResolvedContext() == Context.VM_CONTEXT) {
+      resolvedMemberVM = it;
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(VM.NOT_REACHED); }
+    }
   }
 
   /**
@@ -141,7 +196,7 @@ public final class MethodReference exten
    *
    * @return target method or {@code null} if the method cannot be resolved without classloading.
    */
-  public synchronized RVMMethod resolveInvokeSpecial() {
+  public synchronized RVMMethod resolveInvokeSpecial(int context) {
     RVMClass thisClass = (RVMClass) type.peekType();
     if (thisClass == null && name != RVMClassLoader.StandardObjectInitializerMethodName) {
       thisClass = (RVMClass) type.resolve();
@@ -152,7 +207,7 @@ public final class MethodReference exten
     if (thisClass == null) {
       return null; // can't be found now.
     }
-    RVMMethod sought = resolveInternal(thisClass);
+    RVMMethod sought = resolveInternal(thisClass, context);
 
     if (sought.isObjectInitializer()) {
       return sought;   // <init>
@@ -164,7 +219,7 @@ public final class MethodReference exten
     }
 
     for (; cls != null; cls = cls.getSuperClass()) {
-      RVMMethod found = cls.findDeclaredMethod(sought.getName(), sought.getDescriptor());
+      RVMMethod found = cls.findDeclaredMethod(sought.getName(), sought.getDescriptor(), sought.getResolvedContext());
       if (found != null) {
         return found; // new-style invokespecial semantics
       }
@@ -177,13 +232,13 @@ public final class MethodReference exten
    * the search order specified in JVM spec 5.4.3.3.
    * @return the RVMMethod that this method ref resolved to or {@code null} if it cannot be resolved.
    */
-  public RVMMethod peekResolvedMethod() {
-    if (resolvedMember != null) return resolvedMember;
+  public RVMMethod peekResolvedMethod(int context) {
+    if (resolvedMember(context) != null) return resolvedMember(context);
 
     // Hasn't been resolved yet. Try to do it now without triggering class loading.
     RVMType declaringClass = type.peekType();
     if (declaringClass == null) return null;
-    return resolveInternal((RVMClass)declaringClass);
+    return resolveInternal((RVMClass)declaringClass, context);
   }
 
   /**
@@ -191,11 +246,11 @@ public final class MethodReference exten
    * the search order specified in JVM specification 5.4.3.3.
    * @return the RVMMethod that this method reference resolved to.
    */
-  public synchronized RVMMethod resolve() {
-    if (resolvedMember != null) return resolvedMember;
+  public synchronized RVMMethod resolve(int context) {
+    if (resolvedMember(context) != null) return resolvedMember(context);
 
     // Hasn't been resolved yet. Do it now triggering class loading if necessary.
-    return resolveInternal((RVMClass) type.resolve());
+    return resolveInternal((RVMClass) type.resolve(), context);
   }
 
   /**
@@ -223,7 +278,7 @@ public final class MethodReference exten
     // See if method is explicitly declared in any superclass
     for (RVMClass c = declaringClass; c != null; c = c.getSuperClass()) {
 
-      if (c.findDeclaredMethod(name, descriptor) != null) {
+      if (c.hasDeclaredMethodWithAnyContext(name, descriptor)) {
         // Method declared in superclass => not interface method
         return false;
       }
@@ -233,7 +288,7 @@ public final class MethodReference exten
     for (RVMClass c = declaringClass; c != null; c = c.getSuperClass()) {
       // See if method is in any interfaces of c
       for (RVMClass intf : c.getDeclaredInterfaces()) {
-        if (searchInterfaceMethods(intf) != null) {
+        if (hasInterfaceMethodWithAnyContext(intf)) {
           // Found method in interface or superinterface
           return true;
         }
@@ -249,14 +304,14 @@ public final class MethodReference exten
    * SysCall annotated methods we don't know until they are resolved.
    */
   public boolean isMagic() {
-    return getType().isMagicType() || ((resolvedMember != null) && (resolvedMember.isSysCall() || resolvedMember.isSpecializedInvoke()));
+    return getType().isMagicType() || ((resolvedMember(Context.VM_CONTEXT) != null) && (resolvedMember(Context.VM_CONTEXT).isSysCall() || resolvedMember(Context.VM_CONTEXT).isSpecializedInvoke()));
   }
 
   /**
    * Is the method reference to a specialized invoke? NB. we don't know until they are resolved.
    */
   public boolean isSpecializedInvoke() {
-    return (resolvedMember != null) && (resolvedMember.isSpecializedInvoke());
+    return (resolvedMember(Context.VM_CONTEXT) != null) && (resolvedMember(Context.VM_CONTEXT).isSpecializedInvoke());
   }
 
   /**
@@ -264,7 +319,7 @@ public final class MethodReference exten
    * SysCall annotated methods we don't know until they are resolved.
    */
   public boolean isSysCall() {
-    return (getType() == TypeReference.SysCall) || ((resolvedMember != null) && (resolvedMember.isSysCall()));
+    return (getType() == TypeReference.SysCall) || ((resolvedMember(Context.VM_CONTEXT) != null) && (resolvedMember(Context.VM_CONTEXT).isSysCall()));
   }
 
   /**
@@ -272,7 +327,7 @@ public final class MethodReference exten
    * the search order specified in JVM spec 5.4.3.3.
    * @return the RVMMethod that this method ref resolved to.
    */
-  private RVMMethod resolveInternal(RVMClass declaringClass) {
+  private RVMMethod resolveInternal(RVMClass declaringClass, int context) {
     final boolean DBG=false;
     if (!declaringClass.isResolved()) {
       declaringClass.resolve();
@@ -282,13 +337,15 @@ public final class MethodReference exten
         VM.sysWrite("Checking for <" + name + "," + descriptor + "> in class " + c + "...");
       }
 
-      RVMMethod it = c.findDeclaredMethod(name, descriptor);
+      RVMMethod it = c.findDeclaredMethod(name, descriptor, context);
       if (it != null) {
         if (DBG) {
           VM.sysWriteln("...found <" + name + "," + descriptor + "> in class " + c);
         }
-        resolvedMember = it;
-        return resolvedMember;
+        setResolvedMember(it, false);
+        return it;
+        //resolvedMember = it;
+        //return resolvedMember;
       }
       if (DBG) {
         VM.sysWriteln("...NOT found <" + name + "," + descriptor + "> in class " + c);
@@ -320,8 +377,8 @@ public final class MethodReference exten
    * the search order specified in JVM spec 5.4.3.4.
    * @return the RVMMethod that this method ref resolved to or {@code null} if it cannot be resolved without trigering class loading
    */
-  public RVMMethod peekInterfaceMethod() {
-    if (resolvedMember != null) return resolvedMember;
+  public RVMMethod peekInterfaceMethod(int context) {
+    if (resolvedMember(context) != null) return resolvedMember(context);
 
     // Hasn't been resolved yet. Try to do it now.
     RVMClass declaringClass = (RVMClass) type.peekType();
@@ -330,7 +387,7 @@ public final class MethodReference exten
       declaringClass.resolve();
     }
     if (!declaringClass.isInterface()) return null;
-    return resolveInterfaceMethodInternal(declaringClass);
+    return resolveInterfaceMethodInternal(declaringClass, context);
   }
 
   /**
@@ -338,8 +395,8 @@ public final class MethodReference exten
    * the search order specified in JVM spec 5.4.3.4.
    * @return the RVMMethod that this method ref resolved to
    */
-  public RVMMethod resolveInterfaceMethod() throws IncompatibleClassChangeError, NoSuchMethodError {
-    if (resolvedMember != null) return resolvedMember;
+  public RVMMethod resolveInterfaceMethod(int context) throws IncompatibleClassChangeError, NoSuchMethodError {
+    if (resolvedMember(context) != null) return resolvedMember(context);
 
     // Hasn't been resolved yet. Do it now.
     RVMClass declaringClass = (RVMClass) type.resolve();
@@ -352,7 +409,7 @@ public final class MethodReference exten
     if (!declaringClass.isInterface() && !isMiranda()) {
       throw new IncompatibleClassChangeError();
     }
-    RVMMethod ans = resolveInterfaceMethodInternal(declaringClass);
+    RVMMethod ans = resolveInterfaceMethodInternal(declaringClass, context);
     if (ans == null) {
       throw new NoSuchMethodError(this.toString());
     }
@@ -364,28 +421,43 @@ public final class MethodReference exten
    * the search order specified in JVM spec 5.4.3.4.
    * @return the RVMMethod that this method ref resolved to or {@code null} for error
    */
-  private RVMMethod resolveInterfaceMethodInternal(RVMClass declaringClass) {
-    RVMMethod it = declaringClass.findDeclaredMethod(name, descriptor);
+  private RVMMethod resolveInterfaceMethodInternal(RVMClass declaringClass, int context) {
+    RVMMethod it = declaringClass.findDeclaredMethod(name, descriptor, context);
     if (it != null) {
-      resolvedMember = it;
-      return resolvedMember;
+      setResolvedMember(it, false);
+      return it;
+      //resolvedMember = it;
+      //return resolvedMember;
     }
     for (RVMClass intf : declaringClass.getDeclaredInterfaces()) {
-      it = searchInterfaceMethods(intf);
+      it = searchInterfaceMethods(intf, context);
       if (it != null) {
-        resolvedMember = it;
-        return resolvedMember;
+        setResolvedMember(it, false);
+        return it;
+        //resolvedMember = it;
+        //return resolvedMember;
       }
     }
     return null;
   }
 
-  private RVMMethod searchInterfaceMethods(RVMClass c) {
+  private boolean hasInterfaceMethodWithAnyContext(RVMClass c) {
+    if (!c.isResolved()) c.resolve();
+    boolean has = c.hasDeclaredMethodWithAnyContext(name, descriptor);
+    if (has) return true;
+    for (RVMClass intf : c.getDeclaredInterfaces()) {
+      has = hasInterfaceMethodWithAnyContext(intf);
+      if (has) return true;
+    }
+    return false;
+  }
+
+  private RVMMethod searchInterfaceMethods(RVMClass c, int context) {
     if (!c.isResolved()) c.resolve();
-    RVMMethod it = c.findDeclaredMethod(name, descriptor);
+    RVMMethod it = c.findDeclaredMethod(name, descriptor, context);
     if (it != null) return it;
     for (RVMClass intf : c.getDeclaredInterfaces()) {
-      it = searchInterfaceMethods(intf);
+      it = searchInterfaceMethods(intf, context);
       if (it != null) return it;
     }
     return null;
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/NativeMethod.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/NativeMethod.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/NativeMethod.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/NativeMethod.java	2014-04-03 17:43:50.090693776 -0400
@@ -41,6 +41,8 @@ public final class NativeMethod extends 
    */
   private Address nativeTOC;
 
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+
   /**
    * Construct native method information
    *
@@ -56,7 +58,7 @@ public final class NativeMethod extends 
    */
   NativeMethod(TypeReference declaringClass, MemberReference memRef, short modifiers,
                   TypeReference[] exceptionTypes, Atom signature, RVMAnnotation[] annotations,
-                  RVMAnnotation[][] parameterAnnotations, Object annotationDefault) {
+                  RVMAnnotation[][] parameterAnnotations, Object annotationDefault, int resolvedContext) {
     super(declaringClass,
           memRef,
           modifiers,
@@ -64,7 +66,16 @@ public final class NativeMethod extends 
           signature,
           annotations,
           parameterAnnotations,
-          annotationDefault);
+          annotationDefault,
+          resolvedContext);
+  }
+  
+  NativeMethod(NativeMethod method, int resolvedContext) {
+    super(method, resolvedContext);
+  }
+
+  RVMMethod cloneMethod(int resolvedContext) {
+    return new NativeMethod(this, resolvedContext);
   }
 
   @Override
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/NormalMethod.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/NormalMethod.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/NormalMethod.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/NormalMethod.java	2014-04-03 17:43:50.081693749 -0400
@@ -140,6 +140,8 @@ public final class NormalMethod extends 
   private static final HashMapRVM<NormalMethod, Integer> savedOperandWords =
     new HashMapRVM<NormalMethod, Integer>();
 
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+
   /**
    * Construct a normal Java bytecode method's information
    *
@@ -161,8 +163,8 @@ public final class NormalMethod extends 
    */
   NormalMethod(TypeReference dc, MemberReference mr, short mo, TypeReference[] et, short lw, short ow,
                   byte[] bc, ExceptionHandlerMap eMap, int[] lm, LocalVariableTable lvt, int[] constantPool, Atom sig,
-                  RVMAnnotation[] annotations, RVMAnnotation[][] parameterAnnotations, Object ad) {
-    super(dc, mr, mo, et, sig, annotations, parameterAnnotations, ad);
+                  RVMAnnotation[] annotations, RVMAnnotation[][] parameterAnnotations, Object ad, int resolvedContext) {
+    super(dc, mr, mo, et, sig, annotations, parameterAnnotations, ad, resolvedContext);
     localWords = lw;
     operandWords = ow;
     bytecodes = bc;
@@ -172,6 +174,23 @@ public final class NormalMethod extends 
     computeSummary(constantPool);
   }
 
+
+  NormalMethod(NormalMethod method, int resolvedContext) {
+    super(method, resolvedContext);
+    this.localWords = method.localWords;
+    this.operandWords = method.operandWords;
+    this.bytecodes = method.bytecodes;
+    this.exceptionHandlerMap = method.exceptionHandlerMap;
+    this.lineNumberMap = method.lineNumberMap;
+    localVariableTables.put(this, method.getLocalVariableTable());
+    this.summaryFlags = method.summaryFlags;
+    this.summarySize = method.summarySize;
+  }
+
+  RVMMethod cloneMethod(int resolvedContext) {
+    return new NormalMethod(this, resolvedContext);
+  }
+
   @Override
   protected CompiledMethod genCode() throws VerifyError {
     if (VM.writingBootImage) {
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMAnnotation.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMAnnotation.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMAnnotation.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMAnnotation.java	2014-04-03 17:43:50.084693758 -0400
@@ -487,7 +487,8 @@ public final class RVMAnnotation {
         Atom.findOrCreateAsciiAtom("()" + TypeReference.findOrCreate(valueType).getName())
     ).asMethodReference();
     try {
-      return methRef.resolve().getAnnotationDefault();
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      return methRef.resolve(Context.VM_CONTEXT).getAnnotationDefault();
     } catch (Throwable t) {
       return NO_VALUE;
     }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMArray.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMArray.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMArray.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMArray.java	2014-04-03 17:43:50.086693764 -0400
@@ -435,6 +435,8 @@ public final class RVMArray extends RVMT
     /* Set GC metadata for this type */
     boolean isRefArray = elementType.isReferenceType();
     referenceOffsets = isRefArray ? REFARRAY_OFFSET_ARRAY : NOREFS_OFFSET_ARRAY;
+    // Velodrome: Initialize array of metadata references
+    velodromeMetadataOffsets = isRefArray ? REFARRAY_OFFSET_ARRAY : NOREFS_OFFSET_ARRAY;
 
     state = CLASS_LOADED;
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMClass.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMClass.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMClass.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMClass.java	2014-04-03 17:43:50.077693733 -0400
@@ -12,6 +12,9 @@
  */
 package org.jikesrvm.classloader;
 
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Inherited;
 
@@ -19,22 +22,31 @@ import org.jikesrvm.Callbacks;
 import org.jikesrvm.Constants;
 import org.jikesrvm.VM;
 import org.jikesrvm.compilers.common.CompiledMethod;
+import org.jikesrvm.compilers.common.CompiledMethods;
 import org.jikesrvm.compilers.opt.inlining.ClassLoadingDependencyManager;
-import org.jikesrvm.mm.mminterface.HandInlinedScanning;
 import org.jikesrvm.mm.mminterface.AlignmentEncoding;
+import org.jikesrvm.mm.mminterface.HandInlinedScanning;
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.objectmodel.FieldLayoutContext;
 import org.jikesrvm.objectmodel.IMT;
 import org.jikesrvm.objectmodel.ObjectModel;
 import org.jikesrvm.objectmodel.TIB;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.OctetState;
+import org.jikesrvm.octet.Stats;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
 import org.jikesrvm.runtime.StackBrowser;
 import org.jikesrvm.runtime.Statics;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.NonMoving;
 import org.vmmagic.pragma.Pure;
 import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+
+// Octet: Static cloning: Modified various places in this class to support multiple resolved methods for every method reference.
 
 /**
  * Description of a java "class" type.<p>
@@ -86,7 +98,7 @@ public final class RVMClass extends RVMT
   /** Fields of this class */
   private final RVMField[] declaredFields;
   /** Methods of this class */
-  private final RVMMethod[] declaredMethods;
+  private RVMMethod[] declaredMethods;
   /** Declared inner classes, may be null */
   private final TypeReference[] declaredClasses;
   /** The outer class, or null if this is not a inner/nested class */
@@ -418,6 +430,7 @@ public final class RVMClass extends RVMT
    * Class that immediately encloses this class, or null if this is not an
    * inner/nested class.
    */
+  @Uninterruptible
   public TypeReference getEnclosingClass() {
     return enclosingClass;
   }
@@ -432,13 +445,13 @@ public final class RVMClass extends RVMT
     }
     for(RVMMethod method: declaredMethods) {
       /* Make all declared methods appear resolved */
-      method.getMemberRef().asMethodReference().setResolvedMember(method);
+      method.getMemberRef().asMethodReference().setResolvedMember(method, true);
     }
     if (virtualMethods != null) {
       /* Possibly created Miranda methods */
       for(RVMMethod method: virtualMethods) {
         if (method.getDeclaringClass() == this) {
-          method.getMemberRef().asMethodReference().setResolvedMember(method);
+          method.getMemberRef().asMethodReference().setResolvedMember(method, true);
         }
       }
     }
@@ -520,18 +533,38 @@ public final class RVMClass extends RVMT
     return null;
   }
 
+  boolean hasDeclaredMethodWithAnyContext(Atom methodName, Atom methodDescriptor) {
+    for (RVMMethod method : declaredMethods) {
+      if (method.getName() == methodName && method.getDescriptor() == methodDescriptor) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * Find description of a method of this class.
    * @param methodName method name - something like "foo"
    * @param methodDescriptor method descriptor - something like "()I"
    * @return description (null --> not found)
    */
-  public RVMMethod findDeclaredMethod(Atom methodName, Atom methodDescriptor) {
+  public RVMMethod findDeclaredMethod(Atom methodName, Atom methodDescriptor, int context) {
+    // Velodrome: Context: Library class (javax.*) can extend application classes (gnu.java.*), example hedc.
+    // See comment in Context for library prefixes.
+    // This hack is a workaround for just that issue. 
+    if (context == Context.VM_CONTEXT && Context.isApplicationPrefix(getTypeRef())) {
+      context = Context.TRANS_CONTEXT;
+    }
+    boolean foundSomething = false;
     for (RVMMethod method : declaredMethods) {
       if (method.getName() == methodName && method.getDescriptor() == methodDescriptor) {
-        return method;
+        foundSomething = true;
+        if (Context.isMatch(method, context, /* resolve = */ false)) { // Velodrome: Context: Added a parameter
+          return method;
+        }
       }
     }
+    if (VM.VerifyAssertions) { VM._assert(!foundSomething); }
     return null;
   }
 
@@ -557,7 +590,8 @@ public final class RVMClass extends RVMT
   public RVMMethod findMainMethod() {
     Atom mainName = Atom.findOrCreateAsciiAtom(("main"));
     Atom mainDescriptor = Atom.findOrCreateAsciiAtom(("([Ljava/lang/String;)V"));
-    RVMMethod mainMethod = this.findDeclaredMethod(mainName, mainDescriptor);
+    // Velodrome: Context: main() should be non-atomic
+    RVMMethod mainMethod = this.findDeclaredMethod(mainName, mainDescriptor, Context.NONTRANS_CONTEXT);
 
     if (mainMethod == null || !mainMethod.isPublic() || !mainMethod.isStatic()) {
       // no such method
@@ -864,10 +898,11 @@ public final class RVMClass extends RVMT
    * @return method description (null --> not found)
    */
   @Pure
-  public RVMMethod findStaticMethod(Atom memberName, Atom memberDescriptor) {
+  public RVMMethod findStaticMethod(Atom memberName, Atom memberDescriptor, int context) {
     if (VM.VerifyAssertions) VM._assert(isResolved());
     for (RVMMethod method : getStaticMethods()) {
-      if (method.getName() == memberName && method.getDescriptor() == memberDescriptor) {
+      if (method.getName() == memberName && method.getDescriptor() == memberDescriptor &&
+          Context.isMatch(method, context, false)) { // Velodrome: Context: Added a parameter
         return method;
       }
     }
@@ -880,10 +915,11 @@ public final class RVMClass extends RVMT
    * @return method description (null --> not found)
    */
   @Pure
-  public RVMMethod findInitializerMethod(Atom memberDescriptor) {
+  public RVMMethod findInitializerMethod(Atom memberDescriptor, int context) {
     if (VM.VerifyAssertions) VM._assert(isResolved());
     for (RVMMethod method : getConstructorMethods()) {
-      if (method.getDescriptor() == memberDescriptor) {
+      if (method.getDescriptor() == memberDescriptor &&
+          Context.isMatch(method, context, false)) { // Velodrome: Context: Added a parameter
         return method;
       }
     }
@@ -1020,6 +1056,8 @@ public final class RVMClass extends RVMT
     }
     if (VM.verboseClassLoading) VM.sysWrite("[Loaded " + toString() + "]\n");
   }
+  
+  // Velodrome: Context: Modified the resolve() method to support 2 static contexts and 3 resolved application contexts.
 
   /**
    * {@inheritDoc} Space in the JTOC is allocated for static fields,
@@ -1070,7 +1108,7 @@ public final class RVMClass extends RVMT
     }
 
     if (VM.verboseClassLoading) VM.sysWrite("[Preparing " + this + "]\n");
-
+    
     // build field and method lists for this class
     //
     {
@@ -1101,7 +1139,69 @@ public final class RVMClass extends RVMT
           instanceFields.addElement(field);
         }
       }
-
+      
+      // First find declared methods that should be cloned to have an extra context because of an overridden virtual method with two contexts.
+      MethodVector extraDeclaredMethods = new MethodVector();
+      for (int j = 0, m = virtualMethods.size(); j < m; j++) {
+        RVMMethod virtualMethod = virtualMethods.elementAt(j);
+        boolean hasContextMatch = false;
+        RVMMethod overridingMethod = null;
+        for (RVMMethod declaredMethod : declaredMethods) {
+          if (declaredMethod.getName() == virtualMethod.getName() &&
+              declaredMethod.getDescriptor() == virtualMethod.getDescriptor()) {
+            overridingMethod = declaredMethod;
+            if (virtualMethod.getResolvedContext() == declaredMethod.getResolvedContext()) {
+              hasContextMatch = true;
+            }
+          }
+        }
+        if (overridingMethod != null && !hasContextMatch) {
+          if (Context.isApplicationPrefix(this.getTypeRef())) { // Velodrome: Context: Clone only for application methods
+            //RVMMethod clonedMethod = overridingMethod.cloneMethod(Context.getOtherContext(overridingMethod, overridingMethod.getResolvedContext()));
+            RVMMethod clonedMethod = overridingMethod.cloneMethod(virtualMethod.getResolvedContext());
+            clonedMethod.getMemberRef().asMethodReference().setResolvedMember(clonedMethod, true);
+            extraDeclaredMethods.addElement(clonedMethod);
+          }
+        }
+      }
+      addDeclaredMethods(extraDeclaredMethods);      
+      extraDeclaredMethods = new MethodVector();
+      
+      // Now look for declared methods that should be cloned to have an extra context because of an overridden interface method.
+      if (!isInterface()) { // && isAbstract() -- removed this to fix an apparent bug
+        for (RVMClass I : declaredInterfaces) {
+          RVMMethod[] iMeths = I.getVirtualMethods();
+          for (RVMMethod iMeth : iMeths) {
+            RVMMethod partialMatch = null;
+            RVMMethod overridingMethod = null;
+            for (RVMMethod declaredMethod : declaredMethods) {
+              if (declaredMethod.getName() == iMeth.getName() && declaredMethod.getDescriptor() == iMeth.getDescriptor()) {
+                partialMatch = declaredMethod;
+                if (Context.isMatch(iMeth, declaredMethod.getResolvedContext(), true)) {
+                  overridingMethod = declaredMethod;
+                  // Velodrome: Context: Is this required?
+                  if (iMeth.getMemberRef().asMethodReference().isNonAtomic) {
+                    overridingMethod.getMemberRef().asMethodReference().isNonAtomic = true;
+                  } else if (overridingMethod.getMemberRef().asMethodReference().isNonAtomic) {
+                    iMeth.getMemberRef().asMethodReference().isNonAtomic = true;
+                  }
+                  break;
+                }
+              }
+            }
+            if (partialMatch != null && overridingMethod == null) {
+              if (Context.isApplicationPrefix(this.getTypeRef())) { // Velodrome: Context: Clone only for application methods
+                // RVMMethod newDeclaredMethod = partialMatch.cloneMethod(Context.getOtherContext(partialMatch, partialMatch.getResolvedContext()));
+                RVMMethod newDeclaredMethod = partialMatch.cloneMethod(iMeth.getResolvedContext());
+                newDeclaredMethod.getMemberRef().asMethodReference().setResolvedMember(newDeclaredMethod, true);
+                extraDeclaredMethods.addElement(newDeclaredMethod);
+              }
+            }
+          }
+        }
+      }
+      addDeclaredMethods(extraDeclaredMethods);
+      
       // append/overlay methods defined by this class
       //
       for (RVMMethod method : getDeclaredMethods()) {
@@ -1130,13 +1230,26 @@ public final class RVMClass extends RVMT
           // method could override something in superclass - check for it
           //
           int superclassMethodIndex = -1;
+          boolean foundSomething = false;
           for (int j = 0, m = virtualMethods.size(); j < m; ++j) {
             RVMMethod alreadyDefinedMethod = virtualMethods.elementAt(j);
             if (alreadyDefinedMethod.getName() == method.getName() &&
                 alreadyDefinedMethod.getDescriptor() == method.getDescriptor()) {
-              // method already defined in superclass
-              superclassMethodIndex = j;
-              break;
+              foundSomething = true;
+              if (method.getResolvedContext() == alreadyDefinedMethod.getResolvedContext()) {
+                // method already defined in superclass
+                if (VM.VerifyAssertions) { VM._assert(superclassMethodIndex == -1); }
+                superclassMethodIndex = j;
+                // Velodrome: Context: Is this required?
+                if (alreadyDefinedMethod.getMemberRef().asMethodReference().isNonAtomic) {
+                  method.getMemberRef().asMethodReference().isNonAtomic = true;
+                } else if (method.getMemberRef().asMethodReference().isNonAtomic) {
+                  alreadyDefinedMethod.getMemberRef().asMethodReference().isNonAtomic = true;
+                }
+                // This is weird: To actually test the assertion above, we'll continue here instead of break.
+                if (VM.VerifyAssertions) { continue; }
+                break;
+              }
             }
           }
 
@@ -1167,11 +1280,24 @@ public final class RVMClass extends RVMT
           for (RVMMethod iMeth : iMeths) {
             Atom iName = iMeth.getName();
             Atom iDesc = iMeth.getDescriptor();
+            RVMMethod overridingMethod = null;
             for (int k = 0; k < virtualMethods.size(); k++) {
               RVMMethod vMeth = virtualMethods.elementAt(k);
-              if (vMeth.getName() == iName && vMeth.getDescriptor() == iDesc) continue outer;
+              if (vMeth.getName() == iName && vMeth.getDescriptor() == iDesc) {
+                overridingMethod = vMeth;
+                if (Context.isMatch(iMeth, vMeth.getResolvedContext(), true)) continue outer;
+              }
             }
             MemberReference mRef = MemberReference.findOrCreate(typeRef, iName, iDesc);
+            if (overridingMethod != null) {
+              if (Context.isApplicationPrefix(this.getTypeRef())) { // Velodrome: Context: Clone only for application methods
+                //RVMMethod clonedMethod = overridingMethod.cloneMethod(Context.getOtherContext(overridingMethod, overridingMethod.getResolvedContext()));
+                RVMMethod clonedMethod = overridingMethod.cloneMethod(iMeth.getResolvedContext());
+                //clonedMethod.getMemberRef().asMethodReference().setResolvedMember(clonedMethod, true);
+                virtualMethods.addElement(clonedMethod);
+                continue;
+              }
+            }
             virtualMethods.addElement(new AbstractMethod(getTypeRef(),
                                                             mRef,
                                                             (short) (ACC_ABSTRACT | ACC_PUBLIC),
@@ -1179,7 +1305,8 @@ public final class RVMClass extends RVMT
                                                             null,
                                                             null,
                                                             null,
-                                                            null));
+                                                            null,
+                                                            iMeth.getResolvedContext()));
           }
         }
       }
@@ -1212,6 +1339,48 @@ public final class RVMClass extends RVMT
         field.setOffset(Statics.allocateNumericSlot(BYTES_IN_LONG, true));
       }
 
+      // Octet: Add per-field metadata for static, non-final fields.  Initialize metadata.
+      if (Octet.getConfig().addHeaderWord() &&
+          Octet.shouldAddMetadataForField(field.getMemberRef().asFieldReference()) &&
+          !field.isFinal()) {
+        Offset metadataOffset = Statics.allocateNumericSlot(BYTES_IN_WORD, true);
+        field.setMetadataOffset(metadataOffset);
+        if (Octet.getConfig().instrumentAllocation()) {
+          Word metadata =  OctetState.getInitial();
+          OctetState.check(metadata);
+          Statics.setSlotContents(metadataOffset, metadata);
+          if (VM.runningVM) {
+            Stats.Alloc.inc();
+          }
+        }
+      }
+      
+      // Velodrome: Add per-field metadata for static, non-final fields. Initialize metadata.
+      if (Velodrome.addPerFieldVelodromeMetadata() && !field.isFinal() 
+          && Velodrome.shouldAddVelodromeMetadataForStaticField(field.getMemberRef().asFieldReference())) {
+        // Velodrome: Metadata is always a reference to an object, will need to change this 
+        // if we are creating multiple words of metadata per field.
+        // We are treating metadata references as weak references, hence we are creating numeric slots to house those
+        // references so that GC does not trace them. They will be custom processed.
+        Offset writeSlot = Statics.allocateNumericSlot(BYTES_IN_ADDRESS, true);
+        // Verify if the offset can ever be an odd number, since RVMMember.NO_OFFSET is
+        // initialized to Short.MIN_VALUE
+        if (VM.VerifyAssertions && (writeSlot.toInt() % 2 != 0)) {
+          VM.sysWriteln("Value of write offset:", writeSlot.toInt());
+          VM._assert(NOT_REACHED);
+        }
+        field.setWriteMetadataOffset(writeSlot);
+        Statics.setSlotContents(writeSlot, Word.zero());
+        Offset readSlot = Statics.allocateNumericSlot(BYTES_IN_ADDRESS, true);
+        if (VM.VerifyAssertions && (readSlot.toInt() % 2 != 0)) {
+          VM.sysWriteln("Value of read offset:", readSlot.toInt());
+          VM._assert(NOT_REACHED);
+        }
+        field.setReadMetadataOffset(readSlot);
+        Statics.setSlotContents(readSlot, Word.zero());
+        Velodrome.addStaticOffsets(writeSlot, readSlot);
+      }
+
       // (SJF): Serialization nastily accesses even final private static
       //           fields via pseudo-reflection! So, we must shove the
       //           values of final static fields into the JTOC.  Now
@@ -1225,26 +1394,58 @@ public final class RVMClass extends RVMT
     //
     ObjectModel.layoutInstanceFields(this);
 
+    // Velodrome: Initialize array of metadata references
+    
     // count reference fields
     int referenceFieldCount = 0;
+    int velodromeMetadataFieldCount = 0;
     for (RVMField field : instanceFields) {
       if (field.isTraced()) {
         referenceFieldCount += 1;
       }
+      
+      // Velodrome: count per-field metadata, even for untraced fields, this is required to 
+      // facilitate tracing by GC. The per-field metadata added are to be treated as references.
+      if (Velodrome.addPerFieldVelodromeMetadata()) {
+        if (Velodrome.shouldAddPerFieldVelodromeMetadata(field)) {
+          int numFields = Velodrome.getNumFields(field);
+          velodromeMetadataFieldCount += numFields;
+        }
+      }
+      
     }
 
     // record offsets of those instance fields that contain references
     //
     if (typeRef.isRuntimeTable()) {
       referenceOffsets = MemoryManager.newNonMovingIntArray(0);
+      if (Velodrome.addPerFieldVelodromeMetadata()) {
+        velodromeMetadataOffsets = MemoryManager.newNonMovingIntArray(0);
+      }
     } else {
       referenceOffsets = MemoryManager.newNonMovingIntArray(referenceFieldCount);
+      if (Velodrome.addPerFieldVelodromeMetadata()) {
+        velodromeMetadataOffsets = MemoryManager.newNonMovingIntArray(velodromeMetadataFieldCount);
+      }
+      
       int j = 0;
+      int index = 0;
       for (RVMField field : instanceFields) {
         if (field.isTraced()) {
           referenceOffsets[j++] = field.getOffset().toInt();
         }
+        
+        // Velodrome: count per-field metadata, even for untraced fields, this is required to 
+        // facilitate tracing by GC. The per-field metadata added are to be treated as references.
+        if (Velodrome.addPerFieldVelodromeMetadata()) {
+          if (Velodrome.shouldAddPerFieldVelodromeMetadata(field)) {
+            velodromeMetadataOffsets[index++] = field.getWriteMetadataOffset().toInt();
+            velodromeMetadataOffsets[index++] = field.getReadMetadataOffset().toInt();
+          }
+        }
+        
       }
+      if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(velodromeMetadataOffsets.length % 2 == 0); }
     }
 
     // Allocate space for <init> method pointers
@@ -1317,14 +1518,65 @@ public final class RVMClass extends RVMT
     if (!isInterface()) {
       final RVMMethod method =
           findVirtualMethod(RVMClassLoader.StandardObjectFinalizerMethodName,
-                            RVMClassLoader.StandardObjectFinalizerMethodDescriptor);
+                            RVMClassLoader.StandardObjectFinalizerMethodDescriptor,
+                            Context.FINALIZER_CONTEXT);
       if (!method.getDeclaringClass().isJavaLangObjectType()) {
         hasFinalizer = true;
       }
     }
 
     if (VM.TraceClassLoading && VM.runningVM) VM.sysWriteln("RVMClass: (end)   resolve " + this);
+    
+    // Velodrome: Context: Verify that non-application methods should have only one VM_CONTEXT
+    if (VM.VerifyAssertions && !Context.isApplicationPrefix(getTypeRef())) {
+      testContextOfNonApplicationMethods();
+    }
+    
+  }
+
+  private void addDeclaredMethods(MethodVector extraDeclaredMethods) {
+    RVMMethod[] newDeclaredMethods = new RVMMethod[declaredMethods.length + extraDeclaredMethods.size()];
+    int i;
+    for (i = 0; i < declaredMethods.length; i++) {
+      newDeclaredMethods[i] = declaredMethods[i];
+    }
+    for (int j = 0; j < extraDeclaredMethods.size(); j++, i++) {
+      newDeclaredMethods[i] = extraDeclaredMethods.elementAt(j);
+    }
+    declaredMethods = newDeclaredMethods;
+  }
+  
+  private void printMethods() {
+    VM.sysWriteln("Class name:", this.getDescriptor());
+    VM.sysWriteln("Start printVirtualMethods");
+    for (RVMMethod m : virtualMethods) {
+      VM.sysWrite(Velodrome.constructMethodSignature(m));
+      VM.sysWrite(" Static context:", m.getStaticContext());
+      VM.sysWriteln(" Resolved context:", m.getResolvedContext());
+    }
+    VM.sysWriteln("End printVirtualMethods");
+    VM.sysWriteln("Start printDeclaredMethods");
+    for (RVMMethod m : declaredMethods) {
+      VM.sysWrite(Velodrome.constructMethodSignature(m));
+      VM.sysWrite(" Static context:", m.getStaticContext());
+      VM.sysWriteln(" Resolved context:", m.getResolvedContext());
+    }
+    VM.sysWriteln("End printDeclaredMethods");
+  }
+  
+  // Velodrome: Context: Verify that non-application methods should have only one VM_CONTEXT
+  private void testContextOfNonApplicationMethods() {
+    // The following assertions don't work since we are currently considering org.xml.* packages as application.
+//    for (RVMMethod m : virtualMethods) {
+//      if (VM.VerifyAssertions) { VM._assert(m.getStaticContext() == Context.VM_CONTEXT); }
+//      if (VM.VerifyAssertions) { VM._assert(m.getResolvedContext() == Context.VM_CONTEXT); }
+//    }
+    for (RVMMethod m : declaredMethods) {
+      if (VM.VerifyAssertions) { VM._assert(m.getStaticContext() == Context.VM_CONTEXT); }
+      if (VM.VerifyAssertions) { VM._assert(m.getResolvedContext() == Context.VM_CONTEXT); }
+    }
   }
+  
 
   /**
    * Atomically initialize the important parts of the TIB and let the world know this type is
@@ -1530,6 +1782,36 @@ public final class RVMClass extends RVMT
     // run <clinit>
     //
     if (classInitializerMethod != null) {
+      
+      // Velodrome: Context: Need to invoke the correct version of class initializer irrespective of where <clinit> gets
+      // called from. We do this by walking the stack and finding the static context of the first application method.
+      if (Context.isApplicationPrefix(this.getTypeRef())) {
+        Address fp = Magic.getFramePointer();
+        int context = Context.NONTRANS_CONTEXT;
+        fp = Magic.getCallerFramePointer(fp);
+        // Search for the topmost application frame/method
+        while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+          int compiledMethodId = Magic.getCompiledMethodID(fp);
+          if (compiledMethodId != INVISIBLE_METHOD_ID) {
+            CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+            RVMMethod method = compiledMethod.getMethod();
+            if (!method.isNative() && Octet.shouldInstrumentMethod(method)) {
+              context = method.getStaticContext();
+              break;
+            }
+          }
+          fp = Magic.getCallerFramePointer(fp);
+        }
+        for (RVMMethod method : declaredMethods) { // Search for desired <clinit>
+          if (method.getName() == RVMClassLoader.StandardClassInitializerMethodName) {
+            if (method.getResolvedContext() == context) {
+              classInitializerMethod = method;
+              break;
+            }
+          }
+        }
+      }
+      
       CompiledMethod cm = classInitializerMethod.getCurrentCompiledMethod();
       while (cm == null) {
         classInitializerMethod.compile();
@@ -1699,7 +1981,7 @@ public final class RVMClass extends RVMT
    */
   public void updateTIBEntry(RVMMethod m) {
     if (VM.VerifyAssertions) {
-      RVMMethod vm = findVirtualMethod(m.getName(), m.getDescriptor());
+      RVMMethod vm = findVirtualMethod(m.getName(), m.getDescriptor(), m.getResolvedContext());
       VM._assert(vm == m);
     }
     typeInformationBlock.setVirtualMethod(m.getOffset(), m.getCurrentEntryCodeArray());
@@ -1714,7 +1996,7 @@ public final class RVMClass extends RVMT
    *       the most recent instructions for the method.
    */
   public void updateVirtualMethod(RVMMethod m) {
-    RVMMethod dm = findDeclaredMethod(m.getName(), m.getDescriptor());
+    RVMMethod dm = findDeclaredMethod(m.getName(), m.getDescriptor(), m.getResolvedContext());
     if (dm != null && dm != m) return;  // this method got overridden
     updateTIBEntry(m);
     if (m.isPrivate()) return; // can't override
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMField.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMField.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMField.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMField.java	2014-04-03 17:43:50.089693773 -0400
@@ -16,8 +16,11 @@ import java.io.DataInputStream;
 import java.io.IOException;
 import org.jikesrvm.VM;
 import org.jikesrvm.mm.mminterface.Barriers;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.Statics;
+import org.jikesrvm.velodrome.Velodrome;
+import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Extent;
@@ -50,6 +53,13 @@ public final class RVMField extends RVMM
    */
   private boolean madeTraced;
 
+  /** Octet: the offset of direct per-field metadata (currently for static fields only) */
+  private Offset metadataOffset = Offset.fromIntSignExtend(NO_OFFSET);
+  
+  /** Velodrome: Offset of additional header word */
+  private Offset writeMetadataOffset = Offset.fromIntSignExtend(NO_OFFSET);
+  private Offset readMetadataOffset = Offset.fromIntSignExtend(NO_OFFSET);
+
   /**
    * Create a field.
    *
@@ -125,6 +135,84 @@ public final class RVMField extends RVMM
     return new RVMField(annotationClass, memRef, (short) (ACC_PRIVATE | ACC_SYNTHETIC), null, 0, null);
   }
 
+  // Octet: metadata offsets
+
+  @Uninterruptible
+  @Inline
+  public final boolean hasMetadataOffset() {
+    if (VM.VerifyAssertions) { VM._assert(Octet.getConfig().addHeaderWord()); }
+    return metadataOffset.toInt() != NO_OFFSET;
+  }
+
+  @Uninterruptible
+  @Inline
+  public final Offset getMetadataOffset() {
+    if (VM.VerifyAssertions) { VM._assert(hasMetadataOffset()); }
+    return metadataOffset;
+  }
+
+  @Uninterruptible
+  @Inline
+  public final void setMetadataOffset(Offset offset) {
+    if (VM.VerifyAssertions) { VM._assert(!hasMetadataOffset()); }
+    metadataOffset = offset;
+  }
+  
+  // Velodrome: Helper methods for read/write metadata offset
+  
+  /** Check the offset of the first word */ 
+  @Uninterruptible
+  @Inline
+  public final boolean hasVelodromeMetadataOffset() {
+    return hasWriteMetadataOffset();
+  }
+  
+  @Uninterruptible
+  @Inline
+  private final boolean hasWriteMetadataOffset() {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.addPerFieldVelodromeMetadata()); }
+    boolean result = writeMetadataOffset.toInt() != NO_OFFSET;
+    if (VM.VerifyAssertions && result) { VM._assert(readMetadataOffset.toInt() != NO_OFFSET); }
+    return result;
+  }
+  
+  @Uninterruptible
+  @Inline
+  public final Offset getWriteMetadataOffset() {
+    if (VM.VerifyAssertions) { VM._assert(hasWriteMetadataOffset()); }
+    return writeMetadataOffset;
+  }
+  
+  @Uninterruptible
+  @Inline
+  public final void setWriteMetadataOffset(Offset offset) {
+    if (VM.VerifyAssertions) { VM._assert(!hasWriteMetadataOffset()); }
+    writeMetadataOffset = offset;
+  }
+  
+  @Uninterruptible
+  @Inline
+  private final boolean hasReadMetadataOffset() {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.addPerFieldVelodromeMetadata()); }
+    boolean result = readMetadataOffset.toInt() != NO_OFFSET;
+    if (VM.VerifyAssertions && result) { VM._assert(writeMetadataOffset.toInt() != NO_OFFSET); }
+    return result;
+  }
+  
+  @Uninterruptible
+  @Inline
+  public final Offset getReadMetadataOffset() {
+    if (VM.VerifyAssertions) { VM._assert(hasReadMetadataOffset()); }
+    return readMetadataOffset;
+  }
+  
+  @Uninterruptible
+  @Inline
+  public final void setReadMetadataOffset(Offset offset) {
+    if (VM.VerifyAssertions) { VM._assert(!hasReadMetadataOffset()); }
+    readMetadataOffset = offset;
+  }
+
   /**
    * Get type of this field's value.
    */
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMMember.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMMember.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMMember.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMMember.java	2014-04-03 17:43:50.083693755 -0400
@@ -23,7 +23,11 @@ import org.vmmagic.unboxed.Offset;
 public abstract class RVMMember extends AnnotatedElement implements Constants, ClassLoaderConstants {
 
   /** Initial value for a field offset - indicates field not laid out. */
-  private static final int NO_OFFSET = Short.MIN_VALUE + 1;
+  // Octet: Made package-protected instead of private, so RVMField can access it.
+  // Velodrome: LATER: Shouldn't this be initialized to Integer.MIN_VALUE? It seems that the offset cannot be an odd number.
+  // Otherwise, there are more slots allocated in the JTOC than Short.MIN_VALUE. 
+  // Also made this public. 
+  public static final int NO_OFFSET = Short.MIN_VALUE + 1;
 
   /**
    * The class that declared this member, available by calling
@@ -77,6 +81,16 @@ public abstract class RVMMember extends 
   // The following are available after class loading.                   //
   //--------------------------------------------------------------------//
 
+  // Octet: Static cloning: Support for cloning resolved methods.
+  protected RVMMember(RVMMember member) {
+    super(member);
+    this.declaringClass = member.declaringClass;
+    this.memRef = member.memRef;
+    this.modifiers = member.modifiers;
+    this.signature = member.signature;
+    this.offset = NO_OFFSET; // invalid value. Set to valid value during RVMClass.resolve()
+  }
+
   /**
    * Class that declared this field or method. Not available before
    * the class is loaded.
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMMethod.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMMethod.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMMethod.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMMethod.java	2014-04-03 17:43:50.087693767 -0400
@@ -12,26 +12,36 @@
  */
 package org.jikesrvm.classloader;
 
+import static org.jikesrvm.classloader.TypeReference.baseReflectionClass;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.ArchitectureSpecific.LazyCompilationTrampoline;
 import org.jikesrvm.VM;
 import org.jikesrvm.compilers.common.CompiledMethod;
 import org.jikesrvm.compilers.common.CompiledMethods;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.Reflection;
 import org.jikesrvm.runtime.ReflectionBase;
 import org.jikesrvm.runtime.Statics;
 import org.jikesrvm.util.HashMapRVM;
 import org.jikesrvm.util.ImmutableEntryHashMapRVM;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.Pure;
 import org.vmmagic.pragma.RuntimePure;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.pragma.Unpreemptible;
+import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
-import static org.jikesrvm.classloader.TypeReference.baseReflectionClass;
+
+// Octet: Static cloning: Modified this class in various places to support multiple resolved methods for every method reference.
 
 /**
  * A method of a java class corresponding to a method_info structure
@@ -40,6 +50,12 @@ import static org.jikesrvm.classloader.T
  */
 public abstract class RVMMethod extends RVMMember implements BytecodeConstants {
 
+  /** Because of inheritance, a method with just one static context may have multiple resolved methods (one for each context). */
+  private final int resolvedContext;
+
+  /** A method will always have a static context that reflects where it will be called from and what it should call. */
+  private final int staticContext;
+
   /**
    * current compiled method for this method
    */
@@ -87,7 +103,7 @@ public abstract class RVMMethod extends 
    */
   protected RVMMethod(TypeReference declaringClass, MemberReference memRef, short modifiers,
                       TypeReference[] exceptionTypes, Atom signature, RVMAnnotation[] annotations,
-                      RVMAnnotation[][] parameterAnnotations, Object annotationDefault) {
+                      RVMAnnotation[][] parameterAnnotations, Object annotationDefault, int resolvedContext) {
     super(declaringClass, memRef, (short) (modifiers & APPLICABLE_TO_METHODS), signature, annotations);
     if (parameterAnnotations != null) {
       synchronized(RVMMethod.parameterAnnotations) {
@@ -104,6 +120,74 @@ public abstract class RVMMethod extends 
         annotationDefaults.put(this, annotationDefault);
       }
     }
+    this.resolvedContext = resolvedContext;
+    // Velodrome: Context: Initialize static context for application methods 
+    if (Context.isApplicationPrefix(memRef.getType())) {
+      this.staticContext = computeMeetOfResolvedContextAndAtomicitySpec(memRef.asMethodReference(), resolvedContext);
+    } else {
+      this.staticContext = Context.getStaticContext(memRef.asMethodReference(), resolvedContext);
+    }
+  }
+
+  protected RVMMethod(RVMMethod method, int resolvedContext) {
+    super(method);
+    if (method.getParameterAnnotations() != null) {
+      synchronized(RVMMethod.parameterAnnotations) {
+        RVMMethod.parameterAnnotations.put(this, method.getParameterAnnotations());
+      }
+    }
+    if (method.getExceptionTypes() != null) {
+      synchronized(RVMMethod.exceptionTypes) {
+        RVMMethod.exceptionTypes.put(this, method.getExceptionTypes());
+      }
+    }
+    if (method.getAnnotationDefault() != null) {
+      synchronized(annotationDefaults) {
+        annotationDefaults.put(this, method.getAnnotationDefault());
+      }
+    }
+    this.resolvedContext = resolvedContext;
+    // Velodrome: Context: Initialize static context for application methods 
+    if (Context.isApplicationPrefix(memRef.getType())) {
+      this.staticContext = computeMeetOfResolvedContextAndAtomicitySpec(memRef.asMethodReference(), resolvedContext);
+    } else {
+      this.staticContext = Context.getStaticContext(memRef.asMethodReference(), resolvedContext);
+    }
+  }
+  
+  /** Velodrome: Context: Compute static context only for application methods. Logically, the static context of a method 
+   * is the meet of the resolved context and the atomicity specification.
+   * 
+   * Resolved Context     Atomicity spec              Static Context
+   * 
+   *    Trans                 Trans                       Trans
+   *    Trans                 Non-trans                   Trans
+   *    Non-trans             Trans                       Trans (Need to instrument prolog/epilog)
+   *    Non-trans             Non-trans                   Non-trans
+   *    
+   *  */
+  public static int computeMeetOfResolvedContextAndAtomicitySpec(MethodReference methodRef, int resolvedContext) {
+    int meet = Context.NONTRANS_CONTEXT;
+    if (resolvedContext == Context.TRANS_CONTEXT) {
+      meet = Context.TRANS_CONTEXT;
+    } else {
+      if (!methodRef.isNonAtomic) {
+        meet = Context.TRANS_CONTEXT;
+      }
+    }
+    return meet;
+  }
+
+  abstract RVMMethod cloneMethod(int resolvedContext);
+
+  @Uninterruptible
+  public final int getResolvedContext() {
+    return resolvedContext;
+  }
+  
+  @Uninterruptible
+  public final int getStaticContext() {
+    return staticContext;
   }
 
   /**
@@ -142,7 +226,7 @@ public abstract class RVMMethod extends 
    * @param input the DataInputStream to read the method's attributes from
    */
   static RVMMethod readMethod(TypeReference declaringClass, int[] constantPool, MemberReference memRef,
-                              short modifiers, DataInputStream input) throws IOException {
+                              short modifiers, DataInputStream input, int resolvedContext) throws IOException {
     short tmp_localWords = 0;
     short tmp_operandWords = 0;
     byte[] tmp_bytecodes = null;
@@ -237,7 +321,8 @@ public abstract class RVMMethod extends 
                               tmp_signature,
                               annotations,
                               parameterAnnotations,
-                              tmp_annotationDefault);
+                              tmp_annotationDefault,
+                              resolvedContext);
     } else if ((modifiers & ACC_ABSTRACT) != 0) {
       method =
           new AbstractMethod(declaringClass,
@@ -247,8 +332,8 @@ public abstract class RVMMethod extends 
                                 tmp_signature,
                                 annotations,
                                 parameterAnnotations,
-                                tmp_annotationDefault);
-
+                                tmp_annotationDefault,
+                                resolvedContext);
     } else {
       method =
           new NormalMethod(declaringClass,
@@ -265,7 +350,8 @@ public abstract class RVMMethod extends 
                               tmp_signature,
                               annotations,
                               parameterAnnotations,
-                              tmp_annotationDefault);
+                              tmp_annotationDefault,
+                              resolvedContext);
     }
     return method;
   }
@@ -307,7 +393,8 @@ public abstract class RVMMethod extends 
                                null,
                                null,
                                null,
-                               null);
+                               null,
+                               Context.VM_CONTEXT);
   }
 
   /**
@@ -364,7 +451,8 @@ public abstract class RVMMethod extends 
                                null,
                                null,
                                null,
-                               null);
+                               null,
+                               Context.VM_CONTEXT);
   }
 
   /**
@@ -693,9 +781,34 @@ public abstract class RVMMethod extends 
       return currentCompiledMethod.getEntryCodeArray();
     } else if (!VM.writingBootImage || isNative()) {
       if (!isStatic() && !isObjectInitializer() && !isPrivate()) {
+        // Velodrome: Context: Walk the stack to find out which RVMMethod version to use depending on the context
+        int context = getResolvedContext();
+        if (context == Context.VM_CONTEXT && Context.isApplicationPrefix(declaringClass.getTypeRef())) {
+          Address fp = Magic.getFramePointer();
+          fp = Magic.getCallerFramePointer(fp);
+          // Search for the topmost application frame/method
+          while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+            int compiledMethodId = Magic.getCompiledMethodID(fp);
+            if (compiledMethodId != INVISIBLE_METHOD_ID) {
+              CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+              RVMMethod method = compiledMethod.getMethod();
+              if (!method.isNative() && Octet.shouldInstrumentMethod(method)) {
+                context = method.getStaticContext();
+                break;
+              }
+            }
+            fp = Magic.getCallerFramePointer(fp);
+          }
+        }
+        // Velodrome: Context: Library class (javax.*) can extend application classes (gnu.java.*), example hedc.
+        // See comment in Context for library prefixes.
+        if (Context.isLibraryPrefix(declaringClass.getTypeRef()) && 
+            Context.isApplicationPrefix(declaringClass.getSuperClass().getTypeRef())) {
+          context = Context.TRANS_CONTEXT;
+        }
         // A non-private virtual method.
         if (declaringClass.isJavaLangObjectType() ||
-            declaringClass.getSuperClass().findVirtualMethod(getName(), getDescriptor()) == null) {
+            declaringClass.getSuperClass().findVirtualMethod(getName(), getDescriptor(), /*getResolvedContext()*/ context) == null) {
           // The root method of a virtual method family can use the lazy method invoker directly.
           return Entrypoints.lazyMethodInvokerMethod.getCurrentEntryCodeArray();
         } else {
@@ -918,7 +1031,8 @@ public abstract class RVMMethod extends 
                                null,
                                null,
                                null,
-                               null);
+                               null,
+                               Context.VM_CONTEXT);
   }
 
   /**
@@ -1104,6 +1218,7 @@ public abstract class RVMMethod extends 
                                null,
                                null,
                                null,
-                               null);
+                               null,
+                               Context.VM_CONTEXT);
   }
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMType.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMType.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/RVMType.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/RVMType.java	2014-04-03 17:43:50.079693741 -0400
@@ -12,10 +12,10 @@
  */
 package org.jikesrvm.classloader;
 
-import org.jikesrvm.VM;
+import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.Constants;
 import org.jikesrvm.SizeConstants;
-import org.jikesrvm.ArchitectureSpecific.CodeArray;
+import org.jikesrvm.VM;
 import org.jikesrvm.mm.mminterface.AlignmentEncoding;
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.objectmodel.TIB;
@@ -275,6 +275,16 @@ public abstract class RVMType extends An
     TIB tib = MemoryManager.newTIB(0, AlignmentEncoding.ALIGN_CODE_NONE);
     tib.setType(this);
     Statics.setSlotContents(getTibOffset(), tib);
+    
+    // Velodrome: TODO: Checking for TIB over here. But it doesn't work, there is a NPE
+    // while dereferencing tib.
+//    if (this.getDescriptor() == Velodrome.readMapDescriptor) {
+//      VM.sysWrite("Type descriptor:", this.getDescriptor());
+//      VM.sysWriteln("Read map TIB address:", ObjectReference.fromObject(tib));
+//    } else if (this.getDescriptor() == Velodrome.transactionDescriptor) {
+//      VM.sysWrite("Type descriptor:", this.getDescriptor());
+//      VM.sysWriteln("Transaction TIB address:", ObjectReference.fromObject(tib));
+//    } 
   }
 
   /**
@@ -632,15 +642,21 @@ public abstract class RVMType extends An
    * @param memberDescriptor method descriptor - something like "I" or "()I"
    * @return method description (null --> not found)
    */
-  public final RVMMethod findVirtualMethod(Atom memberName, Atom memberDescriptor) {
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+  public final RVMMethod findVirtualMethod(Atom memberName, Atom memberDescriptor, int context) {
     if (VM.VerifyAssertions) VM._assert(isResolved());
     RVMMethod[] methods = getVirtualMethods();
+    boolean foundSomething = false;
     for (int i = 0, n = methods.length; i < n; ++i) {
       RVMMethod method = methods[i];
       if (method.getName() == memberName && method.getDescriptor() == memberDescriptor) {
-        return method;
+        foundSomething = true;
+        if (Context.isMatch(method, context, /* resolve = */ false)) { // Velodrome: Context: Added a parameter
+          return method;
+        }
       }
     }
+    if (VM.VerifyAssertions) { VM._assert(!foundSomething); }
     return null;
   }
 
@@ -856,6 +872,9 @@ public abstract class RVMType extends An
    * reference-containing instance fields
    */
   protected int[] referenceOffsets;
+  
+  // Velodrome: Array storing offsets of Velodrome metadata reference fields
+  protected int[] velodromeMetadataOffsets;
 
   /**
    * Record the allocator information the memory manager holds about this type.
@@ -896,4 +915,12 @@ public abstract class RVMType extends An
     if (VM.VerifyAssertions) VM._assert(isResolved());
     return referenceOffsets;
   }
+  
+  // Velodrome: Return the array of metadata reference offsets
+  @Uninterruptible
+  public int[] getVelodromeMetadataOffsets() {
+    if (VM.VerifyAssertions) { VM._assert(isResolved()); }
+    return velodromeMetadataOffsets;
+  }
+  
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/TableBasedDynamicLinker.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/TableBasedDynamicLinker.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/TableBasedDynamicLinker.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/TableBasedDynamicLinker.java	2014-04-03 17:43:50.084693758 -0400
@@ -12,13 +12,17 @@
  */
 package org.jikesrvm.classloader;
 
-import org.jikesrvm.VM;
 import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
 import org.vmmagic.pragma.Entrypoint;
 
+// Octet: Static cloning: Modified various parts of this class to support multiple resolved methods per method reference.
+ 
+// Velodrome: Context: Changed this class to support 3 contexts
+
 /**
  * Dynamic linking via indirection tables. <p>
  *
@@ -44,12 +48,22 @@ public class TableBasedDynamicLinker imp
    * member or whether the member needs linking.
    */
   @Entrypoint
-  private static int[] memberOffsets;
+  private static int[] memberOffsetsVM;
+  
+  @Entrypoint
+  private static int[] memberOffsetsTrans;
+  
+  @Entrypoint
+  private static int[] memberOffsetsNonTrans;
 
   static {
-    memberOffsets = MemoryManager.newContiguousIntArray(32000);
+    memberOffsetsVM = MemoryManager.newContiguousIntArray(32000);
+    memberOffsetsTrans = MemoryManager.newContiguousIntArray(32000);
+    memberOffsetsNonTrans = MemoryManager.newContiguousIntArray(32000);
     if (NEEDS_DYNAMIC_LINK != 0) {
-      java.util.Arrays.fill(memberOffsets, NEEDS_DYNAMIC_LINK);
+      java.util.Arrays.fill(memberOffsetsVM, NEEDS_DYNAMIC_LINK);
+      java.util.Arrays.fill(memberOffsetsTrans, NEEDS_DYNAMIC_LINK);
+      java.util.Arrays.fill(memberOffsetsNonTrans, NEEDS_DYNAMIC_LINK);
     }
   }
 
@@ -60,9 +74,9 @@ public class TableBasedDynamicLinker imp
    * @return returns the offset of the member.
    */
   @Entrypoint
-  public static int resolveMember(int memberId) throws NoClassDefFoundError {
+  public static int resolveMember(int memberId, int context) throws NoClassDefFoundError {
     MemberReference ref = MemberReference.getMemberRef(memberId);
-    return resolveMember(ref);
+    return resolveMember(ref, context);
   }
 
   /**
@@ -70,13 +84,21 @@ public class TableBasedDynamicLinker imp
    * @param ref reference to the member to link
    * @return returns the offset of the member.
    */
-  public static int resolveMember(MemberReference ref) throws NoClassDefFoundError {
-    RVMMember resolvedMember = ref.resolveMember();
+  public static int resolveMember(MemberReference ref, int context) throws NoClassDefFoundError {
+    RVMMember resolvedMember = ref.resolveMember(context);
     RVMClass declaringClass = resolvedMember.getDeclaringClass();
     RuntimeEntrypoints.initializeClassForDynamicLink(declaringClass);
     int offset = resolvedMember.getOffset().toInt();
     if (VM.VerifyAssertions) VM._assert(offset != NEEDS_DYNAMIC_LINK);
-    memberOffsets[ref.getId()] = offset;
+    if (context == Context.VM_CONTEXT) {
+      memberOffsetsVM[ref.getId()] = offset;
+    } else if (context == Context.TRANS_CONTEXT) {
+      memberOffsetsTrans[ref.getId()] = offset;
+    } else if (context == Context.NONTRANS_CONTEXT) {
+      memberOffsetsNonTrans[ref.getId()] = offset;
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(NOT_REACHED); }
+    }
     return offset;
   }
 
@@ -86,15 +108,37 @@ public class TableBasedDynamicLinker imp
    * the given member reference.
    */
   static synchronized void ensureCapacity(int id) {
-    if (id >= memberOffsets.length) {
-      int oldLen = memberOffsets.length;
+    if (id >= memberOffsetsVM.length) {
+      int oldLen = memberOffsetsVM.length;
+      int[] tmp1 = MemoryManager.newContiguousIntArray((oldLen * 3) / 2);
+      System.arraycopy(memberOffsetsVM, 0, tmp1, 0, oldLen);
+      if (NEEDS_DYNAMIC_LINK != 0) {
+        java.util.Arrays.fill(tmp1, oldLen, tmp1.length, NEEDS_DYNAMIC_LINK);
+      }
+      Magic.sync(); // be sure array initialization is visible before we publish the reference!
+      memberOffsetsVM = tmp1;
+    }
+
+    if (id >= memberOffsetsTrans.length) {
+      int oldLen = memberOffsetsTrans.length;
+      int[] tmp1 = MemoryManager.newContiguousIntArray((oldLen * 3) / 2);
+      System.arraycopy(memberOffsetsTrans, 0, tmp1, 0, oldLen);
+      if (NEEDS_DYNAMIC_LINK != 0) {
+        java.util.Arrays.fill(tmp1, oldLen, tmp1.length, NEEDS_DYNAMIC_LINK);
+      }
+      Magic.sync(); // be sure array initialization is visible before we publish the reference!
+      memberOffsetsTrans = tmp1;
+    }
+    
+    if (id >= memberOffsetsNonTrans.length) {
+      int oldLen = memberOffsetsNonTrans.length;
       int[] tmp1 = MemoryManager.newContiguousIntArray((oldLen * 3) / 2);
-      System.arraycopy(memberOffsets, 0, tmp1, 0, oldLen);
+      System.arraycopy(memberOffsetsNonTrans, 0, tmp1, 0, oldLen);
       if (NEEDS_DYNAMIC_LINK != 0) {
         java.util.Arrays.fill(tmp1, oldLen, tmp1.length, NEEDS_DYNAMIC_LINK);
       }
       Magic.sync(); // be sure array initialization is visible before we publish the reference!
-      memberOffsets = tmp1;
+      memberOffsetsNonTrans = tmp1;
     }
   }
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/TypeReference.java workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/TypeReference.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/classloader/TypeReference.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/classloader/TypeReference.java	2014-04-03 17:43:50.085693761 -0400
@@ -15,6 +15,7 @@ package org.jikesrvm.classloader;
 import org.jikesrvm.VM;
 import static org.jikesrvm.SizeConstants.BYTES_IN_ADDRESS;
 
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.ReflectionBase;
 import org.jikesrvm.util.ImmutableEntryHashSetRVM;
 
@@ -124,6 +125,14 @@ public final class TypeReference {
   public static final TypeReference ITable = findOrCreate(org.jikesrvm.objectmodel.ITable.class);
   public static final TypeReference IMT = findOrCreate(org.jikesrvm.objectmodel.IMT.class);
   public static final TypeReference Thread = findOrCreate(org.jikesrvm.scheduler.RVMThread.class);
+  // Octet: A type reference to the class for Octet barriers so we can check for it (for debugging purposes).
+  // Added finalizer and compilation threads, so we can check for these types when looking at a thread object (for debugging purposes only)
+  public static final TypeReference OctetBarriers = findOrCreate(org.jikesrvm.octet.OctetBarriers.class);
+  /*
+  public static final TypeReference FinalizerThread = findOrCreate(org.jikesrvm.scheduler.FinalizerThread.class);
+  public static final TypeReference CompilationThread = findOrCreate(org.jikesrvm.adaptive.recompilation.CompilationThread.class);
+  public static final TypeReference ControllerThread = findOrCreate(org.jikesrvm.adaptive.controller.ControllerThread.class);
+  */
   public static final TypeReference FunctionTable = findOrCreate(org.jikesrvm.jni.FunctionTable.class);
   public static final TypeReference LinkageTripletTable = findOrCreate(org.jikesrvm.jni.LinkageTripletTable.class);
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/EdgeCounts.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/EdgeCounts.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/EdgeCounts.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/EdgeCounts.java	2014-04-03 17:43:42.244667989 -0400
@@ -21,6 +21,7 @@ import java.util.StringTokenizer;
 import org.jikesrvm.VM;
 import org.jikesrvm.Callbacks;
 import org.jikesrvm.adaptive.controller.Controller;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.NormalMethod;
 import org.jikesrvm.runtime.Magic;
@@ -137,10 +138,16 @@ public final class EdgeCounts implements
     if (data == null) return;
     for (int i = 0; i < data.length; i++) {
       if (data[i] != null) {
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
+        // Here we try the application context and then the VM context.
+        // Velodrome: Context: Blindly using TRANS_CONTEXT for now
         NormalMethod m =
-            (NormalMethod) MemberReference.getMemberRef(i).asMethodReference().peekResolvedMethod();
+            (NormalMethod) MemberReference.getMemberRef(i).asMethodReference().peekResolvedMethod(Context.TRANS_CONTEXT);
         if (m != null) {
-          new BranchProfiles(m, data[i]).print(f);
+          m = (NormalMethod) MemberReference.getMemberRef(i).asMethodReference().peekResolvedMethod(Context.VM_CONTEXT);
+          if (m != null) {
+            new BranchProfiles(m, data[i]).print(f);
+          }
         }
       }
     }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineCompilerImpl.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineCompilerImpl.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineCompilerImpl.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineCompilerImpl.java	2014-04-03 17:43:42.448668660 -0400
@@ -12,12 +12,37 @@
  */
 package org.jikesrvm.compilers.baseline.ia32;
 
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_ADDRESS_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_BOOLEAN_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_BYTE_ASTORE_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_BYTE_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_CHAR_ASTORE_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_CHAR_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_DOUBLE_ASTORE_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_DOUBLE_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_EXTENT_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_FLOAT_ASTORE_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_FLOAT_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_INT_ASTORE_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_INT_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_LONG_ASTORE_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_LONG_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_OBJECT_ALOAD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_OBJECT_GETFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_OBJECT_GETSTATIC_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_OBJECT_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_OBJECT_PUTSTATIC_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_OFFSET_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_SHORT_ASTORE_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_SHORT_PUTFIELD_BARRIER;
+import static org.jikesrvm.mm.mminterface.Barriers.NEEDS_WORD_PUTFIELD_BARRIER;
+
 import org.jikesrvm.SizeConstants;
-import static org.jikesrvm.mm.mminterface.Barriers.*;
 import org.jikesrvm.VM;
 import org.jikesrvm.adaptive.AosEntrypoints;
 import org.jikesrvm.adaptive.recompilation.InvocationCounts;
 import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.DynamicTypeCheck;
 import org.jikesrvm.classloader.FieldReference;
 import org.jikesrvm.classloader.InterfaceInvocation;
@@ -43,6 +68,7 @@ import org.jikesrvm.jni.ia32.JNICompiler
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.objectmodel.JavaHeaderConstants;
 import org.jikesrvm.objectmodel.ObjectModel;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.ArchEntrypoints;
 import org.jikesrvm.runtime.Entrypoints;
 import org.jikesrvm.runtime.Magic;
@@ -50,6 +76,7 @@ import org.jikesrvm.runtime.MagicNames;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
 import org.jikesrvm.runtime.Statics;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Offset;
@@ -75,6 +102,9 @@ public abstract class BaselineCompilerIm
   static final Offset FIVE_SLOTS = FOUR_SLOTS.plus(WORDSIZE);
   private static final Offset MINUS_ONE_SLOT = NO_SLOT.minus(WORDSIZE);
 
+  /** Octet: baseline instrumentation helper */
+  final OctetBaselineInstr octetBaselineInstr = Octet.getClientAnalysis().newBaselineInstr();
+
   /**
    * Create a BaselineCompilerImpl object for the compilation of method.
    */
@@ -462,11 +492,24 @@ public abstract class BaselineCompilerIm
 
   @Override
   protected final void emit_iaload() {
+
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, true, ONE_SLOT, TypeReference.Int, asm);
+    }
+
     asm.emitPOP_Reg(T0); // T0 is array index
     asm.emitPOP_Reg(S0); // S0 is array ref
     genBoundsCheck(asm, T0, S0); // T0 is index, S0 is address of array
     // push [S0+T0<<2]
     asm.emitPUSH_RegIdx(S0, T0, Assembler.WORD, NO_SLOT);
+    
+    // Velodrome: Insert post-barriers
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, true, S0, T0, TypeReference.Int, asm);
+    }
+    
   }
 
   @Override
@@ -477,24 +520,74 @@ public abstract class BaselineCompilerIm
 
   @Override
   protected final void emit_aaload() {
+
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, true, ONE_SLOT, TypeReference.ObjectReference, asm);
+    }
+
     asm.emitPOP_Reg(T0); // T0 is array index
     asm.emitPOP_Reg(T1); // T1 is array ref
     genBoundsCheck(asm, T0, T1); // T0 is index, T1 is address of array
     if (NEEDS_OBJECT_ALOAD_BARRIER) {
+      
+      // Velodrome: save ref and index values
+      if (Velodrome.instrumentArrays()) {
+        asm.emitPUSH_Reg(T1); // T1 is array ref
+        asm.emitPUSH_Reg(T0); // T0 is array index
+      }
+      
       // rewind 2 args on stack
       asm.emitPUSH_Reg(T1); // T1 is array ref
       asm.emitPUSH_Reg(T0); // T0 is array index
       Barriers.compileArrayLoadBarrier(asm, true);
+      
+      // Velodrome: restore ref and index values
+      if (Velodrome.instrumentArrays()) {
+        asm.emitPOP_Reg(S0);
+        asm.emitPOP_Reg(T0); // T0 is array index
+        asm.emitPOP_Reg(T1); // T1 is array ref
+        asm.emitPUSH_Reg(S0);
+      }
+      
     } else {
       asm.emitPUSH_RegIdx(T1, T0, (short)LG_WORDSIZE, NO_SLOT); // push [S0+T0*WORDSIZE]
     }
+    
+    // Velodrome: Insert post-barriers
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, true, T1, T0, TypeReference.ObjectReference, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_caload() {
+
+    // Velodrome: Eclipse6 throws an exception while reading a character array in method getNextToken(). Now if the 
+    // pre-barrier comes before the array bounds check, then in such cases, pre-barrier would be executed but the 
+    // post-barrier won't since the control will switch to the exception block. To avoid this problem, we insert the 
+    // Octet pre-barrier after the array bounds check. 
+    
+    // Velodrome: Duplicate the array index and array ref
+    if (Velodrome.instrumentArrays()) {
+      asm.emitPUSH_RegDisp(SP, ONE_SLOT); // array ref
+      asm.emitPUSH_RegDisp(SP, ONE_SLOT); // array index
+    }
+
     asm.emitPOP_Reg(T0); // T0 is array index
     asm.emitPOP_Reg(S0); // S0 is array ref
     genBoundsCheck(asm, T0, S0); // T0 is index, S0 is address of array
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier after array bounds check
+      octetBaselineInstr.insertArrayBarrier(method, biStart, true, ONE_SLOT, TypeReference.Char, asm);
+      asm.emitPOP_Reg(T0); // T0 is array index
+      asm.emitPOP_Reg(S0); // S0 is array ref
+    }
+    
     // T1 = (int)[S0+T0<<1]
     if (VM.BuildFor32Addr) {
       asm.emitMOVZX_Reg_RegIdx_Word(T1, S0, T0, Assembler.SHORT, NO_SLOT);
@@ -502,10 +595,23 @@ public abstract class BaselineCompilerIm
       asm.emitMOVZXQ_Reg_RegIdx_Word(T1, S0, T0, Assembler.SHORT, NO_SLOT);
     }
     asm.emitPUSH_Reg(T1);        // push short onto stack
+    
+    // Velodrome: Insert post-barriers
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, true, S0, T0, TypeReference.Char, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_saload() {
+
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, true, ONE_SLOT, TypeReference.Short, asm);
+    }
+
     asm.emitPOP_Reg(T0); // T0 is array index
     asm.emitPOP_Reg(S0); // S0 is array ref
     genBoundsCheck(asm, T0, S0); // T0 is index, S0 is address of array
@@ -516,10 +622,23 @@ public abstract class BaselineCompilerIm
       asm.emitMOVSXQ_Reg_RegIdx_Word(T1, S0, T0, Assembler.SHORT, NO_SLOT);
     }
     asm.emitPUSH_Reg(T1);        // push short onto stack
+    
+    // Velodrome: Insert post-barriers
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, true, S0, T0, TypeReference.Short, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_baload() {
+
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, true, ONE_SLOT, TypeReference.Byte, asm);
+    }
+
     asm.emitPOP_Reg(T0); // T0 is array index
     asm.emitPOP_Reg(S0); // S0 is array ref
     genBoundsCheck(asm, T0, S0); // T0 is index, S0 is address of array
@@ -530,10 +649,23 @@ public abstract class BaselineCompilerIm
       asm.emitMOVSXQ_Reg_RegIdx_Byte(T1, S0, T0, Assembler.BYTE, NO_SLOT);
     }
     asm.emitPUSH_Reg(T1);        // push byte onto stack
+    
+    // Velodrome: Insert post-barriers
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, true, S0, T0, TypeReference.Byte, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_laload() {
+
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, true, ONE_SLOT, TypeReference.Long, asm);
+    }
+
     asm.emitPOP_Reg(T0); // T0 is array index
     asm.emitPOP_Reg(T1); // T1 is array ref
     if (VM.BuildFor32Addr && SSE2_BASE) {
@@ -552,6 +684,12 @@ public abstract class BaselineCompilerIm
       adjustStack(-WORDSIZE, true);
       asm.emitPUSH_RegIdx(T1, T0, Assembler.LONG, NO_SLOT);  // load desired long array element
     }
+    
+    // Velodrome: Insert post-barriers
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, true, T1, T0, TypeReference.Long, asm);
+    }
+    
   }
 
   @Override
@@ -573,6 +711,49 @@ public abstract class BaselineCompilerIm
     stackMoveHelper(T0, index); // T0 is array index
     stackMoveHelper(S0, arrayRef); // S0 is array ref
     genBoundsCheck(asm, T0, S0); // T0 is index, S0 is address of array
+
+    // Velodrome: save a duplicate copy of the ref and index values on stack, to be used by post barrier
+    if (Velodrome.instrumentArrays()) {
+      if (index.EQ(ONE_SLOT) && arrayRef.EQ(TWO_SLOTS)) {
+        saveRefIdx(1);
+      } else {
+        if (VM.VerifyAssertions) { VM._assert(index.EQ(TWO_SLOTS) && arrayRef.EQ(THREE_SLOTS)); }
+        saveRefIdx(2);
+      }
+    }
+
+  }
+  
+  /** Velodrome: save a duplicate copy of the ref and index values on stack, to be used by post barrier
+  *
+  *    |   |      SP->|idx|
+  *    |   |          |ref|
+  *SP->|idx|  =>      |idx|
+  *    |ref|          |ref|
+  *    |___|          |___|
+  */
+  private void saveRefIdx(int valueLen) {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.instrumentArrays()); }
+    if (valueLen == 1) {
+      asm.emitPOP_Reg(T1); // T1 is the value to be stored
+      asm.emitPUSH_RegDisp(SP, ONE_SLOT);
+      asm.emitPUSH_RegDisp(SP, ONE_SLOT);
+      asm.emitPUSH_Reg(T1);
+    } else if (valueLen == 2){
+      asm.emitPOP_Reg(T1);
+      asm.emitPOP_Reg(S0);
+      asm.emitPUSH_RegDisp(SP, ONE_SLOT);
+      asm.emitPUSH_RegDisp(SP, ONE_SLOT);
+      asm.emitPUSH_Reg(S0);
+      asm.emitPUSH_Reg(T1);
+    }
+  }
+
+  // Velodrome: restore ref and index values from stack
+  private void restoreRefIdxReg(GPR ref, GPR idx) {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.instrumentArrays()); }
+    asm.emitPOP_Reg(idx);
+    asm.emitPOP_Reg(ref);
   }
 
   /**
@@ -641,6 +822,13 @@ public abstract class BaselineCompilerIm
 
   @Override
   protected final void emit_iastore() {
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, TWO_SLOTS, TypeReference.Int, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 8);
     if (NEEDS_INT_ASTORE_BARRIER) {
       boundsCheckHelper(ONE_SLOT, TWO_SLOTS);
@@ -648,23 +836,61 @@ public abstract class BaselineCompilerIm
     } else {
       arrayStore32bitHelper();
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.Int, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_fastore() {
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, TWO_SLOTS, TypeReference.Float, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 8);
     if (NEEDS_FLOAT_ASTORE_BARRIER) {
       boundsCheckHelper(ONE_SLOT, TWO_SLOTS);
       Barriers.compileArrayStoreBarrierFloat(asm, this);
+      
+      // Velodrome: restore ref and index values from stack
+      if (Velodrome.instrumentArrays()) {
+        restoreRefIdxReg(S0, T0);
+      }
+      
     } else {
       arrayStore32bitHelper();
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.Float, asm);
+    }
+    
   }
 
 
   @Override
   protected final void emit_aastore() {
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, TWO_SLOTS, TypeReference.ObjectReference, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 8);
+    
+    // Velodrome: save ref and idx on stack
+    if (Velodrome.instrumentArrays()) {
+      saveRefIdx(1);
+    }
+    
     if (doesCheckStore) {
       genParameterRegisterLoad(asm, 3);
       asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.aastoreMethod.getOffset()));
@@ -672,36 +898,95 @@ public abstract class BaselineCompilerIm
       genParameterRegisterLoad(asm, 3);
       asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.aastoreUninterruptibleMethod.getOffset()));
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      // Velodrome: restore ref and index values from stack
+      restoreRefIdxReg(S0, T0);
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.ObjectReference, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_castore() {
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, TWO_SLOTS, TypeReference.Char, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 8);
     if (NEEDS_CHAR_ASTORE_BARRIER) {
       boundsCheckHelper(ONE_SLOT, TWO_SLOTS);
       Barriers.compileArrayStoreBarrierChar(asm, this);
+      
+      // Velodrome: restore ref and index values from stack
+      if (Velodrome.instrumentArrays()) {
+        restoreRefIdxReg(S0, T0);
+      }
+      
     } else {
       arrayStore16bitHelper();
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.Char, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_sastore() {
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, TWO_SLOTS, TypeReference.Short, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 8);
     if (NEEDS_SHORT_ASTORE_BARRIER) {
       boundsCheckHelper(ONE_SLOT, TWO_SLOTS);
       Barriers.compileArrayStoreBarrierShort(asm, this);
+      
+      // Velodrome: restore ref and index values from stack
+      if (Velodrome.instrumentArrays()) {
+        restoreRefIdxReg(S0, T0);
+      }
+      
     } else {
       arrayStore16bitHelper();
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.Short, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_bastore() {
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, TWO_SLOTS, TypeReference.Byte, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 8);
     if (NEEDS_BYTE_ASTORE_BARRIER) {
       boundsCheckHelper(ONE_SLOT, TWO_SLOTS);
       Barriers.compileArrayStoreBarrierByte(asm, this);
+      
+      // Velodrome: restore ref and index values from stack
+      if (Velodrome.instrumentArrays()) {
+        restoreRefIdxReg(S0, T0);
+      }
+      
     } else {
       asm.emitPOP_Reg(T1); // T1 is the value
       asm.emitPOP_Reg(T0); // T0 is array index
@@ -709,28 +994,72 @@ public abstract class BaselineCompilerIm
       genBoundsCheck(asm, T0, S0);         // T0 is index, S0 is address of array
       asm.emitMOV_RegIdx_Reg_Byte(S0, T0, Assembler.BYTE, NO_SLOT, T1); // [S0 + T0<<2] <- T1
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.Byte, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_lastore() {
+    
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, THREE_SLOTS, TypeReference.Long, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 12);
     if (NEEDS_LONG_ASTORE_BARRIER) {
       boundsCheckHelper(TWO_SLOTS, THREE_SLOTS);
       Barriers.compileArrayStoreBarrierLong(asm, this);
+      
+      // Velodrome: restore ref and index values from stack
+      if (Velodrome.instrumentArrays()) {
+        restoreRefIdxReg(S0, T0);
+      }
+
     } else {
       arrayStore64bitHelper();
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.Long, asm);
+    }
+    
   }
 
   @Override
   protected final void emit_dastore() {
+
+    // Velodrome: Conditional instrumentation of array accesses
+    if (Velodrome.instrumentArrays()) {
+      // Octet: insert barrier
+      octetBaselineInstr.insertArrayBarrier(method, biStart, false, THREE_SLOTS, TypeReference.Double, asm);
+    }
+
     Barriers.compileModifyCheck(asm, 12);
     if (NEEDS_DOUBLE_ASTORE_BARRIER) {
       boundsCheckHelper(TWO_SLOTS, THREE_SLOTS);
       Barriers.compileArrayStoreBarrierDouble(asm, this);
+      
+      // Velodrome: restore ref and index values from stack
+      if (Velodrome.instrumentArrays()) {
+        restoreRefIdxReg(S0, T0);
+      }
+      
     } else {
       arrayStore64bitHelper();
     }
+    
+    // Velodrome: Insert post-barrier
+    if (Velodrome.instrumentArrays()) {
+      VelodromeBaselineInstr.insertPostBarrierForArray(method, biStart, false, S0, T0, TypeReference.Double, asm);
+    }
+    
   }
 
   /*
@@ -2160,6 +2489,14 @@ public abstract class BaselineCompilerIm
   @Override
   protected final void emit_ireturn() {
     if (method.isSynchronized()) genMonitorExit();
+
+    // Velodrome: Insert instrumentation at method return
+    if (Octet.shouldInstrumentMethod(method) && (Velodrome.methodsAsTransactions() || method.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+      if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+        VelodromeBaselineInstr.insertInstrumentationAtTransactionEnd(method, biStart, asm, octetBaselineInstr, method.getId());
+      }
+    }
+    
     asm.emitPOP_Reg(T0);
     genEpilogue(WORDSIZE, WORDSIZE);
   }
@@ -2167,6 +2504,14 @@ public abstract class BaselineCompilerIm
   @Override
   protected final void emit_lreturn() {
     if (method.isSynchronized()) genMonitorExit();
+
+    // Velodrome: Insert instrumentation at method return
+    if (Octet.shouldInstrumentMethod(method) && (Velodrome.methodsAsTransactions() || method.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+      if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+        VelodromeBaselineInstr.insertInstrumentationAtTransactionEnd(method, biStart, asm, octetBaselineInstr, method.getId());
+      }
+    }
+
     if (VM.BuildFor32Addr) {
       asm.emitPOP_Reg(T1); // low half
       asm.emitPOP_Reg(T0); // high half
@@ -2180,6 +2525,14 @@ public abstract class BaselineCompilerIm
   @Override
   protected final void emit_freturn() {
     if (method.isSynchronized()) genMonitorExit();
+
+    // Velodrome: Insert instrumentation at method return
+    if (Octet.shouldInstrumentMethod(method) && (Velodrome.methodsAsTransactions() || method.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+      if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+        VelodromeBaselineInstr.insertInstrumentationAtTransactionEnd(method, biStart, asm, octetBaselineInstr, method.getId());
+      }
+    }
+    
     if (SSE2_FULL) {
       asm.emitMOVSS_Reg_RegInd(XMM0, SP);
     } else {
@@ -2191,6 +2544,14 @@ public abstract class BaselineCompilerIm
   @Override
   protected final void emit_dreturn() {
     if (method.isSynchronized()) genMonitorExit();
+
+    // Velodrome: Insert instrumentation at method return
+    if (Octet.shouldInstrumentMethod(method) && (Velodrome.methodsAsTransactions() || method.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+      if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+        VelodromeBaselineInstr.insertInstrumentationAtTransactionEnd(method, biStart, asm, octetBaselineInstr, method.getId());
+      }
+    }
+
     if (SSE2_FULL) {
       asm.emitMOVLPD_Reg_RegInd(XMM0, SP);
     } else {
@@ -2202,6 +2563,14 @@ public abstract class BaselineCompilerIm
   @Override
   protected final void emit_areturn() {
     if (method.isSynchronized()) genMonitorExit();
+
+    // Velodrome: Insert instrumentation at method return
+    if (Octet.shouldInstrumentMethod(method) && (Velodrome.methodsAsTransactions() || method.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+      if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+        VelodromeBaselineInstr.insertInstrumentationAtTransactionEnd(method, biStart, asm, octetBaselineInstr, method.getId());
+      }
+    }
+
     asm.emitPOP_Reg(T0);
     genEpilogue(WORDSIZE, WORDSIZE);
   }
@@ -2209,6 +2578,14 @@ public abstract class BaselineCompilerIm
   @Override
   protected final void emit_return() {
     if (method.isSynchronized()) genMonitorExit();
+
+    // Velodrome: Insert instrumentation at method return
+    if (Octet.shouldInstrumentMethod(method) && (Velodrome.methodsAsTransactions() || method.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+      if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+        VelodromeBaselineInstr.insertInstrumentationAtTransactionEnd(method, biStart, asm, octetBaselineInstr, method.getId());
+      }
+    }
+
     genEpilogue(0, 0);
   }
 
@@ -2219,6 +2596,10 @@ public abstract class BaselineCompilerIm
   @Override
   protected final void emit_unresolved_getstatic(FieldReference fieldRef) {
     emitDynamicLinkingSequence(asm, T0, fieldRef, true);
+
+    // Octet: insert barrier
+    octetBaselineInstr.insertStaticBarrierUnresolved(method, biStart, true, T0, fieldRef, asm);
+
     if (NEEDS_OBJECT_GETSTATIC_BARRIER && !fieldRef.getFieldContentsType().isPrimitiveType()) {
       Barriers.compileGetstaticBarrier(asm, T0, fieldRef.getId());
       return;
@@ -2243,14 +2624,31 @@ public abstract class BaselineCompilerIm
         asm.emitPUSH_RegOff(T0, Assembler.BYTE, Magic.getTocPointer().toWord().toOffset());
       }
     }
+
+    // Velodrome: Inserting instrumentation to release metadata lock
+    // T0 seems to have the offset
+    if (Velodrome.insertPostBarriers()) {
+      VelodromeBaselineInstr.insertInstrumentationToUnlockMetadataForStaticUnresolved(method, biStart, true, fieldRef, asm);
+    }
+
   }
 
   @Override
   protected final void emit_resolved_getstatic(FieldReference fieldRef) {
     RVMField field = fieldRef.peekResolvedField();
     Offset fieldOffset = field.getOffset();
+
+    // Octet: insert barrier
+    octetBaselineInstr.insertStaticBarrierResolved(method, biStart, true, field, asm);
+
     if (NEEDS_OBJECT_GETSTATIC_BARRIER && !fieldRef.getFieldContentsType().isPrimitiveType() && !field.isUntraced()) {
       Barriers.compileGetstaticBarrierImm(asm, fieldOffset, fieldRef.getId());
+
+      // Velodrome: Inserting instrumentation to release metadata lock before returning
+      if (Velodrome.insertPostBarriers()) {
+        VelodromeBaselineInstr.insertInstrumentationToUnlockMetadataForStaticResolved(method, biStart, true, field, asm);
+      }
+
       return;
     }
     if (fieldRef.getSize() <= BYTES_IN_INT) { // field is one word
@@ -2272,11 +2670,22 @@ public abstract class BaselineCompilerIm
         asm.emitPUSH_Abs(Magic.getTocPointer().plus(fieldOffset));
       }
     }
+
+    // Velodrome: Inserting instrumentation to release metadata lock
+    // T0 seems to have the offset
+    if (Velodrome.insertPostBarriers()) {
+      VelodromeBaselineInstr.insertInstrumentationToUnlockMetadataForStaticResolved(method, biStart, true, field, asm);
+    }
+
   }
 
   @Override
   protected final void emit_unresolved_putstatic(FieldReference fieldRef) {
     emitDynamicLinkingSequence(asm, T0, fieldRef, true);
+
+    // Octet: insert barrier
+    octetBaselineInstr.insertStaticBarrierUnresolved(method, biStart, false, T0, fieldRef, asm);
+
     if (NEEDS_OBJECT_PUTSTATIC_BARRIER && fieldRef.getFieldContentsType().isReferenceType()) {
       Barriers.compilePutstaticBarrier(asm, T0, fieldRef.getId());
     } else {
@@ -2300,6 +2709,13 @@ public abstract class BaselineCompilerIm
         }
       }
     }
+    
+    // Velodrome: Inserting instrumentation to release metadata lock
+    // T0 seems to have the offset
+    if (Velodrome.insertPostBarriers()) {
+      VelodromeBaselineInstr.insertInstrumentationToUnlockMetadataForStaticUnresolved(method, biStart, false, fieldRef, asm);
+    }
+    
     // The field may be volatile
     asm.emitMFENCE();
   }
@@ -2308,6 +2724,10 @@ public abstract class BaselineCompilerIm
   protected final void emit_resolved_putstatic(FieldReference fieldRef) {
     RVMField field = fieldRef.peekResolvedField();
     Offset fieldOffset = field.getOffset();
+
+    // Octet: insert barrier
+    octetBaselineInstr.insertStaticBarrierResolved(method, biStart, false, field, asm);
+
     if (NEEDS_OBJECT_PUTSTATIC_BARRIER && field.isReferenceType() && !field.isUntraced()) {
       Barriers.compilePutstaticBarrierImm(asm, fieldOffset, fieldRef.getId());
     } else {
@@ -2331,6 +2751,12 @@ public abstract class BaselineCompilerIm
         }
       }
     }
+    
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      VelodromeBaselineInstr.insertInstrumentationToUnlockMetadataForStaticResolved(method, biStart, false, field, asm);
+    }
+    
     if (field.isVolatile()) {
       asm.emitMFENCE();
     }
@@ -2340,10 +2766,30 @@ public abstract class BaselineCompilerIm
   protected final void emit_unresolved_getfield(FieldReference fieldRef) {
     TypeReference fieldType = fieldRef.getFieldContentsType();
     emitDynamicLinkingSequence(asm, T0, fieldRef, true);
+
+    // Octet: insert barrier
+    octetBaselineInstr.insertFieldBarrierUnresolved(method, biStart, true, NO_SLOT, T0, fieldRef, asm);
+    // Velodrome: Track whether the code generation flow goes into the else part
+    boolean is64BitLoad = false;
+
     if (fieldType.isReferenceType()) {
       // 32/64bit reference load
       if (NEEDS_OBJECT_GETFIELD_BARRIER) {
+
+        // Velodrome: Save the object reference on stack
+        if (Velodrome.insertPostBarriers()) {
+          asm.emitPUSH_RegInd(SP);
+        }
+
         Barriers.compileGetfieldBarrier(asm, T0, fieldRef.getId());
+
+        // Velodrome: Restore the object reference to S0
+        if (Velodrome.insertPostBarriers()) {
+          asm.emitPOP_Reg(T1);
+          asm.emitPOP_Reg(S0);
+          asm.emitPUSH_Reg(T1);
+        }
+
       } else {
         asm.emitPOP_Reg(S0);                                  // S0 is object reference
         asm.emitPUSH_RegIdx(S0, T0, Assembler.BYTE, NO_SLOT); // place field value on stack
@@ -2380,6 +2826,12 @@ public abstract class BaselineCompilerIm
                    (VM.BuildFor64Addr && fieldType.isWordLikeType()));
       }
       asm.emitPOP_Reg(T1);           // T1 is object reference
+
+      // Velodrome: Make a backup of the object reference
+      if (Velodrome.insertPostBarriers()) {
+        is64BitLoad = true;
+      }
+
       if (VM.BuildFor32Addr) {
         // NB this is a 64bit copy from memory to the stack so implement
         // as a slightly optimized Intel memory copy using the FPU
@@ -2398,6 +2850,18 @@ public abstract class BaselineCompilerIm
         asm.emitPUSH_RegIdx(T1, T0, Assembler.BYTE, NO_SLOT); // place value on stack
       }
     }
+
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      GPR reg = S0;
+      if (fieldType.isReferenceType() && NEEDS_OBJECT_GETFIELD_BARRIER) {
+        reg = S0; // The register containing object reference is changed
+      } else if (is64BitLoad) { // 64 bit load case
+        reg = T1;
+      }
+      VelodromeBaselineInstr.insertPostBarrierForUnresolvedGetfield(method, biStart, asm, fieldRef, reg);
+    }
+    
   }
 
   @Override
@@ -2405,10 +2869,30 @@ public abstract class BaselineCompilerIm
     TypeReference fieldType = fieldRef.getFieldContentsType();
     RVMField field = fieldRef.peekResolvedField();
     Offset fieldOffset = field.getOffset();
+
+    // Octet: insert barrier
+    octetBaselineInstr.insertFieldBarrierResolved(method, biStart, true, NO_SLOT, field, asm);
+    // Velodrome: Track whether the code generation flow goes into the 64-bit else part
+    boolean is64BitLoad = false;
+
     if (field.isReferenceType()) {
       // 32/64bit reference load
       if (NEEDS_OBJECT_GETFIELD_BARRIER && !field.isUntraced()) {
+
+        // Velodrome: Save the object reference on stack
+        if (Velodrome.insertPostBarriers()) {
+          asm.emitPUSH_RegInd(SP);
+        }
+
         Barriers.compileGetfieldBarrierImm(asm, fieldOffset, fieldRef.getId());
+
+        // Velodrome: Restore the object reference to T0
+        if (Velodrome.insertPostBarriers()) {
+          asm.emitPOP_Reg(T1);
+          asm.emitPOP_Reg(T0);
+          asm.emitPUSH_Reg(T1);
+        }
+
       } else {
         asm.emitPOP_Reg(T0);                   // T0 is object reference
         asm.emitPUSH_RegDisp(T0, fieldOffset); // place field value on stack
@@ -2446,6 +2930,12 @@ public abstract class BaselineCompilerIm
                    (VM.BuildFor64Addr && fieldType.isWordLikeType()));
       }
       asm.emitPOP_Reg(T0); // T0 is object reference
+
+      // Velodrome: Make a backup of the object reference
+      if (Velodrome.insertPostBarriers()) {
+        is64BitLoad = true;
+      }
+
       if (VM.BuildFor32Addr) {
         // NB this is a 64bit copy from memory to the stack so implement
         // as a slightly optimized Intel memory copy using the FPU
@@ -2464,6 +2954,16 @@ public abstract class BaselineCompilerIm
         asm.emitPUSH_RegDisp(T0, fieldOffset); // place value on stack
       }
     }
+
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      GPR reg = S0; // Handles most cases
+      if (field.isReferenceType() || is64BitLoad) { // The register containing object reference is changed
+        reg = T0;
+      }
+      VelodromeBaselineInstr.insertPostBarrierForResolvedGetfield(method, biStart, asm, field, reg);
+    }
+
   }
 
   @Override
@@ -2471,6 +2971,25 @@ public abstract class BaselineCompilerIm
     Barriers.compileModifyCheck(asm, fieldRef.getNumberOfStackSlots() * WORDSIZE);
     TypeReference fieldType = fieldRef.getFieldContentsType();
     emitDynamicLinkingSequence(asm, T0, fieldRef, true);
+
+		// Velodrome: Take a backup of the object reference
+    if (Velodrome.insertPostBarriers() && OctetBaselineInstr.shouldInstrument(method, biStart)) {
+      // Test whether we would ever require copying 3 or more stack slots
+      if (VM.VerifyAssertions) { VM._assert(fieldRef.getNumberOfStackSlots() <= 2); }
+      asm.emitPOP_Reg(S0); // S0 now has the value to be stored (first word)
+      if (fieldRef.getNumberOfStackSlots() == 2) {
+        asm.emitPOP_Reg(S1); // S1 now has the second word to be stored
+      }
+      asm.emitPUSH_RegDisp(SP, NO_SLOT); // Duplicate the object reference
+      if (fieldRef.getNumberOfStackSlots() == 2) {
+        asm.emitPUSH_Reg(S1); // Now copy the value back the second word on to the stack
+      }
+      asm.emitPUSH_Reg(S0); // Now copy the value (first word) back on to the stack
+    }
+
+    // Octet: insert barrier
+    octetBaselineInstr.insertFieldBarrierUnresolved(method, biStart, false, NO_SLOT.plus(fieldRef.getNumberOfStackSlots() * WORDSIZE), T0, fieldRef, asm);
+
     if (fieldType.isReferenceType()) {
       // 32/64bit reference store
       if (NEEDS_OBJECT_PUTFIELD_BARRIER) {
@@ -2557,6 +3076,12 @@ public abstract class BaselineCompilerIm
     }
     // The field may be volatile.
     asm.emitMFENCE();
+
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      VelodromeBaselineInstr.insertPostBarrierForUnresolvedPutfield(method, biStart, asm, fieldRef);
+    }
+    
   }
 
   @Override
@@ -2565,6 +3090,25 @@ public abstract class BaselineCompilerIm
     RVMField field = fieldRef.peekResolvedField();
     TypeReference fieldType = fieldRef.getFieldContentsType();
     Offset fieldOffset = field.getOffset();
+
+    // Velodrome: Take a backup of the object reference
+    if (Velodrome.insertPostBarriers() && OctetBaselineInstr.shouldInstrument(method, biStart) && !field.isFinal()) {
+      // Test whether we would ever require copying 3 or more stack slots
+      if (VM.VerifyAssertions) { VM._assert(fieldRef.getNumberOfStackSlots() <= 2); }
+      asm.emitPOP_Reg(T0); // T0 now has the value to be stored (first word)
+      if (fieldRef.getNumberOfStackSlots() == 2) {
+        asm.emitPOP_Reg(T1); // T1 now has the second word to be stored
+      }
+      asm.emitPUSH_RegDisp(SP, NO_SLOT); // Duplicate the object reference
+      if (fieldRef.getNumberOfStackSlots() == 2) {
+        asm.emitPUSH_Reg(T1); // Now copy the value back the second word on to the stack
+      }
+      asm.emitPUSH_Reg(T0); // Now copy the value (first word) back on to the stack
+    }
+        
+    // Octet: insert barrier
+    octetBaselineInstr.insertFieldBarrierResolved(method, biStart, false, NO_SLOT.plus(fieldRef.getNumberOfStackSlots() * WORDSIZE), field, asm);
+
     if (field.isReferenceType()) {
       // 32/64bit reference store
       if (NEEDS_OBJECT_PUTFIELD_BARRIER && !field.isUntraced()) {
@@ -2650,15 +3194,24 @@ public abstract class BaselineCompilerIm
     if (field.isVolatile()) {
       asm.emitMFENCE();
     }
+    
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      VelodromeBaselineInstr.insertPostBarrierForResolvedPutfield(method, biStart, asm, field);
+    }
+
   }
 
   /*
    * method invocation
    */
 
+  // Octet: Static cloning: In various invoke cases, support multiple resolved methods for every method reference.
+
+  // Velodrome: Context: Added a pre-computed context
   @Override
-  protected final void emit_unresolved_invokevirtual(MethodReference methodRef) {
-    emitDynamicLinkingSequence(asm, T0, methodRef, true);            // T0 has offset of method
+  protected final void emit_unresolved_invokevirtual(MethodReference methodRef, int context) {
+    emitDynamicLinkingSequence(asm, T0, methodRef, true, /*method.getStaticContext()*/ context);            // T0 has offset of method
     int methodRefparameterWords = methodRef.getParameterWords() + 1; // +1 for "this" parameter
     Offset objectOffset =
       Offset.fromIntZeroExtend(methodRefparameterWords << LG_WORDSIZE).minus(WORDSIZE); // object offset into stack
@@ -2670,10 +3223,11 @@ public abstract class BaselineCompilerIm
     genResultRegisterUnload(methodRef);                              // push return value, if any
   }
 
+  // Velodrome: Context: Added a pre-computed context
   @Override
-  protected final void emit_resolved_invokevirtual(MethodReference methodRef) {
+  protected final void emit_resolved_invokevirtual(MethodReference methodRef, int context) {
     int methodRefparameterWords = methodRef.getParameterWords() + 1; // +1 for "this" parameter
-    Offset methodRefOffset = methodRef.peekResolvedMethod().getOffset();
+    Offset methodRefOffset = methodRef.peekResolvedMethod(context).getOffset();
     Offset objectOffset =
       Offset.fromIntZeroExtend(methodRefparameterWords << LG_WORDSIZE).minus(WORDSIZE); // object offset into stack
     stackMoveHelper(T1, objectOffset);                               // T1 has "this" parameter
@@ -2704,9 +3258,10 @@ public abstract class BaselineCompilerIm
     }
   }
 
+  // Velodrome: Context: Added a pre-computed context
   @Override
-  protected final void emit_unresolved_invokespecial(MethodReference methodRef) {
-    emitDynamicLinkingSequence(asm, S0, methodRef, true);
+  protected final void emit_unresolved_invokespecial(MethodReference methodRef, int context) {
+    emitDynamicLinkingSequence(asm, S0, methodRef, true, /*method.getStaticContext()*/ context);
     genParameterRegisterLoad(methodRef, true);
     asm.emitCALL_RegDisp(S0, Magic.getTocPointer().toWord().toOffset());
     genResultRegisterUnload(methodRef);
@@ -2714,15 +3269,16 @@ public abstract class BaselineCompilerIm
 
   @Override
   protected final void emit_unresolved_invokestatic(MethodReference methodRef) {
-    emitDynamicLinkingSequence(asm, S0, methodRef, true);
+    emitDynamicLinkingSequence(asm, S0, methodRef, true, method.getStaticContext());
     genParameterRegisterLoad(methodRef, false);
     asm.emitCALL_RegDisp(S0, Magic.getTocPointer().toWord().toOffset());
     genResultRegisterUnload(methodRef);
   }
 
+  // Velodrome: Context: Added a pre-computed context
   @Override
-  protected final void emit_resolved_invokestatic(MethodReference methodRef) {
-    Offset methodOffset = methodRef.peekResolvedMethod().getOffset();
+  protected final void emit_resolved_invokestatic(MethodReference methodRef, int context) {
+    Offset methodOffset = methodRef.peekResolvedMethod(context).getOffset();
     genParameterRegisterLoad(methodRef, false);
     asm.emitCALL_Abs(Magic.getTocPointer().plus(methodOffset));
     genResultRegisterUnload(methodRef);
@@ -2733,7 +3289,7 @@ public abstract class BaselineCompilerIm
     final int count = methodRef.getParameterWords() + 1; // +1 for "this" parameter
 
     RVMMethod resolvedMethod = null;
-    resolvedMethod = methodRef.peekInterfaceMethod();
+    resolvedMethod = methodRef.peekInterfaceMethod(method.getStaticContext());
 
     // (1) Emit dynamic type checking sequence if required to do so inline.
     if (VM.BuildForIMTInterfaceInvocation) {
@@ -2750,7 +3306,8 @@ public abstract class BaselineCompilerIm
           stackMoveHelper(T1, Offset.fromIntZeroExtend((count - 1) << LG_WORDSIZE));
           asm.emitPUSH_Imm(methodRef.getId()); // push dict id of target
           asm.emitPUSH_Reg(T1);                // push "this"
-          genParameterRegisterLoad(asm, 2);    // pass 2 parameter word
+          asm.emitPUSH_Imm(method.getStaticContext());
+          genParameterRegisterLoad(asm, 3);    // pass 3 parameter word
           // check that "this" class implements the interface
           asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.unresolvedInvokeinterfaceImplementsTestMethod.getOffset()));
         } else {
@@ -2795,7 +3352,14 @@ public abstract class BaselineCompilerIm
 
     // (2) Emit interface invocation sequence.
     if (VM.BuildForIMTInterfaceInvocation) {
-      InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(methodRef);
+
+      // Velodrome: Context: Interface invocation for non-application methods can only have VM_CONTEXT
+      int context = method.getStaticContext();
+      if (!Context.isApplicationPrefix(methodRef.getType())) {
+        context = Context.VM_CONTEXT;
+      }
+
+      InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(methodRef, context);
 
       // squirrel away signature ID
       ThreadLocalState.emitMoveImmToField(asm, ArchEntrypoints.hiddenSignatureIdField.getOffset(), sig.getId());
@@ -2817,7 +3381,8 @@ public abstract class BaselineCompilerIm
         itableIndex =
           InterfaceInvocation.getITableIndex(resolvedMethod.getDeclaringClass(),
                                              methodRef.getName(),
-                                             methodRef.getDescriptor());
+                                             methodRef.getDescriptor(),
+                                             resolvedMethod.getResolvedContext());
       }
       if (itableIndex == -1) {
         // itable index is not known at compile-time.
@@ -2831,7 +3396,8 @@ public abstract class BaselineCompilerIm
           asm.emitPUSH_RegDisp(SP, Offset.fromIntZeroExtend((count - 1) << LG_WORDSIZE));
         }
         asm.emitPUSH_Imm(methodRefId);             // id of method to call
-        genParameterRegisterLoad(asm, 2);          // pass 2 parameter words
+        asm.emitPUSH_Imm(method.getStaticContext());
+        genParameterRegisterLoad(asm, 3);          // pass 3 parameter words
         // invokeinterface(obj, id) returns address to call
         asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.invokeInterfaceMethod.getOffset()));
         if (VM.BuildFor32Addr) {
@@ -3226,6 +3792,14 @@ public abstract class BaselineCompilerIm
 
   @Override
   protected final void emit_monitorenter() {
+    
+    // Velodrome: Instrumentation at the beginning of transaction/synchronized block    
+    // We can have a configuration where both methods and sync blocks are enabled
+    if (Octet.shouldInstrumentMethod(method) && Velodrome.syncBlocksAsTransactions()) {
+      if (VM.VerifyAssertions) { VM._assert(NOT_REACHED); }
+      VelodromeBaselineInstr.insertInstrumentationAtTransactionBegin(method, biStart, asm, octetBaselineInstr, method.getId());
+    }   
+    
     if (VM.BuildFor32Addr) {
       asm.emitMOV_Reg_RegInd(T0, SP);      // T0 is object reference
     } else {
@@ -3233,13 +3807,31 @@ public abstract class BaselineCompilerIm
     }
     genNullCheck(asm, T0);
     genParameterRegisterLoad(asm, 1);      // pass 1 parameter word
-    asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.lockMethod.getOffset()));
+    // Velodrome: Decide which lock method to use
+    if (Octet.shouldInstrumentMethod(method)) {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.lockMethodWithInstrumentation.getOffset()));
+    } else {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.lockMethodWithoutInstrumentation.getOffset()));
+    }
   }
 
   @Override
   protected final void emit_monitorexit() {
     genParameterRegisterLoad(asm, 1);          // pass 1 parameter word
-    asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.unlockMethod.getOffset()));
+    // Velodrome: Decide which unlock method to use
+    if (Octet.shouldInstrumentMethod(method)) {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.unlockMethodWithInstrumentation.getOffset()));
+    } else {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.unlockMethodWithoutInstrumentation.getOffset()));
+    }
+
+    // Velodrome: Instrumentation at the end of transaction/synchronized block  
+    // We can have a configuration where both methods and sync blocks are enabled
+    if (Octet.shouldInstrumentMethod(method) && Velodrome.syncBlocksAsTransactions()) {      
+      if (VM.VerifyAssertions) { VM._assert(NOT_REACHED); }
+      VelodromeBaselineInstr.insertInstrumentationAtTransactionEnd(method, biStart, asm, octetBaselineInstr, method.getId());      
+    }
+    
   }
 
   //----------------//
@@ -3348,7 +3940,8 @@ public abstract class BaselineCompilerIm
       /*
        * generate stacklimit check
        */
-      if (isInterruptible) {
+      // Velodrome: Stack overflow: Insert stack overflow checks for all uninterruptible methods if assertions are turned on
+      if (VM.VerifyAssertions || isInterruptible) { 
         // S0<-limit
         if (VM.BuildFor32Addr) {
           asm.emitCMP_Reg_RegDisp(SP, TR, Entrypoints.stackLimitField.getOffset());
@@ -3383,6 +3976,25 @@ public abstract class BaselineCompilerIm
       if (method.isSynchronized()) genMonitorEnter();
 
       genThreadSwitchTest(RVMThread.PROLOGUE);
+
+      // Octet: Static cloning: Debugging for supporting multiple resolved methods for every method reference.
+      if (Context.DEBUG && Context.isLibraryPrefix(method.getDeclaringClass().getTypeRef())) {
+        //genParameterRegisterLoad(asm, 1);
+        asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.checkLibraryContextMethod.getOffset()));
+      }
+
+      // Velodrome: Instrumentation at the beginning of a method/transaction
+      // Instrument only if the static context of the current method is TRANS, while the resolved context is NON_TRANS
+      if (Octet.shouldInstrumentMethod(method) && (Velodrome.methodsAsTransactions() || method.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+        if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+          VelodromeBaselineInstr.insertInstrumentationAtTransactionBegin(method, biStart, asm, octetBaselineInstr, method.getId());
+        }
+        // Insert debug method at all prologs
+        if (Velodrome.checkMethodContextAtProlog() && Context.isApplicationPrefix(method.getDeclaringClass().getTypeRef())) {
+          asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.velodromeCheckMethodContextAtPrologMethod.getOffset()));
+        }
+      }
+      
     }
   }
 
@@ -3394,7 +4006,8 @@ public abstract class BaselineCompilerIm
 
     if (VM.VerifyAssertions) VM._assert(method.isForOsrSpecialization());
 
-    if (isInterruptible) {
+    // Velodrome: Stack overflow: Insert stack overflow checks for all uninterruptible methods if assertions are turned on
+    if (VM.VerifyAssertions || isInterruptible) { 
       // S0<-limit
       ThreadLocalState.emitMoveFieldToReg(asm, S0, Entrypoints.stackLimitField.getOffset());
       if (VM.BuildFor32Addr) {
@@ -3474,7 +4087,12 @@ public abstract class BaselineCompilerIm
     }
     // pass 1 parameter
     genParameterRegisterLoad(asm, 1);
-    asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.lockMethod.getOffset()));
+    // Velodrome: Decide which lock method to use
+    if (Octet.shouldInstrumentMethod(method)) {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.lockMethodWithInstrumentation.getOffset()));
+    } else {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.lockMethodWithoutInstrumentation.getOffset()));
+    }
     // after this instruction, the method has the monitor
     lockOffset = asm.getMachineCodeIndex();
   }
@@ -3491,7 +4109,12 @@ public abstract class BaselineCompilerIm
       asm.emitPUSH_RegDisp(ESP, localOffset(0));                    // push "this" object
     }
     genParameterRegisterLoad(asm, 1); // pass 1 parameter
-    asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.unlockMethod.getOffset()));
+    // Velodrome: Decide which unlock method to use
+    if (Octet.shouldInstrumentMethod(method)) {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.unlockMethodWithInstrumentation.getOffset()));
+    } else {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.unlockMethodWithoutInstrumentation.getOffset()));
+    }
   }
 
   /**
@@ -4160,6 +4783,12 @@ public abstract class BaselineCompilerIm
     return offset.plus(offsetToFrameHead);
   }
 
+  /** Octet: Static cloning: Added this helper method to help with fields, which don't need a context. */
+  static void emitDynamicLinkingSequence(Assembler asm, GPR reg, MemberReference ref, boolean couldBeZero) {
+    if (VM.VerifyAssertions) { VM._assert(ref.isFieldReference()); }
+    emitDynamicLinkingSequence(asm, reg, ref, couldBeZero, Context.VM_CONTEXT);
+  }
+
   /**
    * Emit dynamic linking sequence placing the offset of the given member in reg
    * @param asm assembler to generate code into
@@ -4167,10 +4796,11 @@ public abstract class BaselineCompilerIm
    * @param ref method reference to be resolved
    * @param couldBeZero could the value in the offsets table require resolving
    */
-  static void emitDynamicLinkingSequence(Assembler asm, GPR reg, MemberReference ref, boolean couldBeZero) {
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+  static void emitDynamicLinkingSequence(Assembler asm, GPR reg, MemberReference ref, boolean couldBeZero, int context) {
     int memberId = ref.getId();
     Offset memberOffset = Offset.fromIntZeroExtend(memberId << 2);
-    Offset tableOffset = Entrypoints.memberOffsetsField.getOffset();
+    Offset tableOffset = Entrypoints.memberOffsetsFields[context].getOffset();
     if (couldBeZero) {
       int retryLabel = asm.getMachineCodeIndex();            // branch here after dynamic class loading
       if (VM.BuildFor32Addr) {
@@ -4186,7 +4816,8 @@ public abstract class BaselineCompilerIm
       }
       ForwardReference fr = asm.forwardJcc(Assembler.NE);       // if so, skip call instructions
       asm.emitPUSH_Imm(memberId);                            // pass member's dictId
-      genParameterRegisterLoad(asm, 1);                           // pass 1 parameter word
+      asm.emitPUSH_Imm(context);
+      genParameterRegisterLoad(asm, 2);                           // pass 2 parameter word
       Offset resolverOffset = Entrypoints.resolveMemberMethod.getOffset();
       asm.emitCALL_Abs(Magic.getTocPointer().plus(resolverOffset)); // does class loading as sideffect
       asm.emitJMP_Imm(retryLabel);                           // reload reg with valid value
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java	2014-04-03 17:43:42.446668654 -0400
@@ -14,14 +14,19 @@ package org.jikesrvm.compilers.baseline.
 
 import org.jikesrvm.ArchitectureSpecific;
 import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.compilers.baseline.BaselineCompiledMethod;
 import org.jikesrvm.compilers.common.CompiledMethod;
 import org.jikesrvm.ia32.BaselineConstants;
 import org.jikesrvm.objectmodel.ObjectModel;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.ExceptionDeliverer;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.velodrome.TransactionalHBGraph;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.Unpreemptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
@@ -95,7 +100,12 @@ public abstract class BaselineExceptionD
                   0)) - BYTES_IN_ADDRESS).loadAddress());
         }
         if (ObjectModel.holdsLock(lock, RVMThread.getCurrentThread())) {
-          ObjectModel.genericUnlock(lock);
+          // Velodrome: Decide which lock method to use
+          if (Octet.shouldInstrumentMethod(method)) {
+            ObjectModel.genericUnlock(lock);
+          } else {
+            ObjectModel.genericUnlockWithoutInstrumentation(lock);
+          }
         }
       }
     }
@@ -108,7 +118,19 @@ public abstract class BaselineExceptionD
     }
 
     registers.unwindStackFrame();
+
+    // Velodrome: Decrement the transaction depth for the current thread
+    RVMMethod rMethod = compiledMethod.getMethod();
+    if (!rMethod.isNative()) {
+      if (Octet.shouldInstrumentMethod(rMethod) && (Velodrome.methodsAsTransactions() || rMethod.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+        if (Context.isTRANSContext(rMethod.getStaticContext()) && Context.isNONTRANSContext(rMethod.getResolvedContext())) {
+          TransactionalHBGraph.handleExceptionDuringStackUnwinding(rMethod);
+        }
+      }
+    }
+
   }
+
 }
 
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java	2014-04-03 17:43:42.446668654 -0400
@@ -55,6 +55,7 @@ import org.jikesrvm.ArchitectureSpecific
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.ArchitectureSpecific.Registers;
 import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.MethodReference;
 import org.jikesrvm.classloader.RVMArray;
 import org.jikesrvm.classloader.RVMMethod;
@@ -181,8 +182,9 @@ final class BaselineMagic {
       if ((dc != JavaHeader.class) &&
           (dc != ObjectModel.class)
       ){
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
         if (checkMR.needsDynamicLink(cm)) {
-          BaselineCompilerImpl.emitDynamicLinkingSequence(asm, S0, checkMR, true);
+          BaselineCompilerImpl.emitDynamicLinkingSequence(asm, S0, checkMR, true, Context.VM_CONTEXT);
           if (offset.NE(NO_SLOT)) {
             asm.emitMOV_Reg_RegDisp(T0, SP, offset);
           } else {
@@ -197,7 +199,7 @@ final class BaselineMagic {
             asm.emitMOV_Reg_RegInd(T0, SP);
           }
           asm.emitPUSH_Reg(T0);
-          asm.emitCALL_Abs(Magic.getTocPointer().plus(checkMR.peekResolvedMethod().getOffset()));
+          asm.emitCALL_Abs(Magic.getTocPointer().plus(checkMR.peekResolvedMethod(Context.VM_CONTEXT).getOffset()));
         }
       }
       generator.generateMagic(asm, m, cm, sd);
@@ -226,8 +228,9 @@ final class BaselineMagic {
       if ((dc != JavaHeader.class) &&
           (dc != ObjectModel.class)
       ){
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
         if (checkMR.needsDynamicLink(cm)) {
-          BaselineCompilerImpl.emitDynamicLinkingSequence(asm, S0, checkMR, true);
+          BaselineCompilerImpl.emitDynamicLinkingSequence(asm, S0, checkMR, true, Context.VM_CONTEXT);
           if (offset.NE(NO_SLOT)) {
             asm.emitMOV_Reg_RegDisp(T0, SP, offset);
           } else {
@@ -242,7 +245,7 @@ final class BaselineMagic {
             asm.emitMOV_Reg_RegInd(T0, SP);
           }
           asm.emitPUSH_Reg(T0);
-          asm.emitCALL_Abs(Magic.getTocPointer().plus(checkMR.peekResolvedMethod().getOffset()));
+          asm.emitCALL_Abs(Magic.getTocPointer().plus(checkMR.peekResolvedMethod(Context.VM_CONTEXT).getOffset()));
         }
       }
     }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/OctetBaselineInstr.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/OctetBaselineInstr.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/OctetBaselineInstr.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/OctetBaselineInstr.java	2014-04-03 17:43:42.445668651 -0400
@@ -0,0 +1,185 @@
+package org.jikesrvm.compilers.baseline.ia32;
+
+import org.jikesrvm.ArchitectureSpecific.Assembler;
+import org.jikesrvm.ArchitectureSpecific.BaselineConstants;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.octet.InstrDecisions;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.Site;
+import org.jikesrvm.runtime.Magic;
+import org.vmmagic.unboxed.Offset;
+
+public class OctetBaselineInstr implements BaselineConstants {
+
+  /** Barrier for resolved static fields */
+  boolean insertStaticBarrierResolved(NormalMethod method, int biStart, boolean isRead, RVMField field, Assembler asm) {
+    if (shouldInstrument(method, biStart) && InstrDecisions.staticFieldHasMetadata(field)) {
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, true, true, false, isSpecializedMethod(method));
+      // start and finish call      
+      int params = startStaticBarrierResolvedCall(field, asm);
+      finishCall(method, biStart, true, field.getMemberRef().asFieldReference(), null, null, barrierMethod, params, asm);
+      return true;
+    }
+    return false;
+  }
+
+  int startStaticBarrierResolvedCall(RVMField field, Assembler asm) {
+    // param: metadata offset
+    asm.emitPUSH_Imm(field.getMetadataOffset().toInt()); // push field metadata offset
+    // param: field info
+    int fieldInfo = InstrDecisions.getFieldInfo(field);
+    asm.emitPUSH_Imm(fieldInfo);
+    return 2;
+  }
+
+  /** Barrier for unresolved static fields */
+  boolean insertStaticBarrierUnresolved(NormalMethod method, int biStart, boolean isRead, GPR offsetReg, FieldReference fieldRef, Assembler asm) {
+    if (shouldInstrument(method, biStart) && InstrDecisions.staticFieldMightHaveMetadata(fieldRef)) {
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, false, true, false, isSpecializedMethod(method));
+      // save offset value on stack
+      asm.emitPUSH_Reg(offsetReg); // save value on the stack; also update where we'll find the reference
+      // start and finish call      
+      int params = startStaticBarrierUnresolvedCall(offsetReg, fieldRef, asm);
+      finishCall(method, biStart, true, fieldRef, null, offsetReg, barrierMethod, params, asm);
+      // restore offset value from stack
+      asm.emitPOP_Reg(offsetReg);
+      return true;
+    }
+    return false;
+  }
+
+  int startStaticBarrierUnresolvedCall(GPR offsetReg, FieldReference fieldRef, Assembler asm) {
+    // param: field ID (needed even if field info disabled, since it's needed to get the metadata offset)
+    asm.emitPUSH_Imm(fieldRef.getId());
+    return 1;
+  }
+  
+  /** Barrier for resolved non-static fields */
+  boolean insertFieldBarrierResolved(NormalMethod method, int biStart, boolean isRead, Offset numSlots, RVMField field, Assembler asm) {
+    if (shouldInstrument(method, biStart) &&
+        InstrDecisions.objectOrFieldHasMetadata(field) &&
+        Octet.shouldInstrumentFieldAccess(field.getMemberRef().asFieldReference())) {
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, true, false, false, isSpecializedMethod(method));
+      // start and finish call      
+      int params = startFieldBarrierResolvedCall(numSlots, field, asm);
+      finishCall(method, biStart, true, field.getMemberRef().asFieldReference(), null, null, barrierMethod, params, asm);
+      return true;
+    }
+    return false;
+  }
+
+  int startFieldBarrierResolvedCall(Offset numSlots, RVMField field, Assembler asm) {
+    // param: object reference
+    asm.emitPUSH_RegDisp(SP, numSlots);
+    // param: field info
+    int fieldInfo = InstrDecisions.getFieldInfo(field);
+    asm.emitPUSH_Imm(fieldInfo);
+    return 2;
+  }
+  
+  /** Barrier for unresolved non-static fields */
+  boolean insertFieldBarrierUnresolved(NormalMethod method, int biStart, boolean isRead, Offset numSlots, GPR offsetReg, FieldReference fieldRef, Assembler asm) {
+    if (shouldInstrument(method, biStart) &&
+        InstrDecisions.objectOrFieldMightHaveMetadata(fieldRef) &&
+        Octet.shouldInstrumentFieldAccess(fieldRef)) {
+      // we can just send isResolved==true because we can get the offset out of the register "offsetReg"
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, true, false, false, isSpecializedMethod(method));
+      // save offset value on stack
+      asm.emitPUSH_Reg(offsetReg);
+      // start and finish call      
+      int params = startFieldBarrierUnresolvedCall(numSlots, offsetReg, fieldRef, asm);
+      finishCall(method, biStart, true, fieldRef, null, offsetReg, barrierMethod, params, asm);
+      // restore offset value from stack
+      asm.emitPOP_Reg(offsetReg);
+      return true;
+    }
+    return false;
+  }
+
+  int startFieldBarrierUnresolvedCall(Offset numSlots, GPR offsetReg, FieldReference fieldRef, Assembler asm) {
+    // param: object reference -- add a slot because of the push above
+    asm.emitPUSH_RegDisp(SP, numSlots.plus(WORDSIZE));
+    // param: field info (either field ID or field offset)
+    if (InstrDecisions.passFieldInfo()) {
+      if (InstrDecisions.useFieldOffset()) {
+        asm.emitPUSH_Reg(offsetReg); // the offset is in a register
+      } else {
+        asm.emitPUSH_Imm(fieldRef.getId());
+      }
+    } else {
+      asm.emitPUSH_Imm(0);
+    }
+    return 2;
+  }
+  
+  /** Barrier for arrays */
+  boolean insertArrayBarrier(NormalMethod method, int biStart, boolean isRead, Offset numSlots, TypeReference type, Assembler asm) {
+    if (shouldInstrument(method, biStart)) {
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, false, true, false, false, isSpecializedMethod(method));
+      // start and finish call
+      int params = startArrayBarrierCall(numSlots, asm);
+      finishCall(method, biStart, false, null, type, null, barrierMethod, params, asm);
+      return true;
+    }
+    return false;
+  }
+
+  int startArrayBarrierCall(Offset numSlots, Assembler asm) {
+    // param: object reference
+    asm.emitPUSH_RegDisp(SP, numSlots);
+    // param: index
+    if (InstrDecisions.passFieldInfo()) {
+      asm.emitPUSH_RegDisp(SP, numSlots); // push index (which is now one lower)
+    } else {
+      asm.emitPUSH_Imm(0);
+    }
+    return 2;
+  }
+  
+  /** Helper method for passing final parameters and actually making the call */
+  void finishCall(NormalMethod method, int biStart, boolean isField, FieldReference fieldRef, TypeReference type, GPR offsetReg, NormalMethod barrierMethod, int params, Assembler asm) {
+    // pass site info
+    params += passSite(method, biStart, asm);
+    // pass extra info specified by a client analysis
+    params += passExtra(method, biStart, isField, fieldRef, type, offsetReg, asm);
+    // make the call
+    BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+    asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+  }
+  
+  /** A client analysis can override this to do nothing. */
+  static int passSite(NormalMethod method, int biStart, Assembler asm) {
+    int siteID = InstrDecisions.passSite() ? Site.getSite(method, biStart, null) : 0;
+    asm.emitPUSH_Imm(siteID);
+    return 1;
+  }
+  
+  /** A client analysis can override this to pass extra parameters. */
+  int passExtra(NormalMethod method, int biStart, boolean isField, FieldReference fieldRef, TypeReference type, GPR offsetReg, Assembler asm) {
+    return 0;
+  }
+
+  /** Helper method */
+  static boolean shouldInstrument(NormalMethod method, int bci) {
+    return shouldInstrument(method) && (!Octet.getConfig().enableStaticRaceDetection() || isLibraries(method) || Octet.shouldInstrumentCheckRace(method, bci));
+  }
+  
+  /** Helper to check if the method is a Library method */
+  static boolean isLibraries(NormalMethod method) {    
+    return Context.isLibraryPrefix(method.getDeclaringClass().getTypeRef());
+  }
+  
+  /** Helper method */
+  static boolean shouldInstrument(NormalMethod method) {
+    return Octet.getConfig().insertBarriers() && Octet.getConfig().instrumentBaselineCompiler() && Octet.shouldInstrumentMethod(method);
+  }
+  
+  boolean isSpecializedMethod(NormalMethod method) {
+    return Octet.getClientAnalysis().isSpecializedMethod(method);
+  }
+    
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/VelodromeBaselineInstr.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/VelodromeBaselineInstr.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/ia32/VelodromeBaselineInstr.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/ia32/VelodromeBaselineInstr.java	2014-04-03 17:43:42.448668660 -0400
@@ -0,0 +1,325 @@
+package org.jikesrvm.compilers.baseline.ia32;
+
+import org.jikesrvm.ArchitectureSpecific.Assembler;
+import org.jikesrvm.ArchitectureSpecific.BaselineConstants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.octet.InstrDecisions;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.velodrome.Velodrome;
+import org.jikesrvm.velodrome.VelodromeInstrDecisions;
+import org.vmmagic.unboxed.Offset;
+
+public final class VelodromeBaselineInstr extends OctetBaselineInstr implements BaselineConstants {
+  
+  /** Instrument the beginning of a transaction. */
+  static final void insertInstrumentationAtTransactionBegin(NormalMethod method, int biStart, Assembler asm, 
+      OctetBaselineInstr octetBaselineInstr, int methodID) {    
+    int params = 0;
+    params += passSite(method, biStart, asm); // Pass site info
+    // Parameter: Method id
+    asm.emitPUSH_Imm(methodID);
+    params += 1; // For method id
+    // make the call
+    BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+    asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.velodromeStartTransactionMethod.getOffset()));
+  }
+  
+  /** Instrument the end of a transaction. */
+  static final void insertInstrumentationAtTransactionEnd(NormalMethod method, int biStart, Assembler asm, 
+      OctetBaselineInstr octetBaselineInstr, int methodID) {
+    int params = 0; 
+    params += passSite(method, biStart, asm); // Pass site info
+    // Parameter: Method id
+    asm.emitPUSH_Imm(methodID);
+    params += 1; // For method id
+    // make the call
+    BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+    asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.velodromeEndTransactionMethod.getOffset()));
+  }     
+  
+  /** <ol> 
+   * <li> Pass Velodrome metadata offset for all. 
+   * <li> Pass the element size for arrays. 
+   * </ol>*/
+  @Override
+  int passExtra(NormalMethod method, int biStart, boolean isField, FieldReference fieldRef, TypeReference type, GPR offsetReg, Assembler asm) {
+    // param: Velodrome metadata offset, note that zero is a valid offset
+    int writeOffset = Velodrome.UNITIALIZED_OFFSET;
+    int readOffset = Velodrome.UNITIALIZED_OFFSET;
+
+    // fieldRef is null for arrays
+    if (Velodrome.addPerFieldVelodromeMetadata()) {
+      if (fieldRef != null && fieldRef.getResolvedField() != null) {
+        // Possible for fields accessed to have no Velodrome metadata offset 
+        //if (VM.VerifyAssertions) { VM._assert(fieldRef.getResolvedField().hasVelodromeMetadataOffset()); }
+        if (fieldRef.getResolvedField().hasVelodromeMetadataOffset()) {
+          writeOffset = fieldRef.getResolvedField().getWriteMetadataOffset().toInt();
+          readOffset = fieldRef.getResolvedField().getReadMetadataOffset().toInt();
+        }
+      }
+    }
+    asm.emitPUSH_Imm(writeOffset);
+    asm.emitPUSH_Imm(readOffset);
+    int param = 2;  // We always pass the metadata offsets
+    
+    // We pass the array element size from here, so that it helps in computing array index offset
+    if (!isField) { // Array type
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.instrumentArrays()); }
+      if (VM.VerifyAssertions) { VM._assert(type != null && fieldRef == null); }
+      asm.emitPUSH_Imm(type.getMemoryBytes()); // Can be 1,2,4
+      param += 1;
+    }
+    return param;
+  }
+  
+  /** Barrier for resolved static fields */
+  @Override
+  boolean insertStaticBarrierResolved(NormalMethod method, int biStart, boolean isRead, RVMField field, Assembler asm) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.staticFieldHasVelodromeMetadata(field)) {
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, true, true, false, isSpecializedMethod(method));
+      // Start and finish call      
+      int params = startStaticBarrierResolvedCall(field, asm);
+      finishCall(method, biStart, true, field.getMemberRef().asFieldReference(), null, null, barrierMethod, params, asm);
+      return true;
+    }
+    return false;
+  }
+  
+  @Override
+  int startStaticBarrierResolvedCall(RVMField field, Assembler asm) {
+    // param: field info
+    int fieldOffset = InstrDecisions.getFieldInfo(field);
+    asm.emitPUSH_Imm(fieldOffset);
+    return 1;
+  }
+  
+  /** Barrier for unresolved static fields */
+  @Override
+  boolean insertStaticBarrierUnresolved(NormalMethod method, int biStart, boolean isRead, GPR offsetReg, FieldReference fieldRef, Assembler asm) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.staticFieldMightHaveVelodromeMetadata(fieldRef)) {
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, false, true, false, isSpecializedMethod(method));
+      // save offset value on stack
+      asm.emitPUSH_Reg(offsetReg); // save value on the stack; also update where we'll find the reference
+      // start and finish call      
+      int params = startStaticBarrierUnresolvedCall(offsetReg, fieldRef, asm);
+      finishCall(method, biStart, true, fieldRef, null, offsetReg, barrierMethod, params, asm);
+      // restore offset value from stack
+      asm.emitPOP_Reg(offsetReg);
+      return true;
+    }
+    return false;
+  }
+  
+  /** Barrier for resolved non-static fields */
+  @Override
+  boolean insertFieldBarrierResolved(NormalMethod method, int biStart, boolean isRead, Offset numSlots, RVMField field, Assembler asm) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.objectOrFieldHasVelodromeMetadata(field)) {
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, true, false, false, isSpecializedMethod(method));
+      // start and finish call      
+      int params = startFieldBarrierResolvedCall(numSlots, field, asm);
+      finishCall(method, biStart, true, field.getMemberRef().asFieldReference(), null, null, barrierMethod, params, asm);
+      return true;
+    }
+    return false;
+  }
+  
+  /** Barrier for unresolved non-static fields */
+  @Override
+  boolean insertFieldBarrierUnresolved(NormalMethod method, int biStart, boolean isRead, Offset numSlots, GPR offsetReg, FieldReference fieldRef, Assembler asm) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.objectOrFieldMightHaveVelodromeMetadata(fieldRef)) {
+      // we can just send isResolved==true because we can get the offset out of the register "offsetReg"
+      // But we are instead passing false, so that we can extract the Velodrome metadata offset in the barriers
+      NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(method, isRead, true, false, false, false, isSpecializedMethod(method));
+      // save offset value on stack
+      asm.emitPUSH_Reg(offsetReg);
+      // start and finish call      
+      int params = startFieldBarrierUnresolvedCall(numSlots, offsetReg, fieldRef, asm);
+      finishCall(method, biStart, true, fieldRef, null, offsetReg, barrierMethod, params, asm);
+      // restore offset value from stack
+      asm.emitPOP_Reg(offsetReg);
+      return true;
+    }
+    return false;
+  }
+  
+  // It is important to override this method if we are using unresolved barriers 
+  @Override
+  int startFieldBarrierUnresolvedCall(Offset numSlots, GPR offsetReg, FieldReference fieldRef, Assembler asm) {
+    // param: object reference -- add a slot because of the push above
+    asm.emitPUSH_RegDisp(SP, numSlots.plus(WORDSIZE));
+    // param: field info (either field ID or field offset)
+    if (InstrDecisions.passFieldInfo()) {
+      // We are ignoring the fact that offsets are what the client analysis has requested for, and instead 
+      // we are still passing the field id
+      asm.emitPUSH_Imm(fieldRef.getId());
+    } else {
+      asm.emitPUSH_Imm(0);
+    }
+    return 2;
+  }
+  
+  /****************** Post read/write barriers  *******************/
+  
+  static boolean insertPostBarrierForResolvedGetfield(NormalMethod method, int biStart, Assembler asm, RVMField field, GPR reg) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.objectOrFieldHasVelodromeMetadata(field)) {
+      NormalMethod barrierMethod = Entrypoints.velodromeUnlockMetadataForResolvedFieldMethod;
+      asm.emitPUSH_Reg(reg); // Object reference
+      // Object reference is already expected to be on the stack
+      // param: Velodrome write metadata offset, note that zero is a valid offset
+      int writeOffset = Velodrome.UNITIALIZED_OFFSET;
+      if (field.hasVelodromeMetadataOffset()) {
+        writeOffset = field.getWriteMetadataOffset().toInt();
+      }
+      asm.emitPUSH_Imm(writeOffset);
+      int params = 2;
+      params += passSite(method, biStart, asm); // Pass site info
+      asm.emitPUSH_Imm(1);
+      params += 1;
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+      return true;
+    }
+    return false;
+  }
+  
+  static boolean insertPostBarrierForResolvedPutfield(NormalMethod method, int biStart, Assembler asm, RVMField field) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.objectOrFieldHasVelodromeMetadata(field)) {
+      NormalMethod barrierMethod = Entrypoints.velodromeUnlockMetadataForResolvedFieldMethod;
+      // object reference is already on the stack, see emit_resolved_putfield
+      // param: Velodrome write metadata offset, note that zero is a valid offset
+      int writeOffset = Velodrome.UNITIALIZED_OFFSET;
+      if (field.hasVelodromeMetadataOffset()) {
+        writeOffset = field.getWriteMetadataOffset().toInt();
+      }
+      asm.emitPUSH_Imm(writeOffset);
+      int params = 2;
+      params += passSite(method, biStart, asm); // Pass site info
+      asm.emitPUSH_Imm(0);
+      params += 1;
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+      return true;
+    }
+    return false;
+  }
+  
+  static boolean insertPostBarrierForUnresolvedGetfield(NormalMethod method, int biStart, Assembler asm, 
+      FieldReference fieldRef, GPR reg) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.objectOrFieldMightHaveVelodromeMetadata(fieldRef)) {
+      NormalMethod barrierMethod = Entrypoints.velodromeUnlockMetadataForUnresolvedFieldMethod;
+      asm.emitPUSH_Reg(reg); // Object reference
+      // param: Velodrome metadata offset, note that zero is a valid offset
+      if (InstrDecisions.passFieldInfo()) {
+        // We are ignoring the fact that offsets are what the client analysis has requested for, and instead 
+        // we are still passing the field id
+        asm.emitPUSH_Imm(fieldRef.getId());
+      } else {
+        asm.emitPUSH_Imm(0);
+      }
+      int params = 2;
+      params += passSite(method, biStart, asm); // Pass site info
+      asm.emitPUSH_Imm(1);
+      params += 1;
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+      return true;
+    }
+    return false;
+  }
+  
+  static boolean insertPostBarrierForUnresolvedPutfield(NormalMethod method, int biStart, Assembler asm, FieldReference fieldRef) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.objectOrFieldMightHaveVelodromeMetadata(fieldRef)) {
+      NormalMethod barrierMethod = Entrypoints.velodromeUnlockMetadataForUnresolvedFieldMethod;
+      // object reference is already on the stack, see emit_unresolved_putfield()
+      // param: Velodrome metadata offset, note that zero is a valid offset
+      if (InstrDecisions.passFieldInfo()) {
+        // We are ignoring the fact that offsets are what the client analysis has requested for, and instead 
+        // we are still passing the field id
+        asm.emitPUSH_Imm(fieldRef.getId());
+      } else {
+        asm.emitPUSH_Imm(0);
+      }
+      int params = 2;
+      params += passSite(method, biStart, asm); // Pass site info
+      asm.emitPUSH_Imm(0);
+      params += 1;
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+      return true;
+    }
+    return false;
+  }
+  
+  static boolean insertInstrumentationToUnlockMetadataForStaticUnresolved(NormalMethod method, int biStart, boolean isRead, 
+      FieldReference fieldRef, Assembler asm) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.staticFieldMightHaveVelodromeMetadata(fieldRef)) {
+      NormalMethod barrierMethod = Entrypoints.velodromeUnlockMetadataForStaticUnresolvedMethod;
+      int fieldInfo = fieldRef.getId();
+      asm.emitPUSH_Imm(fieldInfo);
+      int params = 1;
+      params += passSite(method, biStart, asm);
+      if (isRead) {
+        asm.emitPUSH_Imm(1);
+      } else {
+        asm.emitPUSH_Imm(0);
+      }
+      params += 1;
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+      return true;
+    }
+    return false;
+  }
+  
+  static boolean insertInstrumentationToUnlockMetadataForStaticResolved(NormalMethod method, int biStart, boolean isRead, RVMField field,
+      Assembler asm) {
+    if (shouldInstrument(method, biStart) && VelodromeInstrDecisions.staticFieldHasVelodromeMetadata(field)) {
+      NormalMethod barrierMethod = Entrypoints.velodromeUnlockMetadataForStaticResolvedMethod;
+      // param: Velodrome write metadata offset, note that zero is a valid offset
+      int writeOffset = field.getWriteMetadataOffset().toInt();
+      asm.emitPUSH_Imm(writeOffset);
+      int fieldInfo = InstrDecisions.getFieldInfo(field);
+      asm.emitPUSH_Imm(fieldInfo);
+      int params = 2;
+      params += passSite(method, biStart, asm);
+      if (isRead) {
+        asm.emitPUSH_Imm(1);
+      } else {
+        asm.emitPUSH_Imm(0);
+      }
+      params += 1;
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+      return true;
+    }
+    return false;
+  }
+  
+  static boolean insertPostBarrierForArray(NormalMethod method, int biStart, boolean isRead, GPR refReg, GPR idxReg, 
+      TypeReference type, Assembler asm) {
+    if (shouldInstrument(method, biStart)) {
+      NormalMethod barrierMethod = Entrypoints.velodromeArrayPostBarrierMethod;
+      asm.emitPUSH_Reg(refReg); // Object reference
+      asm.emitPUSH_Reg(idxReg); // Array index
+      int params = 2;
+      params += passSite(method, biStart, asm);
+      if (isRead) {
+        asm.emitPUSH_Imm(1);
+      } else {
+        asm.emitPUSH_Imm(0);
+      }
+      params += 1;
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, params);
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(barrierMethod.getOffset()));
+      return true;
+    }
+    return false;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/TemplateCompilerFramework.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/TemplateCompilerFramework.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/baseline/TemplateCompilerFramework.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/baseline/TemplateCompilerFramework.java	2014-04-03 17:43:42.242667983 -0400
@@ -15,24 +15,26 @@ package org.jikesrvm.compilers.baseline;
 import org.jikesrvm.ArchitectureSpecific.Assembler;
 import org.jikesrvm.ArchitectureSpecific.MachineCode;
 import org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants;
-import org.jikesrvm.VM;
 import org.jikesrvm.Services;
 import org.jikesrvm.SizeConstants;
-import org.jikesrvm.classloader.ClassLoaderConstants;
-import org.jikesrvm.classloader.RVMArray;
+import org.jikesrvm.VM;
 import org.jikesrvm.classloader.BytecodeConstants;
 import org.jikesrvm.classloader.BytecodeStream;
-import org.jikesrvm.classloader.RVMClass;
+import org.jikesrvm.classloader.ClassLoaderConstants;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.FieldReference;
-import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.MethodReference;
 import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMArray;
+import org.jikesrvm.classloader.RVMClass;
+import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.classloader.TypeReference;
 import org.jikesrvm.compilers.common.CompiledMethod;
 import org.jikesrvm.compilers.common.CompiledMethods;
 import org.jikesrvm.compilers.common.assembler.ForwardReference;
 import org.jikesrvm.osr.bytecodes.InvokeStatic;
+import org.jikesrvm.runtime.Entrypoints;
 import org.jikesrvm.runtime.Statics;
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.NoInline;
@@ -1383,6 +1385,18 @@ public abstract class TemplateCompilerFr
 
         case JBC_getstatic: {
           FieldReference fieldRef = bcodes.getFieldReference();
+
+          // Octet: If System.out/err/in is used from the VM context, change it to VMSystem.out/err/in.
+          if (method.getStaticContext() == Context.VM_CONTEXT) {
+            if (fieldRef == Entrypoints.systemOut) {
+              fieldRef = Entrypoints.vmSystemOut;
+            } else if (fieldRef == Entrypoints.systemErr) {
+              fieldRef = Entrypoints.vmSystemErr;
+            } else if (fieldRef == Entrypoints.systemIn) { 
+              fieldRef = Entrypoints.vmSystemIn;
+            }
+          }
+
           if (shouldPrint) asm.noteBytecode(biStart, "getstatic", fieldRef);
           if (fieldRef.needsDynamicLink(method)) {
             // Forbidden from uninterruptible code as dynamic linking can cause
@@ -1437,7 +1451,11 @@ public abstract class TemplateCompilerFr
           break;
         }
 
+        // Octet: Static cloning: Modified a few invoke cases to support multiple resolved methods for every method reference.
+
         case JBC_invokevirtual: {
+          
+          MethodReference methodRef = bcodes.getMethodReference();
           ForwardReference xx = null;
           if (biStart == this.pendingIdx) {
             ForwardReference x = emit_pending_goto(0);  // goto X
@@ -1449,7 +1467,7 @@ public abstract class TemplateCompilerFr
             x.resolve(asm);                       //  X:
           }
 
-          MethodReference methodRef = bcodes.getMethodReference();
+          
           if (shouldPrint) asm.noteBytecode(biStart, "invokevirtual", methodRef);
           if (methodRef.getType().isMagicType()) {
             if (emit_Magic(methodRef)) {
@@ -1468,14 +1486,25 @@ public abstract class TemplateCompilerFr
             if (VM.VerifyUnint && !isInterruptible) forbiddenBytecode("invokeinterface ", methodRef, bcodes.index());
             emit_invokeinterface(methodRef);
           } else {
+            // Velodrome: Context: Compute context if the current method is non-application while the invoked method is an 
+            // application method.
+            int context = method.getStaticContext();
+            if (!Context.isApplicationPrefix(method.getDeclaringClass().getTypeRef()) && 
+                Context.isApplicationPrefix(methodRef.getType())) {
+              if (methodRef.isNonAtomic) {
+                context = Context.NONTRANS_CONTEXT;
+              } else {
+                context = Context.TRANS_CONTEXT;
+              }
+            }            
             if (methodRef.needsDynamicLink(method)) {
               // Forbidden from uninterruptible code as dynamic linking can
               // cause interruptions
               if (VM.VerifyUnint && !isInterruptible) forbiddenBytecode("unresolved invokevirtual ", methodRef, bcodes.index());
-              emit_unresolved_invokevirtual(methodRef);
+              emit_unresolved_invokevirtual(methodRef, context);
             } else {
-              if (VM.VerifyUnint && !isInterruptible) checkTarget(methodRef.peekResolvedMethod(), bcodes.index());
-              emit_resolved_invokevirtual(methodRef);
+              if (VM.VerifyUnint && !isInterruptible) checkTarget(methodRef.peekResolvedMethod(context), bcodes.index());
+              emit_resolved_invokevirtual(methodRef, context);
             }
           }
 
@@ -1486,6 +1515,8 @@ public abstract class TemplateCompilerFr
         }
 
         case JBC_invokespecial: {
+          
+          MethodReference methodRef = bcodes.getMethodReference();
           ForwardReference xx = null;
           if (biStart == this.pendingIdx) {
             ForwardReference x = emit_pending_goto(0);  // goto X
@@ -1496,14 +1527,27 @@ public abstract class TemplateCompilerFr
             xx = emit_pending_goto(0);                     // goto XX
             x.resolve(asm);                       //  X:
           }
-          MethodReference methodRef = bcodes.getMethodReference();
+          
           if (shouldPrint) asm.noteBytecode(biStart, "invokespecial", methodRef);
-          RVMMethod target = methodRef.resolveInvokeSpecial();
+          
+          // Velodrome: Context: Compute context if the current method is non-application while the invoked method is an 
+          // application method.
+          int context = method.getStaticContext();
+          if (!Context.isApplicationPrefix(method.getDeclaringClass().getTypeRef()) && 
+              Context.isApplicationPrefix(methodRef.getType())) {
+            if (methodRef.isNonAtomic) {
+              context = Context.NONTRANS_CONTEXT;
+            } else {
+              context = Context.TRANS_CONTEXT;
+            }
+          }
+
+          RVMMethod target = methodRef.resolveInvokeSpecial(context);
           if (target != null) {
             if (VM.VerifyUnint && !isInterruptible) checkTarget(target, bcodes.index());
             emit_resolved_invokespecial(methodRef, target);
           } else {
-            emit_unresolved_invokespecial(methodRef);
+            emit_unresolved_invokespecial(methodRef, context);
           }
 
           if (xx != null) {
@@ -1514,6 +1558,8 @@ public abstract class TemplateCompilerFr
         }
 
         case JBC_invokestatic: {
+          
+          MethodReference methodRef = bcodes.getMethodReference();
           ForwardReference xx = null;
           if (biStart == this.pendingIdx) {
             ForwardReference x = emit_pending_goto(0);  // goto X
@@ -1525,7 +1571,6 @@ public abstract class TemplateCompilerFr
             x.resolve(asm);                       //  X:
           }
 
-          MethodReference methodRef = bcodes.getMethodReference();
           if (shouldPrint) asm.noteBytecode(biStart, "invokestatic", methodRef);
           if (methodRef.isMagic()) {
             if (emit_Magic(methodRef)) {
@@ -1538,8 +1583,19 @@ public abstract class TemplateCompilerFr
             if (VM.VerifyUnint && !isInterruptible) forbiddenBytecode("unresolved invokestatic ", methodRef, bcodes.index());
             emit_unresolved_invokestatic(methodRef);
           } else {
-            if (VM.VerifyUnint && !isInterruptible) checkTarget(methodRef.peekResolvedMethod(), bcodes.index());
-            emit_resolved_invokestatic(methodRef);
+            // Velodrome: Context: Compute context if the current method is non-application while the invoked method is an 
+            // application method.
+            int context = method.getStaticContext();
+            if (!Context.isApplicationPrefix(method.getDeclaringClass().getTypeRef()) && 
+                Context.isApplicationPrefix(methodRef.getType())) {
+              if (methodRef.isNonAtomic) {
+                context = Context.NONTRANS_CONTEXT;
+              } else {
+                context = Context.TRANS_CONTEXT;
+              }
+            }
+            if (VM.VerifyUnint && !isInterruptible) checkTarget(methodRef.peekResolvedMethod(context), bcodes.index());
+            emit_resolved_invokestatic(methodRef, context);
           }
 
           if (xx != null) {
@@ -1550,6 +1606,8 @@ public abstract class TemplateCompilerFr
         }
 
         case JBC_invokeinterface: {
+          
+          MethodReference methodRef = bcodes.getMethodReference();
           ForwardReference xx = null;
           if (biStart == this.pendingIdx) {
             ForwardReference x = emit_pending_goto(0);  // goto X
@@ -1561,7 +1619,6 @@ public abstract class TemplateCompilerFr
             x.resolve(asm);                       //  X:
           }
 
-          MethodReference methodRef = bcodes.getMethodReference();
           bcodes.alignInvokeInterface();
           if (shouldPrint) asm.noteBytecode(biStart, "invokeinterface", methodRef);
           // Forbidden from uninterruptible code as interface invocation
@@ -1961,7 +2018,8 @@ public abstract class TemplateCompilerFr
                 int targetidx = bcodes.readIntConst(); // fetch4BytesSigned();
                 RVMMethod methodRef = InvokeStatic.targetMethod(targetidx);
                 if (shouldPrint) asm.noteBytecode(biStart, "pseudo_invokestatic", methodRef);
-                emit_resolved_invokestatic(methodRef.getMemberRef().asMethodReference());
+                // Velodrome: Context: Pass the static context of the method reference
+                emit_resolved_invokestatic(methodRef.getMemberRef().asMethodReference(), methodRef.getStaticContext());
                 break;
               }
               /*
@@ -2943,17 +3001,19 @@ public abstract class TemplateCompilerFr
   * method invocation
   */
 
+  // Velodrome: Context: Added the context as a parameter to a few methods
+  
   /**
    * Emit code to implement a dynamically linked invokevirtual
    * @param methodRef the referenced method
    */
-  protected abstract void emit_unresolved_invokevirtual(MethodReference methodRef);
+  protected abstract void emit_unresolved_invokevirtual(MethodReference methodRef, int context);
 
   /**
    * Emit code to implement invokevirtual
    * @param methodRef the referenced method
    */
-  protected abstract void emit_resolved_invokevirtual(MethodReference methodRef);
+  protected abstract void emit_resolved_invokevirtual(MethodReference methodRef, int context);
 
   /**
    * Emit code to implement a dynamically linked invokespecial
@@ -2966,7 +3026,7 @@ public abstract class TemplateCompilerFr
    * Emit code to implement invokespecial
    * @param methodRef the referenced method
    */
-  protected abstract void emit_unresolved_invokespecial(MethodReference methodRef);
+  protected abstract void emit_unresolved_invokespecial(MethodReference methodRef, int context);
 
   /**
    * Emit code to implement a dynamically linked invokestatic
@@ -2978,7 +3038,7 @@ public abstract class TemplateCompilerFr
    * Emit code to implement invokestatic
    * @param methodRef the referenced method
    */
-  protected abstract void emit_resolved_invokestatic(MethodReference methodRef);
+  protected abstract void emit_resolved_invokestatic(MethodReference methodRef, int context);
 
   // OSR only
   protected abstract void emit_invoke_compiledmethod(CompiledMethod cm);
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/BarrierType.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/BarrierType.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/BarrierType.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/BarrierType.java	2014-04-03 17:43:42.990670442 -0400
@@ -0,0 +1,83 @@
+package org.jikesrvm.compilers.opt;
+
+/**
+ * Octet: This enum represents different types of information that are used in
+ * RedundantBarrierAnalysis.
+ * 
+ * @author Meisam
+ * 
+ */
+public enum BarrierType {
+
+  /**
+   * Object is NOT protected by any barrier
+   * <p>
+   * Note: Normally, this should never be used. If barrier information for an
+   * object does not exist in the {@code ObjectsAccessFacts} then it means that
+   * the type of barrier for that object is {@code BOTTOM}.
+   */
+  BOTTOM,
+
+  /**
+   * Object is protected by read barrier, so adding a new read barrier to it
+   * would be redundant.
+   */
+  READ,
+
+  /**
+   * Object is protected by a write barrier, so adding a new read barrier or a
+   * write barrier to it would be redundant.
+   */
+  WRITE,
+
+  /**
+   * Object is newly instantiated and is visible just to one thread. Even a safe
+   * point cannot cause this object lose its write exclusive access.
+   */
+  TOP;
+
+  /**
+   * Returns true if this barrier is "stronger" than the other given barrier.
+   * 
+   * @param otherBarrier
+   *          the other given barrier
+   * @return true if this barrier is higher
+   * 
+   */
+  public boolean isHigher(final BarrierType otherBarrier) {
+    return this.compareTo(otherBarrier) >= 0;
+  }
+
+  /**
+   * Returns true if this barrier is "weaker" than the other given barrier.
+   * 
+   * @param otherBarrier
+   *          other given barrier
+   * @return true if this barrier is higher
+   * @param otherBarrier
+   * @return
+   */
+  public boolean isLower(final BarrierType otherBarrier) {
+    return this.compareTo(otherBarrier) <= 0;
+  }
+
+  /**
+   * Using the terminology of a lattice.
+   * 
+   * @param otherBarrier
+   * @return
+   */
+  public BarrierType infimum(final BarrierType otherBarrier) {
+    return this.compareTo(otherBarrier) < 0 ? this : otherBarrier;
+  }
+
+  /**
+   * Using the terminology of a lattice
+   * 
+   * @param otherBarrier
+   * @return
+   */
+  public BarrierType supremum(final BarrierType otherBarrier) {
+    return this.compareTo(otherBarrier) > 0 ? this : otherBarrier;
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/bc2ir/BC2IR.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/bc2ir/BC2IR.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/bc2ir/BC2IR.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/bc2ir/BC2IR.java	2014-04-03 17:43:43.432671895 -0400
@@ -20,6 +20,7 @@ import org.jikesrvm.adaptive.controller.
 import org.jikesrvm.classloader.BytecodeConstants;
 import org.jikesrvm.classloader.BytecodeStream;
 import org.jikesrvm.classloader.ClassLoaderConstants;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.FieldReference;
@@ -1609,6 +1610,12 @@ public final class BC2IR
                   // VM.sysWrite("Replaced getstatic of "+field+" with "+rhs+"\n");
                   push(rhs, fieldType);
                   break;
+                // Octet: TODO: Is this catch no longer needed after the port to Jikes 3.1.3?
+                // Octet: LATER: This catch block avoids an error due to upgrading to a new JDK version in October 2012.
+                // There's a more complete fix coming in Jikes 3.1.3.
+                } catch (NullPointerException e) {
+                  if (VM.VerifyAssertions) { VM._assert(!VM.runningVM); }
+                  System.out.println("Ignoring unexpected NPE when trying to chase constant field at bootimage build time: " + field);
                 } catch (NoSuchFieldException e) {
                   if (VM.runningVM) {
                     throw new Error("Unexpected exception", e);
@@ -1776,6 +1783,8 @@ public final class BC2IR
         }
         break;
 
+        // Octet: Static cloning: Modified various invoke cases to support multiple resolved methods for every method reference.
+
         case JBC_invokevirtual: {
           MethodReference ref = bcodes.getMethodReference();
 
@@ -1815,7 +1824,7 @@ public final class BC2IR
             // to prove one implies the other.
             RVMMethod vmeth = null;
             if (receiverType != null && receiverType.isInitialized() && !receiverType.isInterface()) {
-              vmeth = ClassLoaderProxy.lookupMethod(receiverType, ref);
+              vmeth = ClassLoaderProxy.lookupMethod(receiverType, ref, gc.method.getStaticContext());
             }
             if (vmeth != null) {
               MethodReference vmethRef = vmeth.getMemberRef().asMethodReference();
@@ -1846,7 +1855,18 @@ public final class BC2IR
           } else {
             // A normal invokevirtual.  Create call instruction.
             boolean unresolved = ref.needsDynamicLink(bcodes.getMethod());
-            RVMMethod target = ref.peekResolvedMethod();
+            // Velodrome: Context: Compute context if the current method is non-application while the invoked method is an 
+            // application method.
+            int context = gc.method.getStaticContext();
+            if (!Context.isApplicationPrefix(gc.method.getDeclaringClass().getTypeRef()) 
+                && Context.isApplicationPrefix(ref.getType())) {
+              if (ref.isNonAtomic) {
+                context = Context.NONTRANS_CONTEXT;
+              } else {
+                context = Context.TRANS_CONTEXT;
+              }
+            }
+            RVMMethod target = ref.peekResolvedMethod(context);
             MethodOperand methOp = MethodOperand.VIRTUAL(ref, target);
 
             s = _callHelper(ref, methOp);
@@ -1896,7 +1916,7 @@ public final class BC2IR
               if (type.isClassType()) {
                 RVMMethod vmeth = target;
                 if (target == null || type != target.getDeclaringClass()) {
-                  vmeth = ClassLoaderProxy.lookupMethod(type.asClass(), ref);
+                  vmeth = ClassLoaderProxy.lookupMethod(type.asClass(), ref, context);
                 }
                 if (vmeth != null) {
                   methOp.refine(vmeth, isPreciseType || type.asClass().isFinal());
@@ -1921,7 +1941,18 @@ public final class BC2IR
 
         case JBC_invokespecial: {
           MethodReference ref = bcodes.getMethodReference();
-          RVMMethod target = ref.resolveInvokeSpecial();
+          // Velodrome: Context: Compute context if the current method is non-application while the invoked method is an 
+          // application method.
+          int context = gc.method.getStaticContext();
+          if (!Context.isApplicationPrefix(gc.method.getDeclaringClass().getTypeRef()) &&
+              Context.isApplicationPrefix(ref.getType())) {
+            if (ref.isNonAtomic) {
+              context = Context.NONTRANS_CONTEXT;
+            } else {
+              context = Context.TRANS_CONTEXT;
+            }
+          }
+          RVMMethod target = ref.resolveInvokeSpecial(context);
 
           /* just create an osr barrier right before _callHelper
            * changes the states of locals and stacks.
@@ -1977,7 +2008,18 @@ public final class BC2IR
 
           // A non-magical invokestatic.  Create call instruction.
           boolean unresolved = ref.needsDynamicLink(bcodes.getMethod());
-          RVMMethod target = ref.peekResolvedMethod();
+          // Velodrome: Context: Compute context if the current method is non-application while the invoked method is an 
+          // application method.
+          int context = gc.method.getStaticContext();
+          if (!Context.isApplicationPrefix(gc.method.getDeclaringClass().getTypeRef()) &&
+              Context.isApplicationPrefix(ref.getType())) {
+            if (ref.isNonAtomic) {
+              context = Context.NONTRANS_CONTEXT;
+            } else {
+              context = Context.TRANS_CONTEXT;
+            }
+          }
+          RVMMethod target = ref.peekResolvedMethod(context);
 
           /* just create an osr barrier right before _callHelper
           * changes the states of locals and stacks.
@@ -2018,7 +2060,12 @@ public final class BC2IR
           MethodReference ref = bcodes.getMethodReference();
           bcodes.alignInvokeInterface();
           RVMMethod resolvedMethod = null;
-          resolvedMethod = ref.peekInterfaceMethod();
+          // Velodrome: Context: Interface invocation for non-application methods can only have VM_CONTEXT
+          int context = gc.method.getStaticContext();
+          if (!Context.isApplicationPrefix(ref.getType())) {
+            context = Context.VM_CONTEXT;
+          }
+          resolvedMethod = ref.peekInterfaceMethod(context);
 
           /* just create an osr barrier right before _callHelper
            * changes the states of locals and stacks.
@@ -2049,12 +2096,13 @@ public final class BC2IR
             // to an out-of-line typechecking routine to handle it at runtime.
             RVMMethod target = Entrypoints.unresolvedInvokeinterfaceImplementsTestMethod;
             Instruction callCheck =
-              Call.create2(CALL,
+              Call.create3(CALL,
                            null,
                            new AddressConstantOperand(target.getOffset()),
                            MethodOperand.STATIC(target),
                            new IntConstantOperand(ref.getId()),
-                           receiver.copy());
+                           receiver.copy(),
+                           IRTools.IC(context));
             if (gc.options.H2L_NO_CALLEE_EXCEPTIONS) {
               callCheck.markAsNonPEI();
             }
@@ -2093,7 +2141,7 @@ public final class BC2IR
           // to prove one implies the other.
           RVMMethod vmeth = null;
           if (receiverType != null && receiverType.isInitialized() && !receiverType.isInterface()) {
-            vmeth = ClassLoaderProxy.lookupMethod(receiverType, ref);
+            vmeth = ClassLoaderProxy.lookupMethod(receiverType, ref, gc.method.getStaticContext());
           }
           if (vmeth != null) {
             MethodReference vmethRef = vmeth.getMemberRef().asMethodReference();
@@ -4622,6 +4670,14 @@ public final class BC2IR
     if (Call.getMethod(call).getTarget() == null) {
       return InlineDecision.NO("Target method is null");
     }
+    // Velodrome: Don't allow inlining a Tx into a non-Tx
+    if (VM.runningVM && VM.VerifyAssertions) {
+      if (gc.method.getMemberRef().asMethodReference().isNonAtomic && 
+          !Call.getMethod(call).getTarget().getMemberRef().asMethodReference().isNonAtomic) {
+        return InlineDecision.NO("AVD Shouldn't inline Tx into non-Tx");
+      }
+    }
+
     CompilationState state = new CompilationState(call, isExtant, gc.options, gc.original_cm, realBCI);
     InlineDecision d = gc.inlinePlan.shouldInline(state);
     return d;
@@ -4648,7 +4704,15 @@ public final class BC2IR
       if (VM.VerifyAssertions) VM._assert(lastOsrBarrier != null);
       callSite.scratchObject = lastOsrBarrier;
     }
-
+    
+    // Velodrome: Assert that a Tx is not inlined into a non-Tx
+    if (VM.runningVM && VM.VerifyAssertions) {
+      if (gc.method.getMemberRef().asMethodReference().isNonAtomic 
+          && !Call.getMethod(callSite).getTarget().getMemberRef().asMethodReference().isNonAtomic) {
+        VM.sysFail("Shouldn't inline a Tx into a non-Tx");
+      }
+    }
+    
     // Execute the inline decision.
     // NOTE: It is tempting to wrap the call to Inliner.execute in
     // a try/catch block that suppresses MagicNotImplemented failures
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java	2014-04-03 17:43:43.376671710 -0400
@@ -73,6 +73,7 @@ import static org.jikesrvm.compilers.opt
 import org.jikesrvm.VM;
 import org.jikesrvm.ArchitectureSpecificOpt.GenerateMachineSpecificMagic;
 import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.MethodReference;
@@ -522,7 +523,8 @@ public class GenerateMagic implements TI
         Call.setResult(call, op0);
         bc2ir.push(op0.copyD2U(), returnType);
       }
-      Call.setMethod(call, MethodOperand.STATIC(meth, meth.peekResolvedMethod()));
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      Call.setMethod(call, MethodOperand.STATIC(meth, meth.peekResolvedMethod(Context.VM_CONTEXT)));
       bc2ir.appendInstruction(call);
     } else if (meth.isSpecializedInvoke()) {
       // The callsite looks like              RETURN = INVOKE (ID, OBJECT, P0, P1 .. PN)
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerationContext.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerationContext.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerationContext.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerationContext.java	2014-04-03 17:43:43.431671891 -0400
@@ -58,6 +58,7 @@ import org.jikesrvm.compilers.opt.ir.ope
 import org.jikesrvm.compilers.opt.ir.operand.RegisterOperand;
 import org.jikesrvm.compilers.opt.ir.operand.TrueGuardOperand;
 import org.jikesrvm.compilers.opt.ir.operand.TypeOperand;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.Entrypoints;
 import org.jikesrvm.runtime.Statics;
 import org.vmmagic.unboxed.Offset;
@@ -728,7 +729,14 @@ public final class GenerationContext imp
       appendInstruction(rethrow, s, SYNTH_CATCH_BCI);
       Operand lockObject = getLockObject();
 
-      RVMMethod target = Entrypoints.unlockAndThrowMethod;
+      // Velodrome: Decide which unlock method to use
+      RVMMethod target;
+      if (Octet.shouldInstrumentMethod(method)) {
+        target = Entrypoints.unlockAndThrowMethod;
+      } else {
+        target = Entrypoints.unlockAndThrowMethodWithoutInstrumentation;
+      }
+      
       MethodOperand methodOp = MethodOperand.STATIC(target);
       methodOp.setIsNonReturningCall(true); // Used to keep cfg correct
       s =
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ClassLoaderProxy.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ClassLoaderProxy.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ClassLoaderProxy.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ClassLoaderProxy.java	2014-04-03 17:43:44.845676539 -0400
@@ -324,13 +324,14 @@ public final class ClassLoaderProxy impl
   /**
    * Find the method of the given class that matches the given descriptor.
    */
-  public static RVMMethod lookupMethod(RVMClass cls, MethodReference ref) {
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+  public static RVMMethod lookupMethod(RVMClass cls, MethodReference ref, int context) {
     RVMMethod newmeth = null;
     if (cls.isResolved() && !cls.isInterface()) {
       Atom mn = ref.getName();
       Atom md = ref.getDescriptor();
       for (; (newmeth == null) && (cls != null); cls = cls.getSuperClass()) {
-        newmeth = cls.findDeclaredMethod(mn, md);
+        newmeth = cls.findDeclaredMethod(mn, md, context);
       }
     }
     return newmeth;
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizationPlanner.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizationPlanner.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizationPlanner.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizationPlanner.java	2014-04-03 17:43:42.871670050 -0400
@@ -14,8 +14,8 @@ package org.jikesrvm.compilers.opt.drive
 
 import java.util.ArrayList;
 
-import org.jikesrvm.VM;
 import org.jikesrvm.ArchitectureSpecificOpt.MIROptimizationPlanner;
+import org.jikesrvm.VM;
 import org.jikesrvm.adaptive.recompilation.instrumentation.InsertInstructionCounters;
 import org.jikesrvm.adaptive.recompilation.instrumentation.InsertMethodInvocationCounter;
 import org.jikesrvm.adaptive.recompilation.instrumentation.InsertYieldpointCounters;
@@ -28,6 +28,7 @@ import org.jikesrvm.compilers.opt.LocalC
 import org.jikesrvm.compilers.opt.LocalConstantProp;
 import org.jikesrvm.compilers.opt.LocalCopyProp;
 import org.jikesrvm.compilers.opt.OptOptions;
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
 import org.jikesrvm.compilers.opt.Simple;
 import org.jikesrvm.compilers.opt.bc2ir.ConvertBCtoHIR;
 import org.jikesrvm.compilers.opt.bc2ir.OsrPointConstructor;
@@ -55,6 +56,7 @@ import org.jikesrvm.compilers.opt.ssa.Lo
 import org.jikesrvm.compilers.opt.ssa.PiNodes;
 import org.jikesrvm.compilers.opt.ssa.RedundantBranchElimination;
 import org.jikesrvm.compilers.opt.ssa.SSATuneUp;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.osr.AdjustBCIndexes;
 
 /**
@@ -422,6 +424,7 @@ public class OptimizationPlanner {
    * @param p the plan under construction
    */
   private static void HIR2LIR(ArrayList<OptimizationPlanElement> p) {
+    RedundantBarrierRemover redundantBarrierRemover;
     composeComponents(p, "Convert HIR to LIR", new Object[]{
         // Optional printing of final HIR
         new IRPrinter("Final HIR") {
@@ -431,6 +434,14 @@ public class OptimizationPlanner {
           }
         },
 
+        // Octet: decide which instructions should get instrumented
+        Octet.getClientAnalysis().newOptSelect(),
+        
+        // Octet: Unmarks instructions that don't need a barrier
+        redundantBarrierRemover = Octet.getClientAnalysis().newRedundantBarriersAnalysis(),
+        // Octet: add instrumentation early in the optimization process (if early instrumentation enabled)
+        Octet.getClientAnalysis().newOptInstr(false, redundantBarrierRemover),
+
         // Inlining "runtime service" methods
         new ExpandRuntimeServices(),
         // Peephole branch optimizations
@@ -482,6 +493,9 @@ public class OptimizationPlanner {
     // Perform peephole branch optimizations
     addComponent(p, new BranchOptimizations(0, false, true));
 
+    // Octet: add instrumentation late in the optimization process (if late instrumentation enabled)
+    addComponent(p, Octet.getClientAnalysis().newOptInstr(true, null));
+
     if (VM.BuildForAdaptiveSystem) {
       // Arnold & Ryder instrumentation sampling framework
       addComponent(p, new InstrumentationSamplingFramework());
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/EscapeTransformations.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/EscapeTransformations.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/EscapeTransformations.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/EscapeTransformations.java	2014-04-03 17:43:43.290671427 -0400
@@ -81,6 +81,14 @@ public class EscapeTransformations exten
     return false;
   }
 
+  /** Octet: use Jikes's existing escape analysis to identify objects that definitely don't escape their allocating thread */
+  // Octet: TODO: evaluate whether escape analysis is still broken in Jikes 3.1.2 / 3.1.3  
+  public static FI_EscapeSummary getEscapeSummary(IR ir) {
+    SimpleEscape analyzer = new SimpleEscape();
+    FI_EscapeSummary summary = analyzer.simpleEscapeAnalysis(ir);
+    return summary;
+  }
+  
   /**
    * Perform the transformations
    *
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/FI_EscapeSummary.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/FI_EscapeSummary.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/FI_EscapeSummary.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/FI_EscapeSummary.java	2014-04-03 17:43:43.289671424 -0400
@@ -19,13 +19,15 @@ import org.jikesrvm.compilers.opt.ir.Reg
  * This class holds the results of a flow-insensitive escape analysis
  * for a method.
  */
-class FI_EscapeSummary {
+// Octet: made public (was package-protected)
+public class FI_EscapeSummary {
 
   /**
    * Returns {@code true} iff ANY object pointed to by symbolic register r
    * MUST be thread local
    */
-  boolean isThreadLocal(Register r) {
+  // Octet: made public (was package-protected)
+  public boolean isThreadLocal(Register r) {
     Object result = hash.get(r);
     return result != null && result == THREAD_LOCAL;
   }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/MethodSummary.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/MethodSummary.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/MethodSummary.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/MethodSummary.java	2014-04-03 17:43:43.289671424 -0400
@@ -30,6 +30,7 @@ class MethodSummary {
    * Default escape result, that the result escapes but that no parameter is
    * escaping.
    */
+  // Octet: TODO: This seems like the wrong pattern and thus part of the reason escape analysis is broken?
   private static final long RES_ESCAPE = 0x80000000;
 
   /**
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/SimpleEscape.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/SimpleEscape.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/escape/SimpleEscape.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/escape/SimpleEscape.java	2014-04-03 17:43:43.290671427 -0400
@@ -388,6 +388,14 @@ class SimpleEscape extends CompilerPhase
    */
   private static boolean checkEscapesThread(RegisterOperand use, IR ir, Set<Register> visited) {
     Instruction inst = use.instruction;
+    
+    // Octet: TODO: This check seems necessary (but it's still not enough to make escape analysis correct)
+    /*
+    if (ir.isParameter(use)) {
+      return true;
+    }
+    */
+
     switch (inst.getOpcode()) {
       case INT_ASTORE_opcode:
       case LONG_ASTORE_opcode:
@@ -510,8 +518,15 @@ class SimpleEscape extends CompilerPhase
           return summ.resultMayEscapeThread();
         }
         // use is a parameter to the call.  Find out which one.
+
+        // Octet: Had previously added check for -1 because some call uses aren't actually parameters in low-level IR.
+        // But now we should go back to the original Jikes code, I think.
         int p = getParameterIndex(use, inst);
-        return summ.parameterMayEscapeThread(p);
+        if (p >= 0) {
+          return summ.parameterMayEscapeThread(p);
+        } else {
+          VM.sysFail("Unexpected");
+        }
       case REF_MOVE_opcode: {
         Register copy = Move.getResult(inst).getRegister();
         if (!copy.isSSA()) {
@@ -818,7 +833,10 @@ class SimpleEscape extends CompilerPhase
     try {
       OptimizingCompiler.compile(plan);
     } catch (MagicNotImplementedException e) {
-      summ.setInProgress(false); // summary stays at bottom
+      // Octet: added null check to avoid exception
+      if (summ != null) {
+        summ.setInProgress(false); // summary stays at bottom
+      }
     }
   }
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ConvertToLowLevelIR.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ConvertToLowLevelIR.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ConvertToLowLevelIR.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ConvertToLowLevelIR.java	2014-04-03 17:43:42.992670448 -0400
@@ -91,6 +91,7 @@ import static org.jikesrvm.objectmodel.T
 
 import org.jikesrvm.VM;
 import org.jikesrvm.adaptive.AosEntrypoints;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.InterfaceInvocation;
@@ -780,7 +781,8 @@ public abstract class ConvertToLowLevelI
    * @param ir the containing IR
    * @return the last expanded instruction
    */
-  static Instruction callHelper(Instruction v, IR ir) {
+  // Octet: made public so we can call it from OctetInstr
+  public static Instruction callHelper(Instruction v, IR ir) {
     if (!Call.hasMethod(v)) {
       if (VM.VerifyAssertions) VM._assert(Call.getAddress(v) instanceof RegisterOperand);
       return v; // nothing to do....very low level call to address already in the register.
@@ -868,10 +870,16 @@ public abstract class ConvertToLowLevelI
     } else {
       if (VM.VerifyAssertions) VM._assert(methOp.isInterface());
       if (VM.VerifyAssertions) VM._assert(!Call.hasAddress(v));
+      // Octet: Static cloning: Modified several locations below to support multiple resolved methods for every method reference.
+      // Velodrome: Context: Interface invocation for non-application methods can only have VM_CONTEXT
+      int context = v.position.method.getStaticContext();
+      if (methOp.hasTarget() && !Context.isApplicationPrefix(methOp.getTarget().getDeclaringClass().getTypeRef())) {
+        context = Context.VM_CONTEXT;
+      }      
       if (VM.BuildForIMTInterfaceInvocation) {
         // SEE ALSO: FinalMIRExpansion (for hidden parameter)
         Operand RHStib = getTIB(v, ir, Call.getParam(v, 0).copy(), Call.getGuard(v).copy());
-        InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(methOp.getMemberRef());
+        InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(methOp.getMemberRef(), context);
         Offset offset = sig.getIMTOffset();
         RegisterOperand address = null;
         RegisterOperand IMT =
@@ -892,7 +900,8 @@ public abstract class ConvertToLowLevelI
           itableIndex =
               InterfaceInvocation.getITableIndex(I,
                                                     methOp.getMemberRef().getName(),
-                                                    methOp.getMemberRef().getDescriptor());
+                                                    methOp.getMemberRef().getDescriptor(),
+                                                    context);
         }
         if (itableIndex == -1) {
           // itable index is not known at compile-time.
@@ -901,12 +910,13 @@ public abstract class ConvertToLowLevelI
           RegisterOperand realAddrReg = ir.regpool.makeTemp(TypeReference.CodeArray);
           RVMMethod target = Entrypoints.invokeInterfaceMethod;
           Instruction vp =
-              Call.create2(CALL,
+              Call.create3(CALL,
                            realAddrReg,
                            AC(target.getOffset()),
                            MethodOperand.STATIC(target),
                            Call.getParam(v, 0).asRegister().copyU2U(),
-                           IC(methOp.getMemberRef().getId()));
+                           IC(methOp.getMemberRef().getId()),
+                           IC(context));
           vp.position = v.position;
           vp.bcIndex = RUNTIME_SERVICES_BCI;
           v.insertBefore(vp);
@@ -971,7 +981,8 @@ public abstract class ConvertToLowLevelI
 
     // Get the offset from the appropriate RVMClassLoader array
     // and check to see if it is valid
-    RegisterOperand offsetTable = getStatic(testBB.lastInstruction(), ir, Entrypoints.memberOffsetsField);
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+    RegisterOperand offsetTable = getStatic(testBB.lastInstruction(), ir, Entrypoints.memberOffsetsFields[s.position.method.getStaticContext()]);
     testBB.appendInstruction(Load.create(INT_LOAD,
                                          offset.copyRO(),
                                          offsetTable,
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java	2014-04-03 17:43:42.991670445 -0400
@@ -42,6 +42,7 @@ import static org.jikesrvm.mm.mminterfac
 import java.lang.reflect.Constructor;
 
 import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMArray;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMField;
@@ -79,7 +80,10 @@ import org.jikesrvm.compilers.opt.ir.ope
 import org.jikesrvm.compilers.opt.ir.operand.TypeOperand;
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.objectmodel.ObjectModel;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.util.HashSetRVM;
+import org.vmmagic.pragma.Inline;
 
 /**
  * As part of the expansion of HIR into LIR, this compile phase
@@ -143,6 +147,16 @@ public final class ExpandRuntimeServices
   public void perform(IR ir) {
     ir.gc.resync(); // resync generation context -- yuck...
 
+    // Octet: Static cloning: Check that the static and dynamic contexts match.
+    if (Context.DEBUG && Context.isLibraryPrefix(ir.getMethod().getDeclaringClass().getTypeRef())) {
+      RVMMethod target = Entrypoints.checkLibraryContextMethod;
+      Instruction call = Call.create0(CALL, null, IRTools.AC(target.getOffset()), MethodOperand.STATIC(target));
+      ir.firstBasicBlockInCodeOrder().prependInstructionRespectingPrologue(call);
+    }
+    
+    // Octet: needed in order to ensure that Jikes write pre-barriers aren't added multiple times to the same instruction
+    HashSetRVM<Instruction> instsWithWritePreBarrier = new HashSetRVM<Instruction>();
+    
     Instruction next;
     for (Instruction inst = ir.firstInstructionInCodeOrder(); inst != null; inst = next) {
       next = inst.nextInstructionInCodeOrder();
@@ -322,7 +336,13 @@ public final class ExpandRuntimeServices
           Operand ref = MonitorOp.getClearRef(inst);
           RVMType refType = ref.getType().peekType();
           if (refType != null && !refType.getThinLockOffset().isMax()) {
-            RVMMethod target = Entrypoints.inlineLockMethod;
+            // Velodrome: Decide which lock method to use
+            RVMMethod target;
+            if (Octet.shouldInstrumentMethod(inst.position.getMethod())) {
+              target = Entrypoints.inlineLockMethodWithInstrumentation;
+            } else {
+              target = Entrypoints.inlineLockMethodWithoutInstrumentation;
+            }
             Call.mutate2(inst,
                          CALL,
                          null,
@@ -338,7 +358,13 @@ public final class ExpandRuntimeServices
               inline(inst, ir);
             }
           } else {
-            RVMMethod target = Entrypoints.lockMethod;
+            // Velodrome: Decide which lock method to use
+            RVMMethod target;
+            if (Octet.shouldInstrumentMethod(inst.position.getMethod())) {
+              target = Entrypoints.lockMethodWithInstrumentation;
+            } else {
+              target = Entrypoints.lockMethodWithoutInstrumentation;
+            }
             Call.mutate1(inst,
                          CALL,
                          null,
@@ -354,7 +380,13 @@ public final class ExpandRuntimeServices
           Operand ref = MonitorOp.getClearRef(inst);
           RVMType refType = ref.getType().peekType();
           if (refType != null && !refType.getThinLockOffset().isMax()) {
-            RVMMethod target = Entrypoints.inlineUnlockMethod;
+            // Velodrome: Decide which lock method to use
+            RVMMethod target;
+            if (Octet.shouldInstrumentMethod(inst.position.getMethod())) {
+              target = Entrypoints.inlineUnlockMethodWithInstrumentation;
+            } else {
+              target = Entrypoints.inlineUnlockMethodWithoutInstrumentation;
+            }
             Call.mutate2(inst,
                          CALL,
                          null,
@@ -370,7 +402,13 @@ public final class ExpandRuntimeServices
               inline(inst, ir);
             }
           } else {
-            RVMMethod target = Entrypoints.unlockMethod;
+            // Velodrome: Decide which unlock method to use
+            RVMMethod target;
+            if (Octet.shouldInstrumentMethod(inst.position.getMethod())) {
+              target = Entrypoints.unlockMethodWithInstrumentation;
+            } else {
+              target = Entrypoints.unlockMethodWithoutInstrumentation;
+            }
             Call.mutate1(inst,
                          CALL,
                          null,
@@ -385,6 +423,17 @@ public final class ExpandRuntimeServices
         case REF_ASTORE_opcode: {
           if (NEEDS_OBJECT_ASTORE_BARRIER) {
             RVMMethod target = Entrypoints.objectArrayWriteBarrierMethod;
+            
+            // Octet: If the instruction might need an Octet barrier, let's leave the instruction alone and instead insert a "pre-barrier"
+            boolean usePreBarrier = mightNeedOctetBarrier(inst);
+            if (usePreBarrier) {
+              // Don't add Jikes write barriers twice
+              if (instsWithWritePreBarrier.contains(inst)) {
+                break;
+              }
+              target = Entrypoints.objectArrayWritePreBarrierMethod;
+            }
+            
             Instruction wb =
                 Call.create3(CALL,
                              null,
@@ -396,7 +445,15 @@ public final class ExpandRuntimeServices
                              AStore.getValue(inst).copy());
             wb.bcIndex = RUNTIME_SERVICES_BCI;
             wb.position = inst.position;
-            inst.replace(wb);
+            
+            // Octet: If inserting a pre-barrier, then don't replace the instruction
+            if (usePreBarrier) {
+              inst.insertBefore(wb);
+              instsWithWritePreBarrier.add(inst);
+            } else {
+              inst.replace(wb);
+            }
+
             next = wb.prevInstructionInCodeOrder();
             if (ir.options.H2L_INLINE_WRITE_BARRIER) {
               inline(wb, ir, true);
@@ -453,6 +510,9 @@ public final class ExpandRuntimeServices
 
         case REF_ALOAD_opcode: {
           if (NEEDS_OBJECT_ALOAD_BARRIER) {
+            // Octet: we can't support barriers that aren't heap reference write barriers
+            if (VM.VerifyAssertions) { VM._assert(false); }
+            
             RVMMethod target = Entrypoints.objectArrayReadBarrierMethod;
             Instruction rb =
               Call.create2(CALL,
@@ -480,6 +540,17 @@ public final class ExpandRuntimeServices
               RVMField field = fieldRef.peekResolvedField();
               if (field == null || !field.isUntraced()) {
                 RVMMethod target = Entrypoints.objectFieldWriteBarrierMethod;
+                
+                // Octet: If the instruction might need an Octet barrier, let's leave the instruction alone and instead insert a "pre-barrier"
+                boolean usePreBarrier = mightNeedOctetBarrier(inst);
+                if (usePreBarrier) {
+                  // Don't add Jikes write barriers twice
+                  if (instsWithWritePreBarrier.contains(inst)) {
+                    break;
+                  }
+                  target = Entrypoints.objectFieldWritePreBarrierMethod;
+                }
+                
                 Instruction wb =
                     Call.create4(CALL,
                                  null,
@@ -492,7 +563,15 @@ public final class ExpandRuntimeServices
                                  IRTools.IC(fieldRef.getId()));
                 wb.bcIndex = RUNTIME_SERVICES_BCI;
                 wb.position = inst.position;
-                inst.replace(wb);
+                
+                // Octet: If inserting a pre-barrier, then don't replace the instruction
+                if (usePreBarrier) {
+                  inst.insertBefore(wb);
+                  instsWithWritePreBarrier.add(inst);
+                } else {
+                  inst.replace(wb);
+                }
+                
                 next = wb.prevInstructionInCodeOrder();
                 if (ir.options.H2L_INLINE_WRITE_BARRIER) {
                   inline(wb, ir, true);
@@ -532,6 +611,9 @@ public final class ExpandRuntimeServices
 
         case GETFIELD_opcode: {
           if (NEEDS_OBJECT_GETFIELD_BARRIER) {
+            // Octet: we can't support barriers that aren't heap reference write barriers
+            if (VM.VerifyAssertions) { VM._assert(false); }
+            
             LocationOperand loc = GetField.getLocation(inst);
             FieldReference fieldRef = loc.getFieldRef();
             if (GetField.getResult(inst).getType().isReferenceType()) {
@@ -560,6 +642,9 @@ public final class ExpandRuntimeServices
 
         case PUTSTATIC_opcode: {
           if (NEEDS_OBJECT_PUTSTATIC_BARRIER) {
+            // Octet: we can't support barriers that aren't heap reference write barriers
+            if (VM.VerifyAssertions) { VM._assert(false); }
+            
             LocationOperand loc = PutStatic.getLocation(inst);
             FieldReference field = loc.getFieldRef();
             if (!field.getFieldContentsType().isPrimitiveType()) {
@@ -585,7 +670,27 @@ public final class ExpandRuntimeServices
         break;
 
         case GETSTATIC_opcode: {
+          // Octet: Change System.out/err/in to VMSystem.out/err/in if in the VM context.
+          if (inst.position.getMethod().getStaticContext() == Context.VM_CONTEXT) { 
+            FieldReference oldFieldRef = GetStatic.getLocation(inst).getFieldRef();
+            FieldReference newFieldRef = oldFieldRef; 
+            if (oldFieldRef == Entrypoints.systemOut) {
+              newFieldRef = Entrypoints.vmSystemOut;
+            } else if (oldFieldRef == Entrypoints.systemErr) {
+              newFieldRef = Entrypoints.vmSystemErr;
+            } else if (oldFieldRef == Entrypoints.systemIn) { 
+              newFieldRef = Entrypoints.vmSystemIn;
+            }
+            if (newFieldRef != oldFieldRef) {
+              GetStatic.setLocation(inst, new LocationOperand(newFieldRef));
+              GetStatic.setOffset(inst, IRTools.AC(newFieldRef.peekResolvedField().getOffset()));
+            }
+          }
+          
           if (NEEDS_OBJECT_GETSTATIC_BARRIER) {
+            // Octet: we can't support barriers that aren't heap reference write barriers
+            if (VM.VerifyAssertions) { VM._assert(false); }
+            
             LocationOperand loc = GetStatic.getLocation(inst);
             FieldReference field = loc.getFieldRef();
             if (!field.getFieldContentsType().isPrimitiveType()) {
@@ -627,6 +732,19 @@ public final class ExpandRuntimeServices
     ir.gc.close();
   }
 
+  /** Octet: Check whether an instruction needs to be instrumented by Octet. */
+  @Inline
+  boolean mightNeedOctetBarrier(Instruction inst) {
+    if (Octet.getConfig().insertBarriers() &&
+        Octet.getConfig().instrumentOptimizingCompiler()) {
+      if (inst.isPossibleSharedMemoryAccess()) {
+        if (VM.VerifyAssertions) { VM._assert(Octet.getClientAnalysis().useLateOptInstrumentation()); } 
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * Inline a call instruction
    */
@@ -668,6 +786,9 @@ public final class ExpandRuntimeServices
    * @param ir the IR
    */
   private void primitiveArrayStoreHelper(RVMMethod target, Instruction inst, Instruction next, IR ir) {
+    // Octet: we can't support barriers that aren't heap reference write barriers
+    if (VM.VerifyAssertions) { VM._assert(false); }
+    
     Instruction wb =
       Call.create3(CALL,
                    null,
@@ -694,6 +815,9 @@ public final class ExpandRuntimeServices
    * @param ir the IR
    */
   private void primitiveObjectFieldStoreHelper(RVMMethod target, Instruction inst, Instruction next, IR ir, FieldReference fieldRef) {
+    // Octet: we can't support barriers that aren't heap reference write barriers
+    if (VM.VerifyAssertions) { VM._assert(false); }
+    
     Instruction wb =
       Call.create4(CALL,
                    null,
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/inlining/DefaultInlineOracle.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/inlining/DefaultInlineOracle.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/inlining/DefaultInlineOracle.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/inlining/DefaultInlineOracle.java	2014-04-03 17:43:43.985673714 -0400
@@ -179,7 +179,8 @@ public final class DefaultInlineOracle e
               RVMClass[] subClasses = klass.getSubClasses();
               if (subClasses.length != 1) break; // multiple subclasses => multiple targets
               RVMMethod singleImpl =
-                  subClasses[0].findDeclaredMethod(staticCallee.getName(), staticCallee.getDescriptor());
+                  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+                  subClasses[0].findDeclaredMethod(staticCallee.getName(), staticCallee.getDescriptor(), staticCallee.getResolvedContext());
               if (singleImpl != null && !singleImpl.isAbstract()) {
                 // found something
                 if (verbose) VM.sysWriteln("\tsingle impl of abstract method");
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/inlining/InlineTools.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/inlining/InlineTools.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/inlining/InlineTools.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/inlining/InlineTools.java	2014-04-03 17:43:43.987673720 -0400
@@ -91,7 +91,8 @@ public abstract class InlineTools implem
       }
       while (!s.isEmpty()) {
         RVMClass subClass = s.pop();
-        if (subClass.findDeclaredMethod(callee.getName(), callee.getDescriptor()) != null) {
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
+        if (subClass.findDeclaredMethod(callee.getName(), callee.getDescriptor(), callee.getResolvedContext()) != null) {
           return false;        // found an overridding method
         }
         subClasses = subClass.getSubClasses();
@@ -222,7 +223,8 @@ public abstract class InlineTools implem
     // TODO: clean this hack up
     // Hack to inline java.lang.VMSystem.arraycopy in the case that
     // arg 0 isn't an Object
-    if (callee == Entrypoints.sysArrayCopy) {
+    // Octet: Static cloning: Simplified by just checking for a method reference instead of a resolved method.
+    if (callee.getMemberRef() == Entrypoints.sysArrayCopy) {
       Operand src = Call.getParam(state.getCallInstruction(), 0);
       return src.getType() != TypeReference.JavaLangObject;
     }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/inlining/InterfaceHierarchy.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/inlining/InterfaceHierarchy.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/inlining/InterfaceHierarchy.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/inlining/InterfaceHierarchy.java	2014-04-03 17:43:43.987673720 -0400
@@ -119,7 +119,8 @@ public class InterfaceHierarchy {
     Atom desc = foo.getDescriptor();
 
     for (RVMClass klass : classes) {
-      RVMMethod m = klass.findDeclaredMethod(name, desc);
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      RVMMethod m = klass.findDeclaredMethod(name, desc, foo.getResolvedContext());
       if (firstMethod == null) {
         firstMethod = m;
       }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/ia32/MachineSpecificIRIA.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/ia32/MachineSpecificIRIA.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/ia32/MachineSpecificIRIA.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/ia32/MachineSpecificIRIA.java	2014-04-03 17:43:44.488675366 -0400
@@ -75,7 +75,9 @@ public abstract class MachineSpecificIRI
         case GET_CURRENT_PROCESSOR_opcode:
           return true;
         default:
-          throw new OptimizingCompilerException("SimpleEscape: Unexpected " + instruction);
+          // Octet: changed this code to handle other instructions encountered in low-level IR.
+          return true;
+          //throw new OptimizingCompilerException("SimpleEscape: Unexpected " + instruction);
       }
     }
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/Instruction.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/Instruction.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/Instruction.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/Instruction.java	2014-04-03 17:43:44.543675546 -0400
@@ -284,6 +284,15 @@ public final class Instruction implement
     if (isGCPoint()) {
       result.setCharAt(1, 'G');
     }
+    // Octet: print instruction properties
+    if (isPossibleSharedMemoryAccess()) {
+      if (VM.VerifyAssertions) { VM._assert(!hasRedundantBarrier()); }
+      // access to potentially shared object
+      result.setCharAt(2, 'S');
+    } else if (hasRedundantBarrier()) {
+      // access to redundant barrier
+      result.setCharAt(2, 'R');
+    }
 
     if (operator == LABEL) {
       result.append("LABEL").append(Label.getBlock(this).block.getNumber());
@@ -1200,6 +1209,33 @@ public final class Instruction implement
     operatorInfo |= (OI_PEI_VALID | OI_GC_VALID);
   }
 
+  // Octet: instrumentation selection helper methods
+  
+  /** Mark as an instruction that Octet cares about (non-VM, non-final, non-escaping, non-redundant scalar/array/static access. */
+  public void markAsPossibleSharedMemoryAccess() {
+    setMark1();
+  }
+
+  /** Clear as an instruction that Octet cares about (non-VM, non-final, non-escaping, non-redundant scalar/array/static access. */
+  public void clearAsPossibleSharedMemoryAccess() {
+    clearMark1();
+  }
+
+  /** Is this an instruction that Octet cares about (non-VM, non-final, non-escaping, non-redundant scalar/array/static access? */
+  public boolean isPossibleSharedMemoryAccess() {
+    return isMarked1();
+  }
+
+  /** Mark the instruction as accessing an object that is thread local? */
+  public void markHasRedundantBarrier() {
+    setMark2();
+  }
+  
+  /** Is this an instruction that accesses an object that Octet decided is thread local? */
+  public boolean hasRedundantBarrier() {
+    return isMarked2();
+  }
+
   /**
    * Is the first mark bit of the instruction set?
    *
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/operand/MethodOperand.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/operand/MethodOperand.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/operand/MethodOperand.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/operand/MethodOperand.java	2014-04-03 17:43:44.445675225 -0400
@@ -260,8 +260,9 @@ public final class MethodOperand extends
    * Refine the target information. Used to reduce the set of
    * targets for an invokevirtual.
    */
-  public void refine(RVMType targetClass) {
-    this.target = targetClass.findVirtualMethod(memRef.getName(), memRef.getDescriptor());
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
+  public void refine(RVMType targetClass, int context) {
+    this.target = targetClass.findVirtualMethod(memRef.getName(), memRef.getDescriptor(), context);
     setPreciseTarget();
   }
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/operand/ObjectConstantOperand.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/operand/ObjectConstantOperand.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ir/operand/ObjectConstantOperand.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ir/operand/ObjectConstantOperand.java	2014-04-03 17:43:44.445675225 -0400
@@ -15,9 +15,12 @@ package org.jikesrvm.compilers.opt.ir.op
 import org.jikesrvm.VM;
 import org.jikesrvm.classloader.Atom;
 import org.jikesrvm.classloader.BootstrapClassLoader;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.TypeReference;
 import org.vmmagic.unboxed.Offset;
 import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.objectmodel.ObjectModel;
+import org.jikesrvm.runtime.Magic;
 
 /**
  * Represents a constant object operand (for example, from an
@@ -97,6 +100,13 @@ public class ObjectConstantOperand exten
 
   @Override
   public boolean similar(Operand op) {
+    // Octet: Avoid calling equals() on an application object, since that can trigger an Octet barrier from the compiler thread.
+    // Instead, mimic Object.equals().
+    if (VM.runningVM) {
+      if (Context.isApplicationPrefix(ObjectModel.getObjectType(value).getTypeRef())) {
+        return (op instanceof ObjectConstantOperand) &&  (value == ((ObjectConstantOperand) op).value);   
+      }
+    }
     return (op instanceof ObjectConstantOperand) && value.equals(((ObjectConstantOperand) op).value);
   }
 
@@ -107,6 +117,13 @@ public class ObjectConstantOperand exten
    */
   @Override
   public String toString() {
+    // Octet: Avoid calling toString() on an application object, since that can trigger an Octet barrier from the compiler thread.
+    // Instead, mimic Object.toString().
+    if (VM.runningVM) {
+      if (Context.isApplicationPrefix(ObjectModel.getObjectType(value).getTypeRef())) {
+        return "object \"" + value.getClass().getName() + "@" + Integer.toHexString(ObjectModel.getObjectHashCode(value)) + "\"";
+      }
+    }
     return "object \"" + value + "\"";
   }
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ObjectsAccessFacts.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ObjectsAccessFacts.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/ObjectsAccessFacts.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/ObjectsAccessFacts.java	2014-04-03 17:43:44.732676169 -0400
@@ -0,0 +1,236 @@
+package org.jikesrvm.compilers.opt;
+
+import java.util.HashMap;
+import java.util.Set;
+
+import org.jikesrvm.compilers.opt.ir.IR;
+
+/**
+ * Implements a lattice for keeping data flow facts for objects accessed inside
+ * an {@link IR}
+ * 
+ * @author Meisam
+ */
+public class ObjectsAccessFacts implements Cloneable {
+  
+  private static final int INITAL_CAPACITY = 4;
+
+  /**
+   * Maps each object accessed object to {@code RedundantBarrieresLatticeType}
+   */
+  private HashMap<Object, BarrierType> objectBarrierInfo;
+
+  /**
+   * Constructs a new HashMap
+   */
+  public ObjectsAccessFacts() {
+    this.objectBarrierInfo = new HashMap<Object, BarrierType>(INITAL_CAPACITY);
+  }
+
+  /**
+   * Adds a fact about the barrier that are redundant for a given object
+   * 
+   * @param accessedObject
+   *          The given object
+   * @param barrierType
+   *          The type of barrier that would be redundant
+   */
+  public void updateFact(final Object accessedObject,
+      final BarrierType barrierType) {
+    // The concurrent hash map does not allow null key.
+    if (accessedObject != null) {
+      if (barrierType == BarrierType.BOTTOM) {
+        objectBarrierInfo.remove(accessedObject);
+      } else {
+        objectBarrierInfo.put(accessedObject, barrierType);
+      }
+    }
+  }
+  
+  public void updateFact(HashMap<Object, BarrierType> newObjectBarrierInfo, final Object accessedObject,
+      final BarrierType barrierType) {
+    // The concurrent hash map does not allow null key.
+    if (accessedObject != null) {
+      if (barrierType == BarrierType.BOTTOM) {
+        newObjectBarrierInfo.remove(accessedObject);
+      } else {
+        newObjectBarrierInfo.put(accessedObject, barrierType);
+      }
+    }
+  }
+
+  /**
+   * Returns the fact for the given object.
+   * <p>
+   * NOTE: This does not return null, it returns BOTTOM instead of null.
+   * 
+   * @param accessedObject
+   *          The given object
+   * @return the fact about barriers for the given object
+   */
+  public BarrierType lookupFact(final Object accessedObject) {
+    BarrierType barrierType = objectBarrierInfo.get(accessedObject);
+    return (barrierType == null) ? BarrierType.BOTTOM : barrierType;
+  }
+
+  // Octet: Later: rename this method to setBottom?
+  public void clearFact(final Object accessedObject) {
+    objectBarrierInfo.remove(accessedObject);
+  }
+
+  /**
+   * Sets all facts to BOTTOM
+   */
+  public void clearAllFacts() {
+    objectBarrierInfo.clear();
+  }
+
+  /**
+   * Keeps all top facts and sets all other facts to BOTTOM.
+   */
+  public void clearAllNonTopFacts() {
+    HashMap<Object, BarrierType> newMap = new HashMap<Object, BarrierType>(INITAL_CAPACITY);
+
+    for (Object object : objectBarrierInfo.keySet()) {
+      BarrierType barrierType = objectBarrierInfo.get(object);
+      if (barrierType == BarrierType.TOP) {
+        newMap.put(object, BarrierType.TOP);
+      }
+    }
+    objectBarrierInfo = newMap;
+  }
+
+  /** Get all the objects with non-bottom facts, i.e., all the objects in the facts map. */
+  public Set<Object> getObjects() {
+    return objectBarrierInfo.keySet();
+  }
+  
+  /**
+   * Promotes the barrier of the given object by updating the barrier with the
+   * supremum of the object barrier and the given barrier.
+   * 
+   * @param object
+   *          The given object
+   * @param promotedBarrier
+   *          the given barrier
+   */
+  public void updateToSupremumBarrier(Object object, BarrierType promotedBarrier) {
+    BarrierType barrierType = lookupFact(object);
+    if (barrierType.isLower(promotedBarrier)) {
+      updateFact(object, promotedBarrier);
+    }
+  }
+
+  /**
+   * Updates the barrier of the given object by updating the barrier with the
+   * infimum of the object barrier and the given barrier.
+   * 
+   * @param object
+   *          The given object
+   * @param promotedBarrier
+   *          the given barrier
+   */
+  public void updateToInfimumBarrier(Object object, BarrierType relegatedBarrier) {
+    BarrierType barrierType = lookupFact(object);
+    if (barrierType.isHigher(relegatedBarrier)) {
+      updateFact(object, relegatedBarrier);
+    }
+  }
+
+  public boolean isWriteBarrierRedundant(final Object accessedObject) {
+    return lookupFact(accessedObject).isHigher(BarrierType.WRITE);
+  }
+
+  public boolean isReadBarrierRedundant(final Object accessedObject) {
+    return lookupFact(accessedObject).isHigher(BarrierType.READ);
+
+  }
+
+  /**
+   * Meets the facts in this instance with the facts in the given
+   * ObjectsAccessFacts
+   * 
+   * @param otherFacts
+   *          the given ObjectsAccessFacts
+   */
+  public void meet(final ObjectsAccessFacts otherFacts) {
+    HashMap<Object, BarrierType> newObjectBarrierInfo = new HashMap<Object, BarrierType>(INITAL_CAPACITY);
+    for (Object object : this.objectBarrierInfo.keySet()) {
+      BarrierType thisBarrier = this.lookupFact(object);
+      BarrierType otherBarrier = otherFacts.lookupFact(object);
+      BarrierType infimumBarrier = thisBarrier.infimum(otherBarrier);
+      //As we're quierying the hash map here while at the same time we may also update the hash map, to avoid a concurrent update exception, we need to choose concurrentHashMap.
+      newObjectBarrierInfo.put(object,infimumBarrier);
+    }
+    this.objectBarrierInfo = newObjectBarrierInfo;
+  }
+
+  /**
+   * Joins facts in this instance with the facts in the given
+   * {@link ObjectsAccessFacts}
+   * 
+   * @param otherFacts
+   *          the given {@link ObjectsAccessFacts}
+   */
+  public void join(final ObjectsAccessFacts otherFacts) {
+    Set<Object> otherFactKeys = otherFacts.objectBarrierInfo.keySet();
+
+    for (Object object : this.objectBarrierInfo.keySet()) {
+      BarrierType thisBarrier = this.objectBarrierInfo.get(object);
+      BarrierType otherBarrier = otherFacts.objectBarrierInfo.get(object);
+
+      BarrierType infimumBarrier = thisBarrier.supremum(otherBarrier);
+      //depricated! It is unclear the semantic of what will happen enumerating a hash map while at the same inserting something into that hasha map.
+      updateFact(otherFactKeys, infimumBarrier);
+
+    }
+  }
+
+  @Override
+  protected ObjectsAccessFacts clone() {
+    try {
+      ObjectsAccessFacts clone = (ObjectsAccessFacts) super.clone();
+      clone.objectBarrierInfo = new HashMap<Object, BarrierType>(this.objectBarrierInfo);
+      return clone;
+    } catch (CloneNotSupportedException ex) {
+      throw new InternalError();
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "[ObjectsAccessFacts: " + objectBarrierInfo.toString() + "]";
+  }
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see java.lang.Object#equals(java.lang.Object)
+   */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    }
+
+    // Octet: TODO later: Meisam: Mike suggests that I change this to
+    // assertions.
+    if (o == null) {
+      return false;
+    }
+    if (!(o instanceof ObjectsAccessFacts)) {
+      return false;
+    }
+
+    ObjectsAccessFacts otherFacts = (ObjectsAccessFacts) o;
+    return this.objectBarrierInfo.equals(otherFacts.objectBarrierInfo);
+  }
+
+  /*
+   * @see java.lang.Object#hashCode()
+   */
+  @Override
+  public int hashCode() {
+    return objectBarrierInfo.hashCode();
+  }
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/OctetOptInstr.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/OctetOptInstr.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/OctetOptInstr.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/OctetOptInstr.java	2014-04-03 17:43:43.925673516 -0400
@@ -0,0 +1,777 @@
+package org.jikesrvm.compilers.opt;
+
+import static org.jikesrvm.compilers.opt.ir.Operators.CALL;
+import static org.jikesrvm.compilers.opt.ir.Operators.REF_AND;
+import static org.jikesrvm.compilers.opt.ir.Operators.INT_AND;
+import static org.jikesrvm.compilers.opt.ir.Operators.INT_MOVE;
+import static org.jikesrvm.compilers.opt.ir.Operators.INT_IFCMP;
+
+import java.util.Set;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.compilers.opt.driver.CompilerPhase;
+import org.jikesrvm.compilers.opt.hir2lir.ConvertToLowLevelIR;
+import org.jikesrvm.compilers.opt.inlining.InlineDecision;
+import org.jikesrvm.compilers.opt.inlining.Inliner;
+import org.jikesrvm.compilers.opt.ir.ALoad;
+import org.jikesrvm.compilers.opt.ir.AStore;
+import org.jikesrvm.compilers.opt.ir.BasicBlock;
+import org.jikesrvm.compilers.opt.ir.Binary;
+import org.jikesrvm.compilers.opt.ir.Call;
+import org.jikesrvm.compilers.opt.ir.GetField;
+import org.jikesrvm.compilers.opt.ir.GetStatic;
+import org.jikesrvm.compilers.opt.ir.Goto;
+import org.jikesrvm.compilers.opt.ir.IR;
+import org.jikesrvm.compilers.opt.ir.IRTools;
+import org.jikesrvm.compilers.opt.ir.IfCmp;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.compilers.opt.ir.Load;
+import org.jikesrvm.compilers.opt.ir.Move;
+import org.jikesrvm.compilers.opt.ir.Operators;
+import org.jikesrvm.compilers.opt.ir.PutField;
+import org.jikesrvm.compilers.opt.ir.PutStatic;
+import org.jikesrvm.compilers.opt.ir.Register;
+import org.jikesrvm.compilers.opt.ir.Store;
+import org.jikesrvm.compilers.opt.ir.operand.BranchOperand;
+import org.jikesrvm.compilers.opt.ir.operand.BranchProfileOperand;
+import org.jikesrvm.compilers.opt.ir.operand.ConditionOperand;
+import org.jikesrvm.compilers.opt.ir.operand.LocationOperand;
+import org.jikesrvm.compilers.opt.ir.operand.MethodOperand;
+import org.jikesrvm.compilers.opt.ir.operand.Operand;
+import org.jikesrvm.compilers.opt.ir.operand.RegisterOperand;
+import org.jikesrvm.objectmodel.MiscHeader;
+import org.jikesrvm.octet.CFGVisualization;
+import org.jikesrvm.octet.InstrDecisions;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.OctetState;
+import org.jikesrvm.octet.Site;
+import org.jikesrvm.octet.Stats;
+import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.util.HashSetRVM;
+import org.jikesrvm.velodrome.Velodrome;
+import org.vmmagic.unboxed.Offset;
+
+/** Octet: add read/write instrumentation */ 
+public class OctetOptInstr extends CompilerPhase {
+
+	// Velodrome: Made this protected so that it is visible in derived classes
+  protected static final boolean verbose = false;
+
+  /** Is this happening early or late in the compilation process (i.e., before or after 
+   * getfields and putfields are converted to loads and stores)? */
+  final boolean lateInstr;
+
+  static enum InliningType { NO_INLINING, JIKES_INLINER, INSERT_IR_INSTS };
+  final InliningType inliningType;
+  final RedundantBarrierRemover redundantBarrierRemover;
+
+  @Override
+  public String getName() {
+    return "Octet instrumentation";
+  }
+
+  public OctetOptInstr(boolean lateInstr, RedundantBarrierRemover redundantBarrierRemover) {
+    this.lateInstr = lateInstr;
+    this.redundantBarrierRemover = redundantBarrierRemover;
+    if (Octet.getConfig().inlineBarriers()) {
+      // Build-time option can force use of the Jikes inliner
+      if (Octet.getClientAnalysis().supportsIrBasedBarriers() &&
+          !Octet.getConfig().forceUseJikesInliner()) {
+        // Consistency check: Stats won't work with IR-based barriers
+        if (VM.VerifyAssertions) { VM._assert(!Octet.getConfig().stats()); }
+        this.inliningType = InliningType.INSERT_IR_INSTS;
+      } else if (!lateInstr) {
+        this.inliningType = InliningType.JIKES_INLINER;
+      } else {
+        this.inliningType = InliningType.NO_INLINING;
+      }
+    } else {
+      this.inliningType = InliningType.NO_INLINING;
+    }
+  }
+
+  // we'll reuse the previous instance of this class
+  public CompilerPhase newExecution(IR ir) {
+    return this;
+  }
+
+  @Override
+  public boolean shouldPerform(OptOptions options) {
+    if (Octet.getConfig().insertBarriers() && Octet.getConfig().instrumentOptimizingCompiler()) {
+      // Build-time options can force early instrumentation and/or use of the Jikes inliner, which requires early instrumentation
+      if (Octet.getClientAnalysis().useLateOptInstrumentation() &&
+          !Octet.getConfig().forceEarlyInstrumentation() &&
+          !Octet.getConfig().forceUseJikesInliner()) {
+        return lateInstr;
+      } else {
+        return !lateInstr;
+      }
+    }
+    return false;
+  }
+
+  /** For debugging purposes. See makeRedundantBarriersSafe(). */
+  protected HashSetRVM<Instruction> slowPathsInstrumented;
+
+  @Override
+  public void perform(IR ir) {
+
+    if(ir.options.VISUALIZE_CFG) {
+      CFGVisualization cfg = new CFGVisualization(ir, "beforeOctet");
+      cfg.visualizeCFG(ir);
+    }
+
+    if (VM.VerifyAssertions) {
+      slowPathsInstrumented = new HashSetRVM<Instruction>();
+    }
+
+    HashSetRVM<Instruction> callsToInline = null;
+    if (inliningType == InliningType.JIKES_INLINER) {
+      ir.gc.resync(); // resync generation context; needed since Jikes inlining may occur
+      callsToInline = new HashSetRVM<Instruction>();
+    }
+
+    if (verbose) {
+      System.out.println("Method before: " + ir.getMethod());
+      ir.printInstructions();
+    }
+
+    for (Instruction inst = ir.firstInstructionInCodeOrder(); inst != null; inst = inst.nextInstructionInCodeOrder()) {
+      if (inst.isPossibleSharedMemoryAccess() || (Octet.getClientAnalysis().instrInstructionHasRedundantBarrier(inst))) {
+        instrumentInst(inst, callsToInline, ir);
+        inst.clearAsPossibleSharedMemoryAccess();
+      } else {
+        // Use this method to instrument any additional instruction types
+        // Instructions with possible shared memory accesses probably will not require any further form of 
+        // instrumentation, so an else should suffice and would minimize compares
+        instrumentOtherInstTypes(inst, callsToInline, ir);
+      }
+    }
+
+    if (verbose) {
+      System.out.println("Method after: " + ir.getMethod());
+      ir.printInstructions();
+    }
+
+    if (inliningType == InliningType.JIKES_INLINER) {
+      for (Instruction call : callsToInline) {
+        Instruction inst = call.nextInstructionInCodeOrder();
+        // Setting no callee exceptions might be incorrect for analyses that
+        // want to throw exceptions out of the slow path, so allow analyses to override this.
+        // Octet: TODO: trying this -- does it help STM?
+        inline(call, ir, !Octet.getClientAnalysis().barriersCanThrowExceptions());
+        // Make optimistic RBA safe by executing barriers for recently acquired objects.
+        if (!inst.hasRedundantBarrier() || !Octet.getConfig().isFieldSensitiveAnalysis()) {
+          makeRedundantBarriersSafe(inst, null, ir);
+        }
+      }
+    }
+
+    // Check that all instructions were instrumented.  While it seems like iterating over
+    // all instructions above should accomplish this, the facts that instructions get inserted --
+    // and particularly because BBs get split -- can cause problems, particularly if
+    // the "next" instruction is determined prior to inserting barrier code (which is avoided above).
+    if (VM.VerifyAssertions) {
+      if (!Octet.getConfig().isFieldSensitiveAnalysis()) {
+        for (Instruction inst = ir.firstInstructionInCodeOrder(); inst != null; inst = inst.nextInstructionInCodeOrder()) {
+          VM._assert(!inst.isPossibleSharedMemoryAccess());
+        }
+      }
+    }
+    if(ir.options.VISUALIZE_CFG) {
+      CFGVisualization cfgAfter = new CFGVisualization(ir, "afterOctet");
+      cfgAfter.visualizeCFG(ir);
+    }
+  }  
+
+  /**
+   * Classes deriving from OctetOptInstr can override this method and choose whether to instrument additional instructions
+   * Does nothing by default
+   * @param inst
+   * @param callsToInline
+   * @param ir
+   */
+  public void instrumentOtherInstTypes(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir) {
+    // Do nothing.
+  }
+
+  protected boolean isSpecializedMethod(IR ir) {
+    return Octet.getClientAnalysis().isSpecializedMethod(ir.getMethod());
+  }
+  
+  void instrumentInst(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir) {
+    if (GetField.conforms(inst) || PutField.conforms(inst)) {
+      if (VM.VerifyAssertions) { VM._assert(!lateInstr); }
+      instrumentScalarAccess(inst, callsToInline, ir);
+    } else if (ALoad.conforms(inst) || AStore.conforms(inst)) {
+      // Velodrome: Avoiding instrumenting array accesses
+      if (Velodrome.instrumentArrays()) {
+        instrumentArrayAccess(inst, callsToInline, ir);
+      }
+    } else if (GetStatic.conforms(inst) || PutStatic.conforms(inst)) {
+      if (VM.VerifyAssertions) { VM._assert(!lateInstr); }
+      instrumentStaticAccess(inst, callsToInline, ir);
+    } else if (Load.conforms(inst) || Store.conforms(inst)) {
+      if (VM.VerifyAssertions) { VM._assert(lateInstr); }
+      Operand tempRef = Load.conforms(inst) ? Load.getAddress(inst) : Store.getAddress(inst);
+      boolean isStatic = tempRef.isIntConstant() && tempRef.asIntConstant().value == Magic.getTocPointer().toInt();
+      if (isStatic) {
+        instrumentStaticAccess(inst, callsToInline, ir);
+      } else {
+        instrumentScalarAccess(inst, callsToInline, ir);
+      }
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(false); }
+    }
+  }
+
+  void instrumentScalarAccess(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir) {
+    boolean isRead;
+    LocationOperand loc;
+    Operand ref = null;
+    if (!lateInstr) {
+      isRead = GetField.conforms(inst);
+      loc = isRead ? GetField.getLocation(inst) : PutField.getLocation(inst);
+      ref = isRead ? GetField.getRef(inst) : PutField.getRef(inst);
+    } else {
+      isRead = Load.conforms(inst);
+      loc = isRead ? Load.getLocation(inst) : Store.getLocation(inst);
+      if (VM.VerifyAssertions) { VM._assert(loc != null && loc.isFieldAccess()); }
+      Operand tempRef = isRead ? Load.getAddress(inst) : Store.getAddress(inst);
+      if (VM.VerifyAssertions) { VM._assert(!(tempRef.isIntConstant() && tempRef.asIntConstant().value == Magic.getTocPointer().toInt())); }
+      ref = tempRef;
+    }
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    if (VM.VerifyAssertions && isResolved) { VM._assert(!field.isStatic()); }
+
+    int fieldInfo = 0;
+    if (InstrDecisions.passFieldInfo()) {
+      // Octet: TODO: we could still call the resolved barrier if doing late instrumentation,
+      // since the offset will be in a virtual register
+      if (isResolved && InstrDecisions.useFieldOffset()) {
+        fieldInfo = getFieldOffset(field);
+      } else {
+        fieldInfo = fieldRef.getId();
+      }
+    }
+
+    NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(ir.getMethod(), isRead, true, isResolved, false, inst.hasRedundantBarrier(), isSpecializedMethod(ir));
+    Instruction barrierCall = Call.create2(CALL,
+        null,
+        IRTools.AC(barrierMethod.getOffset()),
+        MethodOperand.STATIC(barrierMethod),
+        ref.copy(),
+        IRTools.IC(fieldInfo));
+    barrierCall.position = inst.position;
+    barrierCall.bcIndex = inst.bcIndex;
+    // Octet: LATER: try this
+    /*
+    if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+      barrierCall.markAsNonPEI();
+    }
+     */
+    finishParams(inst, fieldRef, barrierCall);
+    insertBarrier(barrierCall, inst, isRead, ref, field, isResolved, callsToInline, ir);
+  }
+
+  void instrumentArrayAccess(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir) {
+    boolean isRead = ALoad.conforms(inst);
+    LocationOperand loc = isRead ? ALoad.getLocation(inst) : AStore.getLocation(inst);
+    if (VM.VerifyAssertions) { VM._assert(loc.isArrayAccess()); }
+    Operand ref = isRead ? ALoad.getArray(inst) : AStore.getArray(inst);
+    Operand index = isRead ? ALoad.getIndex(inst) : AStore.getIndex(inst);
+
+    NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(ir.getMethod(), isRead, false, true, false, inst.hasRedundantBarrier(), isSpecializedMethod(ir));
+    Instruction barrierCall = Call.create2(CALL,
+        null,
+        IRTools.AC(barrierMethod.getOffset()),
+        MethodOperand.STATIC(barrierMethod),
+        ref.copy(),
+        index.copy());
+    barrierCall.position = inst.position;
+    barrierCall.bcIndex = inst.bcIndex;
+    // Octet: LATER: try this
+    /*
+    if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+      barrierCall.markAsNonPEI();
+    }
+     */
+    finishParams(inst, null, barrierCall);
+    insertBarrier(barrierCall, inst, isRead, ref, null, true, callsToInline, ir);
+  }
+
+  void instrumentStaticAccess(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir) {
+    boolean isRead;
+    LocationOperand loc;
+    if (!lateInstr) {
+      isRead = GetStatic.conforms(inst);
+      loc = isRead ? GetStatic.getLocation(inst) : PutStatic.getLocation(inst);
+    } else {
+      isRead = Load.conforms(inst);
+      loc = isRead ? Load.getLocation(inst) : Store.getLocation(inst);
+      if (VM.VerifyAssertions) { VM._assert(loc.isFieldAccess()); }
+      Operand tempRef = isRead ? Load.getAddress(inst) : Store.getAddress(inst);
+      if (VM.VerifyAssertions) { VM._assert(tempRef.isIntConstant() && tempRef.asIntConstant().value == Magic.getTocPointer().toInt()); }
+    }
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    if (VM.VerifyAssertions && isResolved) { VM._assert(field.isStatic()); }
+
+    int fieldInfo = 0;
+    if (InstrDecisions.passFieldInfo()) {
+      if (isResolved && InstrDecisions.useFieldOffset()) {
+        fieldInfo = getFieldOffset(field);
+      } else {
+        fieldInfo = fieldRef.getId();
+      }
+    }
+
+    NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(ir.getMethod(), isRead, true, isResolved, true, inst.hasRedundantBarrier(), isSpecializedMethod(ir));
+    Instruction barrierCall;
+    if (isResolved) {
+      barrierCall = Call.create2(CALL,
+          null,
+          IRTools.AC(barrierMethod.getOffset()),
+          MethodOperand.STATIC(barrierMethod),
+          IRTools.AC(field.getMetadataOffset()),
+          IRTools.IC(fieldInfo));
+    } else {
+      barrierCall = Call.create1(CALL,
+          null,
+          IRTools.AC(barrierMethod.getOffset()),
+          MethodOperand.STATIC(barrierMethod),
+          // need to pass the field ID even if field info isn't needed, since it's needed to get the metadata offset
+          IRTools.IC(fieldRef.getId()));
+    }
+    barrierCall.position = inst.position;
+    barrierCall.bcIndex = inst.bcIndex;
+    // Octet: LATER: try this
+    /*
+    if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+      barrierCall.markAsNonPEI();
+    }
+     */
+    finishParams(inst, fieldRef, barrierCall);
+    insertBarrier(barrierCall, inst, isRead, null, field, isResolved, callsToInline, ir);
+  }
+
+  /** Pass site and/or other client-specific parameters */
+  void finishParams(Instruction inst, FieldReference fieldRef, Instruction barrier) {
+    passSite(inst, barrier);
+    passExtra(inst, fieldRef, barrier);
+  }
+
+  void passSite(Instruction inst, Instruction barrier) {
+    int siteID = InstrDecisions.passSite() ? Site.getSite(inst) : 0;
+    addParam(barrier, IRTools.IC(siteID));
+  }
+
+  /** Client analyses can override this to add more parameters */
+  void passExtra(Instruction inst, FieldReference fieldRef, Instruction barrier) {
+  }
+
+  /** Helper method */
+  void addParam(Instruction call, Operand operand) {
+    int params = Call.getNumberOfParams(call);
+    Call.resizeNumberOfParams(call, params + 1);
+    Call.setParam(call, params, operand);
+  }
+
+  /** Client analyses can override this to provide customized field offset*/
+  protected int getFieldOffset(RVMField field) {
+    return field.getOffset().toInt();
+  }
+
+  void insertBarrier(Instruction barrierCall, Instruction inst, boolean isRead, Operand refOperand, RVMField field, boolean isResolved, HashSetRVM<Instruction> callsToInline, IR ir) {
+    // "Inline" by inserting IR instructions one-by-one, or insert a (possibly inlined) call
+    if (inliningType == InliningType.INSERT_IR_INSTS &&
+        // can't support IR-based barriers for unresolved statics
+        (isResolved || refOperand != null) &&
+        // just insert a call for infrequent instructions
+        !inst.getBasicBlock().getInfrequent()) {
+
+      insertIrBasedBarrier(inst, isRead, refOperand, field, barrierCall, ir, null, false, null, null, false);
+    } else {
+      insertCall(barrierCall, inst, isResolved, ir);
+
+      // Velodrome: TODO: Check performance impact for inlining barriers, this is disabled in AVD
+      // Inline if using Jikes inliner
+      if (inliningType == InliningType.JIKES_INLINER &&
+          // only inline non-infrequent instructions
+          !inst.getBasicBlock().getInfrequent() &&
+          // only inline for resolved fields
+          isResolved) {
+        callsToInline.add(barrierCall);
+      } else {
+        // Make optimistic RBA safe by executing barriers for recently acquired objects
+        if (!inst.hasRedundantBarrier() || !Octet.getConfig().isFieldSensitiveAnalysis()) {
+          makeRedundantBarriersSafe(inst, barrierCall, ir);
+        }
+      }
+    }
+  }
+
+  /** Adds special barriers to make redundant barrier analysis safe. */
+  void makeRedundantBarriersSafe(Instruction inst, Instruction slowPath, IR ir) {
+    if (redundantBarrierRemover != null &&
+        redundantBarrierRemover.analysisLevel == RedundantBarrierRemover.AnalysisLevel.OPTIMISTIC_SAFE) {
+      // Only early instrumentation is currently supported.
+      if (VM.VerifyAssertions) { VM._assert(!lateInstr); }
+      if (slowPath == null) {
+        // Need to find slow path, since it was added via inlining
+        boolean done = false;
+        slowPath = inst;
+        do {
+          slowPath = slowPath.prevInstructionInCodeOrder();
+          if (Call.conforms(slowPath)) {
+            RVMMethod target = Call.getMethod(slowPath).getTarget();
+            done = (target == Entrypoints.octetReadSlowPathMethod ||
+                target == Entrypoints.octetWriteSlowPathMethod);
+          }
+        } while (!done);
+        // Octet: LATER: try this
+        /*
+        if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+          barrierCall.markAsNonPEI();
+        }
+         */
+      } else {
+        if (VM.VerifyAssertions) {
+          VM._assert(Call.conforms(slowPath));
+          RVMMethod target = Call.getMethod(slowPath).getTarget();
+          VM._assert(target == Entrypoints.octetReadSlowPathMethod ||
+              target == Entrypoints.octetWriteSlowPathMethod ||
+              // If the barrier isn't inlined, then the call might actually be to the fast path, so allow that, too
+              target.getDeclaringClass().equals(Entrypoints.octetFieldReadBarrierResolvedMethod.getDeclaringClass()));
+        }
+      }
+
+      // Check to make sure we found the right slow path
+      if (VM.VerifyAssertions) {
+        // Check that we haven't already instrumented this slow path
+        VM._assert(!slowPathsInstrumented.contains(slowPath));
+        slowPathsInstrumented.add(slowPath);
+        // Make sure all slow paths have been instrumented
+        for (Instruction temp = ir.firstInstructionInCodeOrder(); temp != null; temp = temp.nextInstructionInCodeOrder()) {
+          if (Call.conforms(temp)) {
+            RVMMethod target = Call.getMethod(temp).getTarget();
+            if (target == Entrypoints.octetReadSlowPathMethod ||
+                target == Entrypoints.octetWriteSlowPathMethod) {
+              VM._assert(slowPathsInstrumented.contains(temp));
+            }
+          }
+        }
+      }
+
+      // First see if there are any redundant objects here.
+      int redundantObjects = 0;
+      ObjectsAccessFacts facts = (ObjectsAccessFacts)inst.scratchObject;
+      Set<Object> objects = null;
+      if (facts != null) {
+        objects = facts.getObjects();
+        for (Object object : objects) {
+          BarrierType barrierType = facts.lookupFact(object);
+          // Only READ and WRITE facts need to have their states reacquired.  Not BOTTOM and not TOP. 
+          if (barrierType.equals(BarrierType.READ) || barrierType.equals(BarrierType.WRITE)) {
+            redundantObjects++;
+          }
+        }
+      }
+      Stats.optimisticRbaStaticLoopSize.incBin(redundantObjects);
+
+      // We need to have at least two redundant objects here to do any work.  If only the object for this barrier is redundant, then we don't need a retry loop.
+      if (redundantObjects > 1) {
+        // Initialize a boolean that keeps track of whether any slow paths have been taken
+        RegisterOperand needRetryBooleanOperand = ir.regpool.makeTempBoolean();
+        Instruction moveInst = Move.create(INT_MOVE, needRetryBooleanOperand, IRTools.IC(1));
+        slowPath.insertAfter(moveInst);
+        // Split above and below the Move instruction, to put it in its own basic block
+        BasicBlock slowPathBB = slowPath.getBasicBlock();
+        slowPathBB.splitNodeWithLinksAt(moveInst, ir);
+        BasicBlock loopBB = slowPathBB.splitNodeWithLinksAt(slowPath, ir);
+
+        // Now iterate over all facts in the set
+        for (Object object : objects) {
+          BarrierType barrierType = facts.lookupFact(object);
+          // Only READ and WRITE facts need to have their states reacquired.  Not BOTTOM and not TOP. 
+          if (barrierType.equals(BarrierType.READ) || barrierType.equals(BarrierType.WRITE)) {
+            RVMMethod barrierMethod = null;
+            Operand objectOperand = null;
+            if (object instanceof Register) {
+              objectOperand = new RegisterOperand((Register)object, TypeReference.JavaLangObject);
+              barrierMethod = barrierType.equals(BarrierType.READ) ? Entrypoints.octetReadObjectMethod : Entrypoints.octetWriteObjectMethod;
+            } else if (object instanceof FieldReference) {
+              objectOperand = IRTools.AC(((FieldReference)object).getResolvedField().getMetadataOffset());
+              barrierMethod = barrierType.equals(BarrierType.READ) ? Entrypoints.octetReadStaticMethod : Entrypoints.octetWriteStaticMethod;
+            } else {
+              if (VM.VerifyAssertions) { VM._assert(false, "Unexpected object type: " + object.getClass()); }
+            }
+            // Compute whether slow path was taken
+            RegisterOperand tookSlowPathOperand = ir.regpool.makeTempBoolean();
+            Instruction barrierCall = Call.create3(CALL,
+                tookSlowPathOperand.copyRO(),
+                IRTools.AC(barrierMethod.getOffset()),
+                MethodOperand.STATIC(barrierMethod),
+                objectOperand,
+                IRTools.IC(0),
+                IRTools.IC(0));
+            barrierCall.bcIndex = slowPath.bcIndex;
+            barrierCall.position = slowPath.position;
+            // Octet: LATER: try this
+            /*
+            if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+              barrierCall.markAsNonPEI();
+            }
+             */
+            loopBB.appendInstruction(barrierCall);
+            // Compute whether any slow path was taken
+            Instruction andInst = Binary.create(INT_AND, needRetryBooleanOperand.copyRO(), needRetryBooleanOperand.copyRO(), tookSlowPathOperand.copyRO());
+            andInst.bcIndex = slowPath.bcIndex;
+            andInst.position = slowPath.position;
+            loopBB.appendInstruction(andInst);
+          }
+        }
+        // Now add a back edge up to the top of the basic block (to repeat the slow path)
+        Instruction branchInst = IfCmp.create(INT_IFCMP, null, needRetryBooleanOperand.copyRO(), IRTools.IC(0), ConditionOperand.EQUAL(), loopBB.makeJumpTarget(), new BranchProfileOperand(BranchProfileOperand.NEVER));
+        loopBB.appendInstruction(branchInst);
+        loopBB.insertOut(loopBB);
+        ir.verify("After back edge");
+      }
+    }
+  }
+
+  Instruction insertIrBasedBarrier(Instruction inst, boolean isRead, Operand ref, RVMField field, Instruction slowPath, IR ir, BasicBlock targetAfterSlowPath, boolean insertRetry, BasicBlock thisBB, BasicBlock nextBB, boolean mayBeUnresolvedStatic) {
+    // split the current block and add a target block at the end of the IR
+    BasicBlock readCasesBB = null;
+    BasicBlock slowPathBB = null;
+    if (thisBB == null && nextBB == null) {
+      // Values are null means that these basic blocks have not been set.
+      // RsceAnalysis sets thisBB to the basic block which will have the fast path.
+      // When this method is called from RSCE analysis inst.getBasicBlock gives a basic block 
+      // in the region body (as inst in this case is the instruction for which the barrier was generated
+      // but RSCE requires splitting of the current basic block where header generation
+      // is at present, that is a basic block in region header. Thus the code below in this if-block is for normal Octet instrumentation
+      // and not for RSCE Analysis.
+      thisBB = inst.getBasicBlock();
+      nextBB = thisBB.splitNodeWithLinksAt(inst.prevInstructionInCodeOrder(), ir);
+      readCasesBB = isRead ? thisBB.createSubBlock(inst.bcIndex, ir, 0) : null;
+      slowPathBB = thisBB.createSubBlock(inst.bcIndex, ir, 0);
+    } else {
+      readCasesBB = isRead ? thisBB.createSubBlock(inst.bcIndex, ir, 0) : null;
+      slowPathBB = thisBB.createSubBlock(inst.bcIndex, ir, 0);
+      CFGVisualization.setColorForBasicBlocks(readCasesBB);
+      CFGVisualization.setColorForBasicBlocks(slowPathBB);
+    }
+
+    if (isRead) {
+      thisBB.insertOut(readCasesBB);
+      readCasesBB.insertOut(nextBB);
+      readCasesBB.insertOut(slowPathBB);
+    } else {
+      thisBB.insertOut(slowPathBB);
+    }
+    slowPathBB.insertOut(nextBB);
+    if (isRead) {
+      ir.cfg.addLastInCodeOrder(readCasesBB);
+    }
+    ir.cfg.addLastInCodeOrder(slowPathBB);
+
+    // populate the local basic block:
+    // get Octet metadata and compare to current thread
+
+    RegisterOperand metadataOperand = ir.regpool.makeTemp(TypeReference.Word);
+    Instruction loadInst;
+    if (ref == null) {
+      // static field (must be resolved, to get metadata offset) 
+      if(!mayBeUnresolvedStatic) {
+        // may be called from sce analysis for unresolved statics
+        if (VM.VerifyAssertions) { VM._assert(field != null && field.isStatic()); }
+      }
+      if (field != null && field.hasMetadataOffset()) {
+        Offset metadataOffset = field.getMetadataOffset();
+        loadInst = Load.create(Operators.PREPARE_INT,
+            metadataOperand,
+            ir.regpool.makeJTOCOp(ir, inst),
+            IRTools.AC(metadataOffset),
+            new LocationOperand(metadataOffset));
+        loadInst.position = inst.position;
+        loadInst.bcIndex = inst.bcIndex;
+        thisBB.appendInstruction(loadInst);
+
+      } else {
+        // Man: I think this block is for unresolved static, so it should not be reached.
+        // Besides, the method "getResolved" returns an address. We should have another load instruction to load from the returned address.
+        // Aritra: not reached by Octet but reached by Sce. Added the loadWord.
+        if (VM.VerifyAssertions) { VM._assert(VM.NOT_REACHED); }
+        NormalMethod getResolved = InstrDecisions.resolveStatic();
+        Instruction getResolvedField = Call.create1(CALL, metadataOperand, IRTools.AC(getResolved.getOffset()),
+            MethodOperand.STATIC(getResolved), Call.getParam(slowPath, 0));
+        getResolvedField.position = inst.position;
+        getResolvedField.bcIndex = inst.bcIndex;
+        thisBB.appendInstruction(getResolvedField);
+        if (lateInstr) {
+          ConvertToLowLevelIR.callHelper(getResolvedField, ir);
+        }
+      }
+
+    } else {
+      // Octet: TODO: should we use location operands for Octet metadata loads? That might help the optimzer know what's going on.
+      
+      // object field or array element
+      loadInst = Load.create(Operators.PREPARE_INT,
+          metadataOperand,
+          ref.copy(),
+          IRTools.AC(MiscHeader.OCTET_OFFSET),
+          null);
+      loadInst.position = inst.position;
+      loadInst.bcIndex = inst.bcIndex;
+      thisBB.appendInstruction(loadInst);
+    }
+
+
+
+
+    if(isRead && Octet.getClientAnalysis().checkBothExclStateIRBasedBarriers()) {
+      // insert And instruction followed by Ifcmp to check for both read and write exclusive state for reads
+      RegisterOperand andResult = ir.regpool.makeTemp(TypeReference.Word);
+      Instruction andIns = Binary.create(REF_AND, andResult, metadataOperand.copy(), IRTools.AC(OctetState.THREAD_MASK_FOR_EXCL_STATE.toAddress()));
+      andIns.position = inst.position;
+      andIns.bcIndex = inst.bcIndex;
+      Instruction cmpInst = IfCmp.create(Operators.REF_IFCMP,
+          ir.regpool.makeTempValidation(),
+          andResult.copy(),
+          ir.regpool.makeTROp(),
+          ConditionOperand.NOT_EQUAL(),
+          new BranchOperand((isRead ? readCasesBB : slowPathBB).firstInstruction()),
+          BranchProfileOperand.never());
+      cmpInst.position = inst.position;
+      cmpInst.bcIndex = inst.bcIndex;
+      thisBB.appendInstruction(andIns);
+      thisBB.appendInstruction(cmpInst);
+
+    } else { 
+
+      Instruction cmpInst = IfCmp.create(Operators.REF_IFCMP,
+          ir.regpool.makeTempValidation(),
+          metadataOperand.copy(),
+          ir.regpool.makeTROp(),
+          ConditionOperand.NOT_EQUAL(),
+          new BranchOperand((isRead ? readCasesBB : slowPathBB).firstInstruction()),
+          BranchProfileOperand.never());
+      cmpInst.position = inst.position;
+      cmpInst.bcIndex = inst.bcIndex;
+      thisBB.appendInstruction(cmpInst);
+
+    }
+
+    // rest of fast path (if any), followed by slow path, then a jump back to the handler
+
+    // Octet: LATER: This code doesn't actually check for RdEx.
+    // But it's correct since the "slow path" call is actually a call to the fast path barrier method, which checks for RdEx.
+
+    // for reads, check for RdSh
+    if (isRead) {
+      RegisterOperand threadRdShCounter = ir.regpool.makeTemp(TypeReference.Word);
+      Instruction loadThreadRdShCounterInst = Load.create(Operators.INT_LOAD,
+          threadRdShCounter,
+          ir.regpool.makeTROp(),
+          IRTools.AC(Entrypoints.octetThreadReadSharedCounterField.getOffset()),
+          new LocationOperand(Entrypoints.octetThreadReadSharedCounterField));
+      loadThreadRdShCounterInst.position = inst.position;
+      loadThreadRdShCounterInst.bcIndex = inst.bcIndex;
+      readCasesBB.appendInstruction(loadThreadRdShCounterInst);
+
+      Instruction rdShCmpInst = IfCmp.create(Operators.REF_IFCMP,
+          ir.regpool.makeTempValidation(),
+          threadRdShCounter.copy(),
+          metadataOperand.copy(),
+          ConditionOperand.LOWER_EQUAL(),
+          new BranchOperand(nextBB.firstInstruction()),
+          BranchProfileOperand.likely());
+      rdShCmpInst.position = inst.position;
+      rdShCmpInst.bcIndex = inst.bcIndex;
+      readCasesBB.appendInstruction(rdShCmpInst);
+    }
+
+    Instruction jumpInst;
+
+    if (insertRetry) {
+      // Delete the fall through edge and insert the retry edge. 
+      // InsertRetry would be true if configuration is RSCEIRBasedHeaderBarriers and if it is not the first barrier of the region.
+      jumpInst = Goto.create(Operators.GOTO,
+          new BranchOperand(targetAfterSlowPath.firstInstruction()));
+      slowPathBB.insertOut(targetAfterSlowPath);
+      slowPathBB.deleteOut(nextBB);
+    } else {
+      jumpInst = Goto.create(Operators.GOTO,
+          new BranchOperand(nextBB.firstInstruction()));
+
+    }
+    jumpInst.position = inst.position;
+    jumpInst.bcIndex = inst.bcIndex;
+    slowPathBB.appendInstruction(jumpInst);
+
+    insertCall(slowPath, jumpInst, true, ir);
+
+    // Make optimistic RBA safe by executing barriers for recently acquired objects
+    makeRedundantBarriersSafe(inst, slowPath, ir);
+
+    return null;
+  }
+
+  /** insert a barrier method */
+  private void insertCall(Instruction barrier, Instruction nextInst, boolean isResolved, IR ir) {
+    if (VM.VerifyAssertions) {
+      RVMMethod target = Call.getMethod(barrier).getTarget();
+      int numParams = target.getParameterTypes().length;
+      if (Call.getNumberOfParams(barrier) != numParams) {
+        System.out.println(barrier);
+        System.out.println(nextInst);
+        VM.sysFail("Bad match");
+      }
+    }
+
+    // Insert the barrier call
+    nextInst.insertBefore(barrier);
+
+    // If in LIR, the call needs to be lowered to LIR
+    if (lateInstr) {
+      ConvertToLowLevelIR.callHelper(barrier, ir);
+    }
+  }
+
+  /**
+   * Inline a call instruction -- copied from ExpandRuntimeServices
+   */
+  protected void inline(Instruction inst, IR ir, boolean noCalleeExceptions) {
+    // Save and restore inlining control state.
+    // Some options have told us to inline this runtime service,
+    // so we have to be sure to inline it "all the way" not
+    // just 1 level.
+    boolean savedInliningOption = ir.options.INLINE;
+    boolean savedExceptionOption = ir.options.H2L_NO_CALLEE_EXCEPTIONS;
+    ir.options.INLINE = true;
+    ir.options.H2L_NO_CALLEE_EXCEPTIONS = noCalleeExceptions;
+    boolean savedOsrGI = ir.options.OSR_GUARDED_INLINING;
+    ir.options.OSR_GUARDED_INLINING = false;
+    try {
+      InlineDecision inlDec =
+          InlineDecision.YES(Call.getMethod(inst).getTarget(), "Expansion of runtime service");
+      Inliner.execute(inlDec, ir, inst);
+    } finally {
+      ir.options.INLINE = savedInliningOption;
+      ir.options.H2L_NO_CALLEE_EXCEPTIONS = savedExceptionOption;
+      ir.options.OSR_GUARDED_INLINING = savedOsrGI;
+    }
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/OctetOptSelection.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/OctetOptSelection.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/OctetOptSelection.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/OctetOptSelection.java	2014-04-03 17:43:43.287671418 -0400
@@ -0,0 +1,398 @@
+package org.jikesrvm.compilers.opt;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.compilers.opt.driver.CompilerPhase;
+import org.jikesrvm.compilers.opt.escape.EscapeTransformations;
+import org.jikesrvm.compilers.opt.escape.FI_EscapeSummary;
+import org.jikesrvm.compilers.opt.ir.ALoad;
+import org.jikesrvm.compilers.opt.ir.AStore;
+import org.jikesrvm.compilers.opt.ir.GetField;
+import org.jikesrvm.compilers.opt.ir.GetStatic;
+import org.jikesrvm.compilers.opt.ir.IR;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.compilers.opt.ir.PutField;
+import org.jikesrvm.compilers.opt.ir.PutStatic;
+import org.jikesrvm.compilers.opt.ir.Register;
+import org.jikesrvm.compilers.opt.ir.operand.LocationOperand;
+import org.jikesrvm.compilers.opt.ir.operand.Operand;
+import org.jikesrvm.octet.InstrDecisions;
+import org.jikesrvm.octet.Octet;
+
+/** Octet: decide which reads/writes should be instrumented */
+public class OctetOptSelection extends CompilerPhase {
+
+  private static final boolean verbose = true;
+
+  @Override
+  public String getName() {
+    return "Octet read and write selection";
+  }
+
+  public OctetOptSelection() {
+  }
+
+  /** Let's just reuse the previous instance of this class, but reset the private variables */
+  public CompilerPhase newExecution(IR ir) {
+    return this;
+  }
+
+  @Override
+  public boolean shouldPerform(OptOptions options) {
+    return Octet.getConfig().insertBarriers() && Octet.getConfig().instrumentOptimizingCompiler();
+  }
+
+  @Override
+  public void perform(IR ir) {
+    // Octet: TODO: also undo prior changes for getting escape analysis to work in LIR
+    FI_EscapeSummary escapeSummary = doEscapeAnalysis(ir);
+
+    // we should be able to do something here with object references that we've already checked,
+    // since they can't change unless we change them -- although a thread might relinquish any
+    // object's state at *any* read or write, so how to deal with that?
+    /*
+    if (Octet.eliminateRedundantBarriers()) {
+      computeRedundantReadBarriers();
+    }
+    */
+    
+    processInsts(escapeSummary, ir);
+    
+    // Octet: TODO: remove
+    /*
+    if (Octet.instrumentMethod(ir.getMethod())) {
+      dumpIR(ir, "After Octet opt selection");
+    }
+    */
+  }
+
+  FI_EscapeSummary doEscapeAnalysis(IR ir) {
+    // use escape analysis to find definitely unshared objects
+    if (Octet.getConfig().useEscapeAnalysis()) {
+      return EscapeTransformations.getEscapeSummary(ir);
+    } else {
+      // No need to do these if escape analysis is off, right?
+      /*
+      DefUse.computeDU(ir);
+      DefUse.recomputeSSA(ir);
+      */
+      return null;
+    }
+  }
+  
+  void processInsts(FI_EscapeSummary escapeSummary, IR ir) {
+    Instruction next;
+    for (Instruction inst = ir.firstInstructionInCodeOrder(); inst != null; inst = next) {
+      next = inst.nextInstructionInCodeOrder();
+      processInst(inst, escapeSummary, ir);
+    }
+  }
+  
+  void processInst(Instruction inst, FI_EscapeSummary escapeSummary, IR ir) {
+    boolean shouldInstrument = false;
+    if (GetField.conforms(inst) || PutField.conforms(inst)) {
+      shouldInstrument = shouldInstrumentInstPosition(inst, ir) && shouldInstrumentScalarAccess(inst, escapeSummary);
+    } else if (ALoad.conforms(inst) || AStore.conforms(inst)) {
+      shouldInstrument = shouldInstrumentInstPosition(inst, ir) && shouldInstrumentArrayAccess(inst, escapeSummary);
+    } else if (GetStatic.conforms(inst) || PutStatic.conforms(inst)) {
+      shouldInstrument = shouldInstrumentInstPosition(inst, ir) && shouldInstrumentStaticAccess(inst);
+    }
+    if (shouldInstrument) {
+      inst.markAsPossibleSharedMemoryAccess();
+    }
+  }
+  
+  boolean shouldInstrumentScalarAccess(Instruction inst, FI_EscapeSummary escapeSummary) {
+    // are we early or late in the compilation process?  use a different strategy in each case
+    boolean isRead = GetField.conforms(inst);
+    LocationOperand loc = isRead ? GetField.getLocation(inst) : PutField.getLocation(inst);
+    Operand ref = isRead ? GetField.getRef(inst) : PutField.getRef(inst);
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    boolean mightHaveMetadata;
+    if (isResolved) {
+      mightHaveMetadata = InstrDecisions.objectOrFieldHasMetadata(field);
+    } else {
+      mightHaveMetadata = InstrDecisions.objectOrFieldMightHaveMetadata(fieldRef);
+    }
+    if (mightHaveMetadata &&
+        Octet.shouldInstrumentFieldAccess(fieldRef)) {
+      if (mightEscape(ref, escapeSummary)) {
+        return true;
+      } else {
+        // Helps with debugging
+        // inst.markThreadLocal();
+      }
+    }
+    return false;
+  }
+  
+  boolean shouldInstrumentArrayAccess(Instruction inst, FI_EscapeSummary escapeSummary) {
+    boolean isRead = ALoad.conforms(inst);
+    LocationOperand loc = isRead ? ALoad.getLocation(inst) : AStore.getLocation(inst);
+    if (VM.VerifyAssertions) { VM._assert(loc.isArrayAccess()); }
+    Operand ref = isRead ? ALoad.getArray(inst) : AStore.getArray(inst);
+    if (mightEscape(ref, escapeSummary)) {
+      return true;
+    } else {
+      // Helps with debugging
+      //inst.markThreadLocal();
+    }
+    return false;
+  }
+  
+  boolean shouldInstrumentStaticAccess(Instruction inst) {
+    boolean isRead = GetStatic.conforms(inst);
+    LocationOperand loc = isRead ? GetStatic.getLocation(inst) : PutStatic.getLocation(inst);
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    boolean mightHaveMetadata;
+    if (isResolved) {
+      mightHaveMetadata = InstrDecisions.staticFieldHasMetadata(field);
+    } else {
+      mightHaveMetadata = InstrDecisions.staticFieldMightHaveMetadata(fieldRef);
+    }
+    if (mightHaveMetadata) {
+      return true;
+    }
+    return false;
+  }
+  
+  public static final boolean shouldInstrumentInstPosition(Instruction inst, IR ir) {
+    boolean instrumentInst = inst.position == null ? false : Octet.shouldInstrumentMethod(inst.position.getMethod());
+    boolean instrumentMethod = Octet.shouldInstrumentMethod(ir.getMethod());
+    boolean racyInst = inst.position == null ? false : (!Octet.getConfig().enableStaticRaceDetection() || (Context.isLibraryPrefix((inst.position.getMethod().getDeclaringClass().getTypeRef()))) || Octet.shouldInstrumentCheckRace(inst.position.getMethod(), inst.position.bcIndex));
+     
+    // Octet: TODO: Instrument all library accesses for now
+    
+    // Octet: TODO: Figure this out!  Might need to instrument more or fewer classes.
+    // A class like System or String doesn't seem to need Octet instrumentation, but what about stuff inlined into it?
+    // Actually, System probably needs Octet instrumentation, e.g., for array copy.
+    // If a library method gets inlined into a VM method, then we probably don't need to instrument the library method.
+    
+    /*
+    if (instrumentInst && !instrumentMethod) {
+      System.out.println("Case A: Instruction in method " + ir.getMethod() + " is instrumented but method wouldn't be:");
+      System.out.println(inst);
+      System.out.println("  inst.position: " + inst.position);
+      System.out.println();
+    }
+    if (!instrumentInst && instrumentMethod) {
+      System.out.println("Case B: Instruction in method " + ir.getMethod() + " isn't instrumented but method would be:");
+      System.out.println(inst);
+      System.out.println("  inst.position: " + inst.position);
+      System.out.println();
+    }
+    */
+    
+    // Octet: TODO: Need to make sure that what's getting instrumented is still reasonable.
+    // VM instrumentation in application/library methods isn't necessarily being ignored!
+    
+    // Octet: TODO: not sure about this policy
+    return instrumentInst && instrumentMethod && racyInst;
+  }
+  
+  boolean mightEscape(Operand refOperand, FI_EscapeSummary escapeSummary) {
+    if (Octet.getConfig().useEscapeAnalysis()) {
+      if (refOperand.isRegister()) {
+        Register reg = refOperand.asRegister().getRegister();
+        if (escapeSummary.isThreadLocal(reg)) {
+          if (VM.VerifyAssertions) { VM._assert(reg.isSSA()); }
+          return false;
+        }
+      }
+    }
+    return true;
+  }
+  
+  // Octet: LATER: synchronization operations should clear data-flow -- actually we might have more
+  // serious problems with using this approach because the result of a barrier
+  // can change at any read or write to any object
+  
+  /** Compute redundant field reads and writes (borrowed from Pacer) -- see note above for why this isn't right for Octet */
+  /*
+  @SuppressWarnings("unchecked")
+  final void computeRedundantReadBarriers(HashSetRVM<Instruction> fullyRedInsts, IR ir) {
+    // first set all the scratch objects to empty sets
+    for (BasicBlock bb = ir.lastBasicBlockInCodeOrder(); bb != null; bb = bb.prevBasicBlockInCodeOrder()) {
+      bb.scratchObject = new HashMap<Register,HashSet<FieldAccess>>();
+    }
+    ir.cfg.exit().scratchObject = new HashMap<Register,HashSet<FieldAccess>>();
+
+    // do data-flow
+    HashMap<Register,HashSet<FieldAccess>> thisFullyRedSet = new HashMap<Register,HashSet<FieldAccess>>();
+    boolean changed;
+    int iteration = 0;
+    do {
+      if (verbose) { System.out.println("Beginning iteration " + iteration + " fullyRedInsts.size() = " + fullyRedInsts.size()); }
+      iteration++;
+      changed = false;
+      for (BasicBlock bb = ir.firstBasicBlockInCodeOrder(); bb != null; bb = bb.nextBasicBlockInCodeOrder()) {
+        // compute redundant variables for the bottom of the block
+        // and merge with redundant variables
+        thisFullyRedSet.clear();
+        boolean first = true;
+        for (BasicBlockEnumeration e = bb.getIn(); e.hasMoreElements(); ) {
+          BasicBlock predBB = e.next();
+          HashMap<Register,HashSet<FieldAccess>> predFullyRedSet = (HashMap<Register,HashSet<FieldAccess>>)predBB.scratchObject;
+          if (first) {
+            for (Register reg : predFullyRedSet.keySet()) {
+              // gotta copy the set, not reused the same object
+              HashSet<FieldAccess> fieldAccesses = new HashSet<FieldAccess>(predFullyRedSet.get(reg));
+              thisFullyRedSet.put(reg, fieldAccesses);
+            }
+            first = false;
+          } else {
+            // intersection of field access sets
+            for (Iterator<Register> iter = thisFullyRedSet.keySet().iterator(); iter.hasNext(); ) {
+              Register reg = iter.next();
+              if (predFullyRedSet.containsKey(reg)) {
+                HashSet<FieldAccess> fieldAccesses = thisFullyRedSet.get(reg);
+                fieldAccesses.retainAll(predFullyRedSet.get(reg));
+              } else {
+                iter.remove();
+              }
+            }
+          }
+        }
+
+        // propagate info from top to bottom of block
+        for (Instruction i = bb.firstInstruction(); !i.isBbLast(); i = i.nextInstructionInCodeOrder()) {
+          // first look at RHS (since we're going forward)
+          Operand useOperand = null;
+          boolean isRead = false;
+          FieldReference fieldRef = null;
+          //} else if (NewArray.conforms(i)) {
+          //  useOperand = NewArray.getResult(i);
+          if (GetField.conforms(i)) {
+            useOperand = GetField.getRef(i);
+            fieldRef = GetField.getLocation(i).asFieldAccess().getFieldRef();
+            isRead = true;
+          //} else if (ALoad.conforms(i)) {
+          //  useOperand = ALoad.getArray(i);
+          } else if (PutField.conforms(i)) {
+            useOperand = PutField.getRef(i);
+            fieldRef = PutField.getLocation(i).asFieldAccess().getFieldRef();
+            isRead = false;
+          //} else if (AStore.conforms(i)) {
+          //  useOperand = AStore.getArray(i);
+          }
+          if (useOperand != null) {
+            //if (VM.VerifyAssertions) { VM._assert(useOperand.isRegister() || useOperand.isConstant()); }
+            if (useOperand.isRegister()) {
+              Register useReg = useOperand.asRegister().register;
+              FieldAccess fieldAccess = new FieldAccess(fieldRef, isRead);
+              HashSet<FieldAccess> fieldAccesses = thisFullyRedSet.get(useReg);
+              if (fieldAccesses == null) {
+                fieldAccesses = new HashSet<FieldAccess>();
+                thisFullyRedSet.put(useReg, fieldAccesses);
+              }
+              if (fieldAccesses.contains(fieldAccess)) {
+                fullyRedInsts.add(i);
+              } else {
+                fieldAccesses.add(fieldAccess);
+              }
+            } else if (useOperand.isConstant()) {
+              fullyRedInsts.add(i);
+            } else {
+              VM.sysFail("Weird operand: " + useOperand);
+            }
+          }
+          // now look at LHS
+          if (Move.conforms(i)) {
+            Operand srcOperand = Move.getVal(i);
+            if (srcOperand.isRegister()) {
+              Register useReg = srcOperand.asRegister().register;
+              Register defReg = Move.getResult(i).register;
+              if (thisFullyRedSet.containsKey(useReg)) {
+                HashSet<FieldAccess> useFieldAccesses = thisFullyRedSet.get(useReg);
+                HashSet<FieldAccess> defFieldAccesses = thisFullyRedSet.get(defReg);
+                if (defFieldAccesses == null) {
+                  defFieldAccesses = new HashSet<FieldAccess>();
+                  thisFullyRedSet.put(defReg, defFieldAccesses);
+                }
+                defFieldAccesses.addAll(useFieldAccesses);
+              }
+            }
+          } else {
+            // look at other defs
+            for (OperandEnumeration e = i.getDefs(); e.hasMoreElements(); ) {
+              Operand defOperand = e.next();
+              if (defOperand.isRegister()) {
+                Register defReg = defOperand.asRegister().register;
+                thisFullyRedSet.remove(defReg);
+              }
+            }
+          }
+        }
+
+        // compare what we've computed with what was already there
+        HashMap<Register,HashSet<FieldAccess>> oldFullyRedSet = (HashMap<Register,HashSet<FieldAccess>>)bb.scratchObject;
+        if (!oldFullyRedSet.equals(thisFullyRedSet)) {
+          if (verbose) {
+            System.out.println(bb);
+            System.out.println("  Old: ");
+            printRegAccessMap(oldFullyRedSet);
+            System.out.println("  New: ");
+            printRegAccessMap(thisFullyRedSet);
+          }
+          //if (VM.VerifyAssertions) { VM._assert(thisFullyRedSet.containsAll(oldFullyRedSet)); }
+          oldFullyRedSet.clear();
+          oldFullyRedSet.putAll(thisFullyRedSet);
+          changed = true;
+        }
+      }
+    } while (changed);
+
+    // print graph
+    //genGraph(ir, "redComp", partRedInsts, fullyRedInsts, needsBarrierMap, true);
+
+    // clear the scratch objects
+    for (BasicBlock bb = ir.lastBasicBlockInCodeOrder(); bb != null; bb = bb.prevBasicBlockInCodeOrder()) {
+      bb.scratchObject = null;
+    }
+    ir.cfg.exit().scratchObject = null;
+  }
+  
+  // used for redundancy
+  static final class FieldAccess {
+    final FieldReference field;
+    final boolean isRead;
+    
+    public FieldAccess(FieldReference field, boolean isRead) {
+      this.field = field;
+      this.isRead = isRead;
+    }
+    
+    @Override
+    public boolean equals(Object o) {
+      FieldAccess other = (FieldAccess)o;
+      return field == other.field && isRead == other.isRead;
+    }
+    
+    @Override
+    public int hashCode() {
+      return field.hashCode() + (isRead ? 1 : 0);
+    }
+    
+    @Override
+    public String toString() {
+      return field + (isRead ? " (read)" : " (write)");
+    }
+  }
+
+  private void printRegAccessMap(HashMap<Register,HashSet<FieldAccess>> map) {
+    for (Register reg : map.keySet()) {
+      System.out.println("    Reg: " + reg);
+      HashSet<FieldAccess> fieldAccesses = map.get(reg);
+      for (FieldAccess fieldAccess : fieldAccesses) {
+        System.out.println("      Field access: " + fieldAccess);
+      }
+    }
+  }
+  */
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/RedundantBarrierRemover.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/RedundantBarrierRemover.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/RedundantBarrierRemover.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/RedundantBarrierRemover.java	2014-04-03 17:43:42.991670445 -0400
@@ -0,0 +1,627 @@
+package org.jikesrvm.compilers.opt;
+
+import java.util.Enumeration;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.compilers.opt.driver.CompilerPhase;
+import org.jikesrvm.compilers.opt.ir.ALoad;
+import org.jikesrvm.compilers.opt.ir.AStore;
+import org.jikesrvm.compilers.opt.ir.BasicBlock;
+import org.jikesrvm.compilers.opt.ir.BoundsCheck;
+import org.jikesrvm.compilers.opt.ir.GetField;
+import org.jikesrvm.compilers.opt.ir.GetStatic;
+import org.jikesrvm.compilers.opt.ir.IR;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.compilers.opt.ir.Move;
+import org.jikesrvm.compilers.opt.ir.New;
+import org.jikesrvm.compilers.opt.ir.NullCheck;
+import org.jikesrvm.compilers.opt.ir.PutField;
+import org.jikesrvm.compilers.opt.ir.PutStatic;
+import org.jikesrvm.compilers.opt.ir.Register;
+import org.jikesrvm.compilers.opt.ir.operand.LocationOperand;
+import org.jikesrvm.compilers.opt.ir.operand.Operand;
+import org.jikesrvm.compilers.opt.liveness.LiveAnalysis;
+import org.jikesrvm.compilers.opt.regalloc.LiveIntervalElement;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.Stats;
+
+/**
+ * Octet: This class implements a compiler phase for finding redundant barriers
+ * in octet
+ * 
+ * @author Meisam
+ * @modified by Minjia on October 4, 2012.
+ * */
+public class RedundantBarrierRemover extends CompilerPhase {
+
+  /** Octet: TODO: more than 10 is probably a bug */
+  private static final int MAX_ITERATIONS = 10; // 10000;
+
+  /**
+   * Octet: later: set this value from config.
+   */
+  private static final boolean DEBUG = false;
+
+  /**
+   * Octet: later: set this value from config.
+   */
+  private static final boolean VERBOSE = false;
+
+  /** There are different levels of redundant barrier analysis. */
+  public enum AnalysisLevel {
+    NONE, DEFAULT_SAFE, OPTIMISTIC_SAFE, OPTIMISTIC_UNSAFE, SUPER_OPTIMISTIC_UNSAFE
+  }
+
+  final AnalysisLevel analysisLevel;
+  
+  public RedundantBarrierRemover(AnalysisLevel analysisLevel) {
+    this.analysisLevel = analysisLevel;
+  }
+  
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.jikesrvm.compilers.opt.driver.CompilerPhase#getName()
+   */
+  @Override
+  public String getName() {
+    return "Octet Redundant Barrier Remover";
+  }
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.jikesrvm.compilers.opt.driver.CompilerPhase#newExecution(org.jikesrvm
+   * .compilers.opt.ir.IR)
+   */
+  @Override
+  public CompilerPhase newExecution(IR ir) {
+    return this;
+  }
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.jikesrvm.compilers.opt.driver.CompilerPhase#shouldPerform(org.jikesrvm
+   * .compilers.opt.OptOptions)
+   */
+  @Override
+  public boolean shouldPerform(OptOptions options) {
+    return Octet.getConfig().insertBarriers() && Octet.getConfig().instrumentOptimizingCompiler()
+        && analysisLevel != AnalysisLevel.NONE;
+  }
+
+  /** Should we perform live analysis?  Only actually performed if using SORBA. */
+  private static final boolean USE_LIVE_ANALYSIS = true;
+  
+  /** Live analysis object (only used if USE_LIVE_ANALYSIS==true and using SORBA). */
+  LiveAnalysis liveAnalysis = null;
+
+  @Override
+  public void perform(IR ir) {
+
+    if (!Octet.shouldInstrumentMethod(ir.getMethod())) {
+      return;
+    }
+
+    if (DEBUG) {
+      System.out.println("DEBUG: ");
+      System.out.println("DEBUG: ");
+      System.out.println("DEBUG: ");
+      System.out.println("DEBUG: ============================================");
+      System.out.println("DEBUG: " + ir.getMethod());
+    }
+
+    /** Perform live analysis if enabled and if using SORBA */
+    if (USE_LIVE_ANALYSIS && analysisLevel == AnalysisLevel.OPTIMISTIC_SAFE) {
+      liveAnalysis = new LiveAnalysis();
+      liveAnalysis.perform(ir);
+      //DefUse.computeDU(ir); -- apparently not actually needed
+      ir.numberInstructions(); // needed to figure out live ranges
+    }
+    
+    boolean needsUpdate = true;
+    int count = 0;
+
+    // Octet: TODO: instead of killing facts at catch blocks, we could unfactor the CFG before this analysis
+    //ir.unfactor();
+    
+    // Initiate the facts as earlier optimization might use the scratch object.
+    Enumeration<BasicBlock> blockEnumeration = ir.getBasicBlocks();
+    while (blockEnumeration.hasMoreElements()) {
+      BasicBlock basicBlock = blockEnumeration.nextElement();
+      basicBlock.scratchObject = new ObjectsAccessFacts();
+    }
+    
+    while (needsUpdate) {
+      needsUpdate = false;
+      count++;
+
+      if (DEBUG) {
+        System.out.println("DEBUG:   ---------------------------------");
+        System.out.println("DEBUG:   Iteration #" + count);
+      }
+
+      if (VM.VerifyAssertions) {
+        VM._assert(count < MAX_ITERATIONS);
+      }
+
+      // Octet: Meisam: TODO LATER use a better order for traversing basic
+      // blocks
+      blockEnumeration = ir.getBasicBlocks();
+      while (blockEnumeration.hasMoreElements()) {
+        BasicBlock basicBlock = blockEnumeration.nextElement();
+        Instruction instruction = basicBlock.firstInstruction();
+
+        ObjectsAccessFacts oldFacts = null;
+        if (basicBlock.scratchObject instanceof ObjectsAccessFacts) {
+          oldFacts = (ObjectsAccessFacts) basicBlock.scratchObject;
+        }
+
+        ObjectsAccessFacts newFacts = meetPredecessorBasicBlocks(basicBlock);
+        if (DEBUG) {
+          System.out.println("DEBUG:     ---- ");
+          System.out.println("DEBUG:     " + basicBlock);
+        }
+        do {
+
+          // Based on existing facts, try to eliminate barriers for a read or write.
+          if (instruction.isPossibleSharedMemoryAccess()) {
+            boolean storesSharedObject = storesSharedObject(instruction);
+            boolean loadsSharedObject = loadsSharedObject(instruction);
+            if (storesSharedObject || loadsSharedObject) {
+              Object object = storesSharedObject ? getStoredObject(instruction) : getLoadedObject(instruction);
+              BarrierType barrierType = newFacts.lookupFact(object);
+              boolean isRedundant = barrierType.isHigher(storesSharedObject ? BarrierType.WRITE : BarrierType.READ);
+              if (isRedundant) {
+                instruction.clearAsPossibleSharedMemoryAccess();
+                instruction.markHasRedundantBarrier();
+              }
+            }
+          }
+
+          updateFactsForUsedSharedObjects(instruction, newFacts);
+
+          if (isSafePoint(instruction)) { // handle safe points
+            if (analysisLevel != AnalysisLevel.SUPER_OPTIMISTIC_UNSAFE) {
+              newFacts.clearAllNonTopFacts();
+            }
+          }
+          
+          // Try to update facts for read and write, depending on whether facts were cleared.
+          if (storesSharedObject(instruction)) { // example: o.f = ...
+            Object obj = getStoredObject(instruction);
+            updateFactsForStoredSharedObject(obj, newFacts, instruction);
+          } else if (loadsSharedObject(instruction)) { // example: ... = o.f
+            Object obj = getLoadedObject(instruction);
+            updateFactsForLoadedSharedObject(obj, newFacts, instruction);
+          } 
+          
+          //Handle the lhs of an instruction.
+          if (Move.conforms(instruction)) { // example o2 = o1
+            Register lhsObject = Move.getResult(instruction).asRegister().getRegister();
+
+            Operand val = Move.getVal(instruction);
+            if (val.isRegister()) {
+              // Right hand side object
+              Register rhsObject = val.asRegister().getRegister();
+              updateFactsForMoveInstruction(rhsObject, lhsObject, newFacts);
+            } else {
+              //Similarly, we 're conservative here, if the right hand side is not a register, than the left hand side could be assigned to anything.
+              newFacts.updateToInfimumBarrier(lhsObject, BarrierType.BOTTOM);
+            }
+          } else if (instruction.isAllocation()) {
+            Register register = New.getResult(instruction).asRegister()
+                .getRegister();
+            // Octet: TODO: Meisam: I think even in optimistic redundant barrier
+            // analysis we should clear facts when we see a new instruction.
+            // The facts have already been cleared by the above isSafepoint() check. We onlyl need to update the fact for the lhs. 
+            newFacts.updateFact(register, BarrierType.TOP);
+          } else {
+            updateFactsForDefs(instruction, newFacts);
+          }
+
+          if (instruction.isBbLast()) {
+            basicBlock.scratchObject = newFacts;
+            break;
+          }
+          if (DEBUG) {
+            System.out.println("DEBUG:        " + instruction);
+            System.out.println("DEBUG:                                     "
+                + newFacts);
+
+          }
+          instruction = instruction.nextInstructionInCodeOrder();
+        } while (instruction != null);
+
+        if (!(newFacts.equals(oldFacts))) {
+          needsUpdate = true;
+        }
+      }
+    }
+
+    collectStats(ir);
+  }
+
+  /**
+   * Counts the number of shared accesses and the number of accesses for which a
+   * redundant barrier was detect for the given IR.
+   * 
+   * @param ir
+   */
+  private void collectStats(IR ir) {
+    if (Octet.getConfig().stats()) {
+      Enumeration<BasicBlock> blockEnumeration = ir.getBasicBlocks();
+      while (blockEnumeration.hasMoreElements()) {
+        BasicBlock basicBlock = blockEnumeration.nextElement();
+        Instruction instruction = basicBlock.firstInstruction();
+        do {
+          if (instruction.isPossibleSharedMemoryAccess()) {
+            Stats.sharedAccesses.inc();
+          }
+          if (instruction.hasRedundantBarrier()) {
+            Stats.redundantBarriers.inc();
+          }
+          instruction = instruction.nextInstructionInCodeOrder();
+        } while (instruction != basicBlock.lastInstruction());
+      }
+    }
+  }
+
+  /**
+   * This methods finds all the objects that are used in the given instruction
+   * and if uses are in TOP state, changes them to WRITE. Because objects in TOP
+   * state may escape when they are used.
+   * 
+   * @param instruction
+   *          The given instruction
+   * @param facts
+   *          The facts for the given instruction
+   */
+  private void updateFactsForUsedSharedObjects(Instruction instruction,
+      ObjectsAccessFacts facts) {
+    
+    Enumeration<Operand> uses = instruction.getUses();
+
+    while (uses.hasMoreElements()) {
+
+      //Any op uses object as an operand like Move, Call, Return.
+      //Conservatively change the fact for a object that might escape due to a Move, Call or Return op.
+      Operand operand = uses.nextElement();
+  
+      if (operand.isRegister()) {
+        // Handle the following case:
+        // r1 = new A();
+        // r2 = new A();
+        // r2 = r1; or call (r1) or or any use of r1. 
+        // r2 = r1.f //In order to use r1.f, it has to be loaded first into some register (A def).
+        // o.f = o // the order of handling defs and uses might matter in this special case.
+        Register register = operand.asRegister().getRegister();
+        if (facts.lookupFact(register) == BarrierType.TOP) {
+          facts.updateFact(register, BarrierType.WRITE);
+        }
+      }
+    }
+  }
+
+  void updateFactsForDefs(Instruction instruction, ObjectsAccessFacts facts) {
+    Enumeration<Operand> defs = instruction.getDefs();
+    while (defs.hasMoreElements()) {
+      Operand operand = defs.nextElement();
+      if (operand.isRegister()) {
+        Register register = operand.asRegister().getRegister();
+        // Normally, the defs should be a new register, however, in unrolling, it could be used again in the unrolled loops.
+        // Kind of having no other choice since it could be assigned to anything. We have to be conservative here.
+        facts.updateFact(register, BarrierType.BOTTOM);
+      }
+    }
+  }
+
+  /**
+   * @param rhsObject
+   *          Right hand side of a move instruction
+   * @param lhsObject
+   *          Left hand side of a move instructions
+   * @param facts
+   *          Facts about redundant barriers after the instruction
+   */
+  private void updateFactsForMoveInstruction(Register rhsObject,
+      Register lhsObject, ObjectsAccessFacts facts) {
+
+    BarrierType rhsBarrierType = facts.lookupFact(rhsObject);
+    // update information for lhs object with barrier for rhs object
+    facts.updateFact(lhsObject, rhsBarrierType);
+  }
+
+  /**
+   * Updates the facts for a given object when we see a {@link Move}
+   * instruction.
+   * 
+   * @param object
+   *          the accessed object
+   * @param facts
+   *          The facts after the instruction
+   */
+  private void updateFactsForNewInstruction(Object object,
+      ObjectsAccessFacts facts) {
+
+    // Octet: TODO: Meisam: I think even in optimistic redundant barrier
+    // analysis we should clear facts when we see a new instruction.
+    facts.clearAllNonTopFacts();
+    facts.updateFact(object, BarrierType.TOP);
+  }
+
+  /**
+   * Updates the facts for a given object when we see a load from that object.
+   * 
+   * @param object
+   *          the accessed object
+   * @param facts
+   *          The facts
+   */
+  private void updateFactsForLoadedSharedObject(Object object, ObjectsAccessFacts facts, Instruction inst) {
+    updateFactsForSharedObject(object, facts, BarrierType.READ, inst);
+  }
+
+  /**
+   * Updates the facts for a given object when we see a store to that object.
+   * 
+   * @param object
+   *          the accessed object
+   * @param facts
+   *          The facts
+   */
+  private void updateFactsForStoredSharedObject(Object object, ObjectsAccessFacts facts, Instruction inst) {
+    updateFactsForSharedObject(object, facts, BarrierType.WRITE, inst);
+  }
+
+  /** Helper method called by updateFactsForLoadedSharedObject and updateFactsForStoredSharedObject */
+  private void updateFactsForSharedObject(Object object, ObjectsAccessFacts facts, BarrierType barrierType, Instruction inst) {
+    if (analysisLevel != AnalysisLevel.OPTIMISTIC_SAFE &&
+        analysisLevel != AnalysisLevel.OPTIMISTIC_UNSAFE &&
+        analysisLevel != AnalysisLevel.SUPER_OPTIMISTIC_UNSAFE) {
+      facts.clearAllNonTopFacts(); // Because of Safe Points
+    }
+    facts.updateToSupremumBarrier(object, barrierType);
+    
+    // For safe optimistic analysis, store the facts for each instruction, to help with adding instrumentation later
+    if (analysisLevel == AnalysisLevel.OPTIMISTIC_SAFE) {
+      // We can't support retry instrumentation for unresolved statics, so let's just kill all non-top facts at unresolved static accesses
+      if (GetStatic.conforms(inst) || PutStatic.conforms(inst)) {
+        LocationOperand locationOperand = GetStatic.conforms(inst) ? GetStatic.getLocation(inst) : PutStatic.getLocation(inst); 
+        FieldReference fieldRef = locationOperand.getFieldRef();
+        RVMField field = fieldRef.getResolvedField();
+        if (field == null || !field.hasMetadataOffset()) {
+          facts.clearAllNonTopFacts();
+        }
+      }
+      // Clone the facts and store them in the instruction's scratch object
+      ObjectsAccessFacts clonedFacts = facts.clone();
+      // If enabled, use live analysis information to remove facts for dead registers.
+      if (USE_LIVE_ANALYSIS) {
+        HashSet<Register> deadRegisters = getDeadRegisters(clonedFacts.getObjects(), inst, object);
+        for (Register reg : deadRegisters) {
+          clonedFacts.clearFact(reg);
+        }
+      }
+      inst.scratchObject = clonedFacts;
+    }
+  }
+  
+  // Octet: LATER: liveness analysis could simply be used for any kind of RBA analysis, not just SORBA, to simplify the facts
+  
+  /** Return objects that are dead at inst and thus can be removed from the facts. */
+  HashSet<Register> getDeadRegisters(Set<Object> objects, Instruction inst, Object instObject) {
+    HashSet<Register> deadRegisters = new HashSet<Register>();
+    for (Object temp : objects) {
+      if (temp instanceof Register) {
+        Register register = (Register)temp;
+        Iterator<LiveIntervalElement> e = null;
+        try {
+          e = liveAnalysis.iterateLiveIntervals(register);
+        } catch (ArrayIndexOutOfBoundsException ex) {
+          //System.out.println("Register: " + register);
+          //ex.printStackTrace();
+        }
+        if (e != null) {
+          boolean hasLaterUse = false;
+          // Iterate over live intervals to see if  
+          while (e.hasNext()) {
+            LiveIntervalElement elem = e.next();
+            BasicBlock bb = elem.getBasicBlock();
+            // Need to look at live ranges only for this basic block
+            if (bb == inst.getBasicBlock()) {
+              Instruction begin = (elem.getBegin() == null) ? bb.firstInstruction() : elem.getBegin();
+              Instruction end = (elem.getEnd() == null) ? bb.lastInstruction() : elem.getEnd();
+              int low = begin.scratch;
+              int high = end.scratch;
+              //System.out.println("inst.scratch = " + inst.scratch + " ; high = " + high);
+              if (inst.scratch >= low && inst.scratch <= high) {
+                hasLaterUse = true;
+                break;
+              } else {
+                /*
+                    System.out.println("inst.scratch = " + inst.scratch);
+                    System.out.println("low = " + low);
+                    System.out.println("high = " + high);
+                    bb.printExtended();
+                    System.out.println("inst: " + inst);
+                 */
+              }
+            }
+          }
+          if (!hasLaterUse) {
+            // Make sure we aren't accidentally clearing fact for the register accessed at this instruction
+            if (VM.VerifyAssertions) { VM._assert(register != instObject); }
+            // Will clear fact for dead register
+            deadRegisters.add(register);
+            //System.out.println("Clearing fact: " + register);
+          } else {
+            //System.out.println("Can't clear fact for " + register + " because it has a later use");
+          }
+        } else {
+          //System.out.println("Can't clear fact for " + register + " because live analysis failed.");
+        }
+      } else {
+        //System.out.println("Can't clear fact for " + temp + " because not a register");
+      }
+    }
+    return deadRegisters;
+  }
+
+  /**
+   * Does the given instruction stores shared object
+   * 
+   * @param instruction
+   *          The given instruction
+   * @return true if the given instruction stores a shared Object
+   */
+  private boolean storesSharedObject(Instruction instruction) {
+    return PutField.conforms(instruction)
+        || PutStatic.conforms(instruction)
+        || (AStore.conforms(instruction) && AStore.getArray(instruction).isRegister());
+  }
+
+  /**
+   * Does the given instruction loads a shared object
+   * 
+   * @param instruction
+   *          The given instruction
+   * @return true if the given instruction loads a shared Object
+   */
+  private boolean loadsSharedObject(Instruction instruction) {
+    return GetField.conforms(instruction)
+        || GetStatic.conforms(instruction)
+        || (ALoad.conforms(instruction) && ALoad.getArray(instruction).isRegister());
+  }
+
+  /**
+   * Returns the object that is stored in the given instruction
+   * 
+   * @param instruction
+   *          The given instruction
+   * @return The stored object
+   */
+  private Object getStoredObject(Instruction instruction) {
+    if (PutField.conforms(instruction)) {
+      if (PutField.getRef(instruction).isRegister()) {
+        return PutField.getRef(instruction).asRegister().getRegister();
+      }
+      return null;
+    } else if (PutStatic.conforms(instruction)) {
+      return PutStatic.getLocation(instruction).getFieldRef();
+    } else if (AStore.conforms(instruction)) {
+      if (AStore.getArray(instruction).isRegister()) {
+        return AStore.getArray(instruction).asRegister().getRegister();
+      }
+      return null;
+    }
+    if (VM.VerifyAssertions) {
+      VM._assert(false, "Instruction " + instruction
+          + " is not valid as an instruction that stores to a shared object");
+    }
+    return null;
+  }
+
+  /**
+   * Returns the object that is loaded in the given instruction
+   * 
+   * @param instruction
+   *          The given instruction
+   * @return The loaded object
+   */
+  private Object getLoadedObject(Instruction instruction) {
+    if (GetField.conforms(instruction)) {
+      if (GetField.getRef(instruction).isRegister()) {
+        return GetField.getRef(instruction).asRegister().getRegister();
+      }
+      return null;
+    } else if (GetStatic.conforms(instruction)) {
+      return GetStatic.getLocation(instruction).getFieldRef();
+    } else if (ALoad.conforms(instruction)) {
+      if (ALoad.getArray(instruction).isRegister()) { 
+        return ALoad.getArray(instruction).asRegister().getRegister();
+      }
+      return null;
+    }
+    if (VM.VerifyAssertions) {
+      VM._assert(false, "Instruction " + instruction
+          + " is not valid as an instruction that loads from a shared object");
+    }
+    return null;
+  }
+
+  /**
+   * Takes a basic block and merges all the facts from its predecessors into a
+   * new fact. Returns the result fact
+   * 
+   * @param bb
+   *          the given basic block
+   * @return the new fact
+   */
+  private ObjectsAccessFacts meetPredecessorBasicBlocks(BasicBlock bb) {
+    // In the FCFG, exception edges can exit out of the middle of a block to a catch block
+    // Thus, all catch blocks should kill all facts.
+    // Another option would be to use the unfactored CFG.
+    if (bb.isExceptionHandlerBasicBlock()) {
+      return new ObjectsAccessFacts();
+    }
+    
+    Enumeration<BasicBlock> predecessorsEnumeration = bb.getInNodes();
+    // The initial barrier type is BOTTOM.
+    ObjectsAccessFacts newFacts;
+    if (!predecessorsEnumeration.hasMoreElements()) { // It is the start node.
+      return new ObjectsAccessFacts();
+    } else {
+      BasicBlock predecessorBasicBlock = predecessorsEnumeration.nextElement();
+      // Need a clone here because we want to build facts for the current BB
+      // based on its predecessors, however, we do not want to change the
+      // predecessor's facts.
+      // Get the first predecessor's facts.
+      newFacts = ((ObjectsAccessFacts)predecessorBasicBlock.scratchObject).clone();
+    }
+    
+    while (predecessorsEnumeration.hasMoreElements()) {
+      BasicBlock predecessorBasicBlock = predecessorsEnumeration.nextElement();
+      ObjectsAccessFacts otherFacts = (ObjectsAccessFacts) (predecessorBasicBlock.scratchObject);
+      newFacts.meet(otherFacts);
+    }
+
+    return newFacts;
+  }
+
+  /**
+   * 
+   * Gets an instruction and returns true if it is a safe point
+   * 
+   * @param instruction
+   *          the given instruction
+   * @return true if the given instruction is a safe point, else false
+   */
+
+  private boolean isSafePoint(Instruction instruction) {
+    return (instruction.isTSPoint() || instruction.isGCPoint())
+        && !benignSafePoint(instruction);
+  }
+
+  /**
+   * Returns true if the given instruction is a benign safe point, which means
+   * it doesn't cause the current thread to lose exclusive access to the objects
+   * that it already has.
+   * 
+   * @param instruction
+   *          the given instruction
+   * @return true if the given instruction is benign safe point
+   */
+  private boolean benignSafePoint(Instruction instruction) {
+    return NullCheck.conforms(instruction) || BoundsCheck.conforms(instruction);
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/CallingConvention.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/CallingConvention.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/CallingConvention.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/CallingConvention.java	2014-04-03 17:43:42.636669277 -0400
@@ -15,8 +15,10 @@ package org.jikesrvm.compilers.opt.regal
 import static org.jikesrvm.SizeConstants.BYTES_IN_ADDRESS;
 
 import java.util.Enumeration;
+
 import org.jikesrvm.ArchitectureSpecificOpt.PhysicalRegisterSet;
 import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.InterfaceMethodSignature;
 import org.jikesrvm.classloader.TypeReference;
 import org.jikesrvm.compilers.opt.DefUse;
@@ -111,7 +113,13 @@ public abstract class CallingConvention 
       if (MIR_Call.hasMethod(call)) {
         MethodOperand mo = MIR_Call.getMethod(call);
         if (mo.isInterface()) {
-          InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(mo.getMemberRef());
+          // Octet: Static cloning: Support multiple resolved methods for every method reference.
+          // Velodrome: Context: Interface invocation for non-application methods can only have VM_CONTEXT
+          int context = call.position.method.getStaticContext();
+          if (mo.hasTarget() && !Context.isApplicationPrefix(mo.getTarget().getDeclaringClass().getTypeRef())) {
+            context = Context.VM_CONTEXT;
+          }
+          InterfaceMethodSignature sig = InterfaceMethodSignature.findOrCreate(mo.getMemberRef(), context);
           MemoryOperand M =
               MemoryOperand.BD(ir.regpool.makeTROp(),
                                    ArchEntrypoints.hiddenSignatureIdField.getOffset(),
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/StackManager.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/StackManager.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/StackManager.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/regalloc/ia32/StackManager.java	2014-04-03 17:43:42.635669274 -0400
@@ -14,6 +14,8 @@ package org.jikesrvm.compilers.opt.regal
 
 import java.util.Enumeration;
 import java.util.Iterator;
+
+import org.jikesrvm.VM;
 import org.jikesrvm.classloader.TypeReference;
 import org.jikesrvm.compilers.opt.OptimizingCompilerException;
 import org.jikesrvm.compilers.opt.ir.Empty;
@@ -27,6 +29,7 @@ import org.jikesrvm.compilers.opt.ir.MIR
 import org.jikesrvm.compilers.opt.ir.IR;
 import org.jikesrvm.compilers.opt.ir.Instruction;
 import org.jikesrvm.compilers.opt.ir.Operator;
+
 import static org.jikesrvm.compilers.opt.ir.Operators.ADVISE_ESP;
 import static org.jikesrvm.compilers.opt.ir.Operators.BBEND;
 import static org.jikesrvm.compilers.opt.ir.Operators.CALL_SAVE_VOLATILE;
@@ -74,7 +77,9 @@ import org.jikesrvm.compilers.opt.ir.ope
 import org.jikesrvm.compilers.opt.regalloc.GenericStackManager;
 import org.jikesrvm.compilers.opt.regalloc.RegisterAllocatorState;
 import org.jikesrvm.ia32.ArchConstants;
+
 import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_ALIGNMENT;
+
 import org.jikesrvm.runtime.ArchEntrypoints;
 import org.jikesrvm.runtime.Entrypoints;
 import org.vmmagic.unboxed.Offset;
@@ -332,7 +337,8 @@ public abstract class StackManager exten
    * @param plg the prologue instruction
    */
   private void insertNormalStackOverflowCheck(Instruction plg) {
-    if (!ir.method.isInterruptible()) {
+    // Velodrome: Stack overflow: Insert stack overflow checks for all uninterruptible methods if assertions are turned on
+    if (!VM.VerifyAssertions && !ir.method.isInterruptible()) {
       plg.remove();
       return;
     }
@@ -369,7 +375,8 @@ public abstract class StackManager exten
    * @param plg the prologue instruction
    */
   private void insertBigFrameStackOverflowCheck(Instruction plg) {
-    if (!ir.method.isInterruptible()) {
+    // Velodrome: Stack overflow: Insert stack overflow checks for all uninterruptible methods if assertions are turned on
+    if (!VM.VerifyAssertions && !ir.method.isInterruptible()) {
       plg.remove();
       return;
     }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptExceptionDeliverer.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptExceptionDeliverer.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptExceptionDeliverer.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptExceptionDeliverer.java	2014-04-03 17:43:44.848676551 -0400
@@ -13,14 +13,19 @@
 package org.jikesrvm.compilers.opt.runtimesupport.ia32;
 
 import org.jikesrvm.ArchitectureSpecific;
-import org.jikesrvm.VM;
-import org.jikesrvm.Constants;
 import org.jikesrvm.ArchitectureSpecific.Registers;
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.compilers.common.CompiledMethod;
 import org.jikesrvm.compilers.opt.runtimesupport.OptCompiledMethod;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.ExceptionDeliverer;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.velodrome.TransactionalHBGraph;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.Unpreemptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
@@ -142,6 +147,16 @@ public abstract class OptExceptionDelive
     if (VM.VerifyAssertions) VM._assert(NUM_NONVOLATILE_FPRS == 0);
 
     registers.unwindStackFrame();
+    
+    // Velodrome: Decrement the transaction depth for the current thread
+    RVMMethod rMethod = compiledMethod.getMethod();
+    if (!rMethod.isNative()) {
+      if (Octet.shouldInstrumentMethod(rMethod) && (Velodrome.methodsAsTransactions() || rMethod.isSynchronized() && Velodrome.syncBlocksAsTransactions())) {
+        if (Context.isTRANSContext(rMethod.getStaticContext()) && Context.isNONTRANSContext(rMethod.getResolvedContext())) {
+          TransactionalHBGraph.handleExceptionDuringStackUnwinding(rMethod);
+        }
+      }
+    }
 
     if (TRACE) {
       VM.sysWrite("Registers after unwinding frame for ");
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java	2014-04-03 17:43:44.905676737 -0400
@@ -136,7 +136,8 @@ public final class OptCompiledMethod ext
       browser.setInlineEncodingIndex(iei);
       browser.setBytecodeIndex(map.getBytecodeIndexForMCOffset(instr));
       browser.setCompiledMethod(this);
-      browser.setMethod(MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod());
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      browser.setMethod(MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod(method.getStaticContext()));
 
       if (VM.TraceStackTrace) {
         VM.sysWrite("setting stack to frame (opt): ");
@@ -162,7 +163,8 @@ public final class OptCompiledMethod ext
 
       browser.setInlineEncodingIndex(next);
       browser.setBytecodeIndex(bci);
-      browser.setMethod(MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod());
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      browser.setMethod(MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod(method.getStaticContext()));
 
       if (VM.TraceStackTrace) {
         VM.sysWrite("up within frame stack (opt): ");
@@ -187,8 +189,9 @@ public final class OptCompiledMethod ext
       int bci = map.getBytecodeIndexForMCOffset(instructionOffset);
       for (int j = iei; j >= 0; j = OptEncodedCallSiteTree.getParent(j, inlineEncoding)) {
         int mid = OptEncodedCallSiteTree.getMethodID(j, inlineEncoding);
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
         NormalMethod m =
-            (NormalMethod) MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod();
+            (NormalMethod) MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod(method.getStaticContext());
         int lineNumber = m.getLineNumberForBCIndex(bci); // might be 0 if unavailable.
         out.print("\tat ");
         out.print(m.getDeclaringClass());
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptLinker.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptLinker.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptLinker.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptLinker.java	2014-04-03 17:43:44.847676547 -0400
@@ -51,17 +51,18 @@ public final class OptLinker implements 
     BytecodeStream bcodes = realMethod.getBytecodes();
     bcodes.reset(bci);
     int opcode = bcodes.nextInstruction();
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
     switch (opcode) {
       case JBC_getfield:
       case JBC_putfield:
       case JBC_getstatic:
       case JBC_putstatic:
-        TableBasedDynamicLinker.resolveMember(bcodes.getFieldReference());
+        TableBasedDynamicLinker.resolveMember(bcodes.getFieldReference(), cm.method.getStaticContext());
         break;
       case JBC_invokevirtual:
       case JBC_invokestatic:
       case JBC_invokespecial:
-        TableBasedDynamicLinker.resolveMember(bcodes.getMethodReference());
+        TableBasedDynamicLinker.resolveMember(bcodes.getMethodReference(), cm.method.getStaticContext());
         break;
       case JBC_invokeinterface:
       default:
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptMachineCodeMap.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptMachineCodeMap.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptMachineCodeMap.java	2013-02-12 13:28:49.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptMachineCodeMap.java	2014-04-03 17:43:44.906676740 -0400
@@ -13,28 +13,33 @@
 package org.jikesrvm.compilers.opt.runtimesupport;
 
 import java.util.ArrayList;
+
 import org.jikesrvm.ArchitectureSpecific;
-import org.jikesrvm.VM;
 import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
 import org.jikesrvm.adaptive.database.callgraph.CallSite;
-import org.jikesrvm.classloader.RVMArray;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.MemberReference;
-import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.classloader.MethodReference;
 import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMArray;
+import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.TypeReference;
 import org.jikesrvm.compilers.opt.OptimizingCompilerException;
 import org.jikesrvm.compilers.opt.driver.OptConstants;
 import org.jikesrvm.compilers.opt.inlining.CallSiteTree;
-import org.jikesrvm.compilers.opt.ir.MIR_Call;
 import org.jikesrvm.compilers.opt.ir.GCIRMap;
 import org.jikesrvm.compilers.opt.ir.GCIRMapElement;
 import org.jikesrvm.compilers.opt.ir.IR;
 import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.compilers.opt.ir.MIR_Call;
 import org.jikesrvm.compilers.opt.ir.operand.MethodOperand;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Offset;
 
+// Octet: Static cloning: Various changes in this class to support multiple resolved methods for every method reference.
+
 /**
  * A class that encapsulates mapping information about generated machine code.
  * Since there will be an instance of this class with every OptCompiledMethod,
@@ -73,10 +78,11 @@ public final class OptMachineCodeMap imp
   /**
    * Private constructor, object should be created via create
    */
-  private OptMachineCodeMap(int[] _MCInformation, int[] _gcMaps, int[] _inlineEncoding) {
+  private OptMachineCodeMap(int[] _MCInformation, int[] _gcMaps, int[] _inlineEncoding, int _context) {
     MCInformation = _MCInformation;
     gcMaps = _gcMaps;
     inlineEncoding = _inlineEncoding;
+    context = _context;
   }
 
   /**
@@ -86,6 +92,7 @@ public final class OptMachineCodeMap imp
     MCInformation = null;
     gcMaps = null;
     inlineEncoding = null;
+    context = Context.INVALID_CONTEXT;
   }
 
   /**
@@ -107,7 +114,7 @@ public final class OptMachineCodeMap imp
     }
 
     // create all machine code maps
-    final OptMachineCodeMap map = generateMCInformation(ir.MIRInfo.gcIRMap, DUMP_MAPS);
+    final OptMachineCodeMap map = generateMCInformation(ir.MIRInfo.gcIRMap, DUMP_MAPS, ir.getMethod().getStaticContext());
 
     if (DUMP_MAP_SIZES) {
       map.recordStats(ir.method,
@@ -158,7 +165,17 @@ public final class OptMachineCodeMap imp
       return null;
     }
     int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
-    return (NormalMethod) MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember();
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+    // Velodrome: Context: The method corresponding to the given machine code offset could be a library method
+    // which will not have any context matches other than VM_CONTEXT
+    MethodReference mRef = MemberReference.getMemberRef(mid).asMethodReference();
+    int con = context;
+    if (!Context.isApplicationPrefix(mRef.getType()) && con != Context.VM_CONTEXT) {
+      con = Context.VM_CONTEXT;
+    }
+    RVMMethod m = mRef.getResolvedMember(con);
+    if (VM.VerifyAssertions) { VM._assert(m != null); }
+    return (NormalMethod) m;
   }
 
   /**
@@ -207,7 +224,7 @@ public final class OptMachineCodeMap imp
           int iei = getInlineEncodingIndex(entry);
           if (iei != -1) {
             int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
-            RVMMethod caller = MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod();
+            RVMMethod caller = MemberReference.getMemberRef(mid).asMethodReference().peekResolvedMethod(context);
             if (caller != null) {
               if (ans == null) ans = new ArrayList<CallSite>();
               ans.add(new CallSite(caller, bcIndex));
@@ -330,7 +347,7 @@ public final class OptMachineCodeMap imp
    *  @param irMap  the irmap to translate from
    *  @param DUMP_MAPS dump while we work
    */
-  private static OptMachineCodeMap generateMCInformation(GCIRMap irMap, boolean DUMP_MAPS) {
+  private static OptMachineCodeMap generateMCInformation(GCIRMap irMap, boolean DUMP_MAPS, int context) {
     CallSiteTree inliningMap = new CallSiteTree();
     int numEntries = 0;
 
@@ -462,8 +479,7 @@ public final class OptMachineCodeMap imp
     int[] mcInformation = new int[lastMCInfoEntry];
     System.arraycopy(tmpMC, 0, mcInformation, 0, mcInformation.length);
     int[] gcMaps = gcMapBuilder.finish();
-
-    return new OptMachineCodeMap(mcInformation, gcMaps, inlineEncoding);
+    return new OptMachineCodeMap(mcInformation, gcMaps, inlineEncoding, context);
   }
 
   ////////////////////////////////////////////
@@ -644,7 +660,7 @@ public final class OptMachineCodeMap imp
       boolean first = true;
       while (iei >= 0) {
         int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
-        RVMMethod meth = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember();
+        RVMMethod meth = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember(context);
         if (first) {
           first = false;
           VM.sysWrite("\n\tIn method    " + meth + " at bytecode " + bci);
@@ -807,6 +823,9 @@ public final class OptMachineCodeMap imp
    * encoded data as defined by OptEncodedCallSiteTree.
    */
   public final int[] inlineEncoding;
+  
+  private final int context;
+  
   /**
    * Running totals for the size of machine code and maps
    */
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/Simplifier.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/Simplifier.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/Simplifier.java	2013-02-12 13:28:48.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/Simplifier.java	2014-04-03 17:43:43.169671030 -0400
@@ -23,6 +23,7 @@ import java.lang.reflect.Method;
 
 import org.jikesrvm.VM;
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.RVMType;
@@ -3200,7 +3201,8 @@ public abstract class Simplifier extends
         } else if (calleeThis.isConstant() || calleeThis.asRegister().isPreciseType()) {
           TypeReference calleeClass = calleeThis.getType();
           if (calleeClass.isResolved()) {
-            methOp.refine(calleeClass.peekType());
+            // Octet: Static cloning: Support multiple resolved methods for every method reference.
+            methOp.refine(calleeClass.peekType(), s.position.method.getStaticContext());
             return DefUseEffect.UNCHANGED;
           }
         }
@@ -3243,6 +3245,10 @@ public abstract class Simplifier extends
       } else if (methOp.hasPreciseTarget() && methOp.getTarget().isPure()) {
         // Look for a precise method call to a pure method with all constant arguments
         RVMMethod method = methOp.getTarget();
+
+        // Octet: Static cloning: The compiler should always call the VM-context version of this method, rather than possibly the APP-context version.
+        method = method.getMemberRef().asMethodReference().getResolvedMember(Context.VM_CONTEXT);
+
         int n = Call.getNumberOfParams(s);
         for(int i=0; i < n; i++) {
           Operand param = Call.getParam(s,i);
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptInstr.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptInstr.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptInstr.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptInstr.java	2014-04-03 17:43:44.846676543 -0400
@@ -0,0 +1,583 @@
+package org.jikesrvm.compilers.opt;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.compilers.opt.driver.OptConstants;
+import org.jikesrvm.compilers.opt.hir2lir.ConvertToLowLevelIR;
+import org.jikesrvm.compilers.opt.ir.ALoad;
+import org.jikesrvm.compilers.opt.ir.AStore;
+import org.jikesrvm.compilers.opt.ir.Call;
+import org.jikesrvm.compilers.opt.ir.GetField;
+import org.jikesrvm.compilers.opt.ir.GetStatic;
+import org.jikesrvm.compilers.opt.ir.IR;
+import org.jikesrvm.compilers.opt.ir.IRTools;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.compilers.opt.ir.Load;
+import org.jikesrvm.compilers.opt.ir.Move;
+import org.jikesrvm.compilers.opt.ir.Operators;
+import org.jikesrvm.compilers.opt.ir.Prologue;
+import org.jikesrvm.compilers.opt.ir.PutField;
+import org.jikesrvm.compilers.opt.ir.PutStatic;
+import org.jikesrvm.compilers.opt.ir.Return;
+import org.jikesrvm.compilers.opt.ir.Store;
+import org.jikesrvm.compilers.opt.ir.operand.LocationOperand;
+import org.jikesrvm.compilers.opt.ir.operand.MethodOperand;
+import org.jikesrvm.compilers.opt.ir.operand.Operand;
+import org.jikesrvm.compilers.opt.ir.operand.RegisterOperand;
+import org.jikesrvm.octet.CFGVisualization;
+import org.jikesrvm.octet.InstrDecisions;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.Site;
+import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.util.HashSetRVM;
+import org.jikesrvm.velodrome.Velodrome;
+
+public class VelodromeOptInstr extends OctetOptInstr implements Operators, OptConstants {
+
+  public VelodromeOptInstr(boolean late, RedundantBarrierRemover redundantBarrierRemover) {
+    super(late, redundantBarrierRemover);
+  }
+  
+  @Override
+  public String getName() {
+    return "Velodrome instrumentation";
+  }
+  
+  // Class to store the <current instr, post instr> information, a tuple indicates that 
+  // the post instr needs to be inserted after current instr in the FCFG.
+  public static final class InstrInfoWrapper {
+    Instruction currInstr;
+    Instruction postInstr;
+    
+    public void addInstrInfo(Instruction inst, Instruction post) {
+      this.currInstr = inst;
+      this.postInstr = post;
+    }
+  }
+  
+  @Override
+  public void perform(IR ir) {
+
+    if(ir.options.VISUALIZE_CFG) {
+      CFGVisualization cfg = new CFGVisualization(ir, "beforeVelodrome");
+      cfg.visualizeCFG(ir);
+    }
+
+    if (VM.VerifyAssertions) {
+      slowPathsInstrumented = new HashSetRVM<Instruction>();
+    }
+
+    HashSetRVM<Instruction> callsToInline = null;
+    HashSetRVM<InstrInfoWrapper> postInstrInfo = new HashSetRVM<InstrInfoWrapper>();
+
+    if (inliningType == InliningType.JIKES_INLINER) {
+      ir.gc.resync(); // resync generation context; needed since Jikes inlining may occur
+      callsToInline = new HashSetRVM<Instruction>();
+    }
+
+    if (verbose) {
+      System.out.println("Method before: " + ir.getMethod());
+      ir.printInstructions();
+    }
+
+    for (Instruction inst = ir.firstInstructionInCodeOrder(); inst != null; inst = inst.nextInstructionInCodeOrder()) {
+      if (inst.isPossibleSharedMemoryAccess() || (Octet.getClientAnalysis().instrInstructionHasRedundantBarrier(inst))) {
+        instrumentInst(inst, callsToInline, ir, postInstrInfo);
+        inst.clearAsPossibleSharedMemoryAccess();
+      } else {
+        instrumentOtherInstTypes(inst, callsToInline, ir, postInstrInfo);
+      }
+    }
+
+    // We insert post instructions for transaction exit and read/write barriers
+    if (Velodrome.insertPostBarriers() || (Velodrome.methodsAsTransactions() 
+        || (Velodrome.syncBlocksAsTransactions() && ir.getMethod().isSynchronized()))) {
+      for (InstrInfoWrapper instr : postInstrInfo) {
+        Instruction curInst = instr.currInstr;
+        Instruction postInstr = instr.postInstr;
+        if (VM.VerifyAssertions) { VM._assert(testPostCall(postInstr, curInst, ir)); }
+        curInst.insertAfter(postInstr);
+      }
+    }
+
+    if (verbose) {
+      System.out.println("Method after: " + ir.getMethod());
+      ir.printInstructions();
+    }
+
+    if (inliningType == InliningType.JIKES_INLINER) {
+      for (Instruction call : callsToInline) {
+        Instruction inst = call.nextInstructionInCodeOrder();
+        // Setting no callee exceptions might be incorrect for analyses that
+        // want to throw exceptions out of the slow path, so allow analyses to override this.
+        // Octet: TODO: trying this -- does it help STM?
+        inline(call, ir, !Octet.getClientAnalysis().barriersCanThrowExceptions());
+        // Make optimistic RBA safe by executing barriers for recently acquired objects.
+        if (!inst.hasRedundantBarrier() || !Octet.getConfig().isFieldSensitiveAnalysis()) {
+          makeRedundantBarriersSafe(inst, null, ir);
+        }
+      }
+    }
+
+    // Check that all instructions were instrumented.  While it seems like iterating over
+    // all instructions above should accomplish this, the facts that instructions get inserted --
+    // and particularly because BBs get split -- can cause problems, particularly if
+    // the "next" instruction is determined prior to inserting barrier code (which is avoided above).
+    if (VM.VerifyAssertions) {
+      if (!Octet.getConfig().isFieldSensitiveAnalysis()) {
+        for (Instruction inst = ir.firstInstructionInCodeOrder(); inst != null; inst = inst.nextInstructionInCodeOrder()) {
+          VM._assert(!inst.isPossibleSharedMemoryAccess());
+        }
+      }
+    }
+    if(ir.options.VISUALIZE_CFG) {
+      CFGVisualization cfgAfter = new CFGVisualization(ir, "afterVelodrome");
+      cfgAfter.visualizeCFG(ir);
+    }
+  }  
+  
+  void instrumentInst(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir, HashSetRVM<InstrInfoWrapper> instrumentedInsts) {
+    if (GetField.conforms(inst) || PutField.conforms(inst)) {
+      if (VM.VerifyAssertions) { VM._assert(!lateInstr); }
+      instrumentScalarAccess(inst, callsToInline, ir, instrumentedInsts);
+    } else if (ALoad.conforms(inst) || AStore.conforms(inst)) {
+      // Conditional instrumentation of array accesses
+      if (Velodrome.instrumentArrays()) {
+        instrumentArrayAccess(inst, callsToInline, ir, instrumentedInsts);
+      }
+    } else if (GetStatic.conforms(inst) || PutStatic.conforms(inst)) {
+      if (VM.VerifyAssertions) { VM._assert(!lateInstr); }
+      instrumentStaticAccess(inst, callsToInline, ir, instrumentedInsts);
+    } else if (Load.conforms(inst) || Store.conforms(inst)) {
+      if (VM.VerifyAssertions) { VM._assert(lateInstr); }
+      Operand tempRef = Load.conforms(inst) ? Load.getAddress(inst) : Store.getAddress(inst);
+      boolean isStatic = tempRef.isIntConstant() && tempRef.asIntConstant().value == Magic.getTocPointer().toInt();
+      if (isStatic) {
+        instrumentStaticAccess(inst, callsToInline, ir, instrumentedInsts);
+      } else {
+        instrumentScalarAccess(inst, callsToInline, ir, instrumentedInsts);
+      }
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(false); }
+    }
+  }
+
+  /**
+   * Velodrome wants to instrument few additional instructions over Octet
+   * @param inst
+   * @param callsToInline
+   * @param ir
+   */
+  public void instrumentOtherInstTypes(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir,
+      HashSetRVM<InstrInfoWrapper> instrumentedInstrs) {
+    // position attribute may not always be set for non-read/write instructions, so cannot directly use
+    // OctetOptSelection::shouldInstrumentInstPosition(), but then again getSite() will fail if position is not set
+    
+    if (OctetOptSelection.shouldInstrumentInstPosition(inst, ir)) {
+      if (Velodrome.methodsAsTransactions() || (Velodrome.syncBlocksAsTransactions() && inst.position.getMethod().isSynchronized())) {
+        NormalMethod method = inst.position.getMethod();
+        
+        if (Prologue.conforms(inst)) { // Method entry
+          // Insert the debug method first
+          if (Velodrome.checkMethodContextAtProlog() && Context.isApplicationPrefix(inst.position.getMethod().getDeclaringClass().getTypeRef())) {
+            insertVerifyApplicationContext(inst);
+          }
+          // Insert at all prologs, this call instruction should get sandwiched between
+          // the prolog and the "just above" context debug call 
+          if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+            instrumentTransactionEntry(inst, callsToInline, ir);
+          }
+        } else if (Return.conforms(inst)) { // Method exit
+          if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+            instrumentTransactionExit(inst, callsToInline, ir, instrumentedInstrs);
+          }
+        }
+        
+      } 
+      if (Velodrome.syncBlocksAsTransactions()) {
+        if (inst.getOpcode() == MONITORENTER_opcode ) { // Monitor entry
+          instrumentTransactionEntry(inst, callsToInline, ir);
+        } else if (inst.getOpcode() == MONITOREXIT_opcode) { // Monitor exit
+          instrumentTransactionExit(inst, callsToInline, ir, instrumentedInstrs);
+        }
+      }
+    }
+  }
+  
+  /**
+   * Insert instrumentation at method entry, or monitor entry
+   * @param inst
+   * @param callsToInline
+   * @param ir
+   */
+  void instrumentTransactionEntry(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir) {
+    int methodID = inst.position.getMethod().getId();
+    int siteID = InstrDecisions.passSite() ? Site.getSite(inst) : 0;
+    NormalMethod barrierMethod = Entrypoints.velodromeStartTransactionMethod;
+    Instruction barrierCall = Call.create2(CALL, 
+                                            null, 
+                                            IRTools.AC(barrierMethod.getOffset()), 
+                                            MethodOperand.STATIC(barrierMethod), 
+                                            IRTools.IC(siteID),
+                                            IRTools.IC(methodID));
+    barrierCall.bcIndex = inst.bcIndex;
+    barrierCall.position = inst.position;
+    inst.insertAfter(barrierCall); // Insert after the prolog instruction
+    if (Velodrome.inlineStartEndTransactions()) {
+      inlineInstrs(barrierCall, inst, callsToInline);
+    }
+  }
+  
+  /** Insert call to debug method to verify contexts */
+  void insertVerifyApplicationContext(Instruction inst) {
+    NormalMethod barrierMethod = Entrypoints.velodromeCheckMethodContextAtPrologMethod;
+    Instruction barrierCall = Call.create0(CALL, null, IRTools.AC(barrierMethod.getOffset()), MethodOperand.STATIC(barrierMethod));
+    barrierCall.bcIndex = inst.bcIndex;
+    barrierCall.position = inst.position;
+    inst.insertAfter(barrierCall);
+  }
+
+  // Inline if using Jikes inliner
+  private void inlineInstrs(Instruction barrierCall, Instruction inst, HashSetRVM<Instruction> callsToInline) {
+    // Velodrome: LATER: Is it necessary to check for frequency?
+    if (inliningType == InliningType.JIKES_INLINER && !inst.getBasicBlock().getInfrequent()) {
+      callsToInline.add(barrierCall);
+    }    
+  }
+
+  /**
+   * Insert instrumentation before method exit, monitor exit
+   * @param inst
+   * @param callsToInline
+   * @param ir
+   */
+  void instrumentTransactionExit(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir, HashSetRVM<InstrInfoWrapper> instrumentedInstrs) {
+    int methodID = inst.position.getMethod().getId();
+    int siteID = InstrDecisions.passSite() ? Site.getSite(inst) : 0;
+    NormalMethod barrierMethod = Entrypoints.velodromeEndTransactionMethod;
+    Instruction barrierCall = Call.create2(CALL, 
+                                            null, 
+                                            IRTools.AC(barrierMethod.getOffset()), 
+                                            MethodOperand.STATIC(barrierMethod), 
+                                            IRTools.IC(siteID),
+                                            IRTools.IC(methodID));
+    barrierCall.bcIndex = inst.bcIndex;
+    barrierCall.position = inst.position;
+    // Velodrome: TODO: Do not insert barrierCall into the instruction stream immediately. Why?
+//    InstrInfoWrapper wrapper = new InstrInfoWrapper();
+//    wrapper.addInstrInfo(inst, barrierCall);
+//    instrumentedInstrs.add(wrapper);
+    inst.insertBefore(barrierCall); // Insert before the return instruction
+    if (Velodrome.inlineStartEndTransactions()) {
+      inlineInstrs(barrierCall, inst, callsToInline);
+    }
+  }
+  
+  /** <ol> 
+   * <li> Pass Velodrome metadata write and read offsets for all. 
+   * <li> Pass the element size for arrays. 
+   * </ol>*/
+  @Override
+  void passExtra(Instruction inst, FieldReference fieldRef, Instruction barrier) {    
+    // param: Velodrome metadata write and read offsets, note that zero is a valid offset
+    int writeOffset = Velodrome.UNITIALIZED_OFFSET;
+    int readOffset = Velodrome.UNITIALIZED_OFFSET;
+    if (Velodrome.addPerFieldVelodromeMetadata()) {
+      if (fieldRef != null && fieldRef.getResolvedField() != null) {
+        RVMField field = fieldRef.getResolvedField();
+        if (field.hasVelodromeMetadataOffset()) {
+          writeOffset = field.getWriteMetadataOffset().toInt();
+          readOffset = field.getReadMetadataOffset().toInt();
+        }
+      }
+    }
+    // We always pass the metadata offsets
+    addParam(barrier, IRTools.IC(writeOffset));
+    addParam(barrier, IRTools.IC(readOffset));
+
+    if (fieldRef == null) { // fieldRef is null for array accesses
+      boolean isRead = ALoad.conforms(inst);
+      LocationOperand loc = isRead ? ALoad.getLocation(inst) : AStore.getLocation(inst);
+      if (VM.VerifyAssertions) { VM._assert(loc.isArrayAccess()); }
+      Operand ref = isRead ? ALoad.getArray(inst) : AStore.getArray(inst);
+      TypeReference elemType = ref.getType().getArrayElementType();
+      addParam(barrier, IRTools.IC(elemType.getMemoryBytes()));
+    }
+  }
+
+  void instrumentScalarAccess(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir, 
+      HashSetRVM<InstrInfoWrapper> instrumentedInstrs) {
+    boolean isRead;
+    LocationOperand loc;
+    Operand ref = null;
+    if (!lateInstr) {
+      isRead = GetField.conforms(inst);
+      loc = isRead ? GetField.getLocation(inst) : PutField.getLocation(inst);
+      ref = isRead ? GetField.getRef(inst) : PutField.getRef(inst);
+    } else {
+      isRead = Load.conforms(inst);
+      loc = isRead ? Load.getLocation(inst) : Store.getLocation(inst);
+      if (VM.VerifyAssertions) { VM._assert(loc != null && loc.isFieldAccess()); }
+      Operand tempRef = isRead ? Load.getAddress(inst) : Store.getAddress(inst);
+      if (VM.VerifyAssertions) { VM._assert(!(tempRef.isIntConstant() && tempRef.asIntConstant().value == Magic.getTocPointer().toInt())); }
+      ref = tempRef;
+    }
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    if (VM.VerifyAssertions && isResolved) { VM._assert(!field.isStatic()); }
+
+    int fieldInfo = 0;
+    if (InstrDecisions.passFieldInfo()) {
+      // Octet: TODO: we could still call the resolved barrier if doing late instrumentation,
+      // since the offset will be in a virtual register
+      if (isResolved && InstrDecisions.useFieldOffset()) {
+        fieldInfo = getFieldOffset(field);
+      } else {
+        fieldInfo = fieldRef.getId();
+      }
+    }
+    NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(ir.getMethod(), isRead, true, isResolved, false, inst.hasRedundantBarrier(), isSpecializedMethod(ir));
+    Instruction barrierCall = Call.create2(CALL,
+                                            null,
+                                            IRTools.AC(barrierMethod.getOffset()),
+                                            MethodOperand.STATIC(barrierMethod),
+                                            ref.copy(),
+                                            IRTools.IC(fieldInfo));
+    barrierCall.position = inst.position;
+    barrierCall.bcIndex = inst.bcIndex;
+    // Octet: LATER: try this
+    /*
+    if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+      barrierCall.markAsNonPEI();
+    }
+     */
+    finishParams(inst, fieldRef, barrierCall);
+    insertBarrier(barrierCall, inst, isRead, ref, field, isResolved, callsToInline, ir);
+    
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      Operand base = ref.copy();
+      // First make a backup of the object reference
+      if (isRead) { // Getfield
+        // This code block assumes early assertion, this assertion helps in sanity check
+        if (VM.VerifyAssertions) { VM._assert(!lateInstr); }
+        if (GetField.getResult(inst).isRegister() && GetField.getRef(inst).isRegister()) { // LHS is a register operand
+          if (GetField.getResult(inst).getRegister() == GetField.getRef(inst).asRegister().getRegister()) {
+            // Register is same on LHS and RHS
+            RegisterOperand t = ir.regpool.makeTempAddress();
+            Instruction backupObjRef = Move.create(REF_MOVE, t, ref.copy());
+            backupObjRef.position = inst.position;
+            backupObjRef.bcIndex = inst.bcIndex;
+            inst.insertBefore(backupObjRef);
+            base = t;
+          }
+        }
+      }
+
+      NormalMethod postBarrierMethod = (isResolved) ? Entrypoints.velodromeUnlockMetadataForResolvedFieldMethod 
+                                                    : Entrypoints.velodromeUnlockMetadataForUnresolvedFieldMethod;
+      int writeOffset = Velodrome.UNITIALIZED_OFFSET;
+      if (isResolved && field.hasVelodromeMetadataOffset()) {
+        writeOffset = field.getWriteMetadataOffset().toInt();
+      } else {
+        writeOffset = fieldRef.getId();
+      }      
+      int siteID = InstrDecisions.passSite() ? Site.getSite(inst) : 0;
+      int read = (isRead) ? 1 : 0;
+      Instruction postBarrierCall = Call.create4(CALL,
+                                                  null,
+                                                  IRTools.AC(postBarrierMethod.getOffset()),
+                                                  MethodOperand.STATIC(postBarrierMethod),
+                                                  base.copy(),
+                                                  IRTools.IC(writeOffset),
+                                                  IRTools.IC(siteID),
+                                                  IRTools.IC(read));
+      postBarrierCall.position = inst.position;
+      postBarrierCall.bcIndex = inst.bcIndex;
+      InstrInfoWrapper wrapper = new InstrInfoWrapper();
+      wrapper.addInstrInfo(inst, postBarrierCall);
+      instrumentedInstrs.add(wrapper);
+    }
+  }
+  
+  /** Insert instrumentation to unlock metadata after the actual access */
+  private boolean testPostCall(Instruction postBarrier, Instruction inst, IR ir) {
+    RVMMethod target = Call.getMethod(postBarrier).getTarget();
+    int numParams = target.getParameterTypes().length;
+    if (Call.getNumberOfParams(postBarrier) != numParams) {
+      System.out.println(postBarrier);
+      System.out.println(inst);
+      VM.sysFail("Bad match");
+      return false;
+    }
+    // If in LIR, the call needs to be lowered to LIR
+    if (lateInstr) {
+      ConvertToLowLevelIR.callHelper(postBarrier, ir);
+    }
+    return true;
+  }
+  
+  void instrumentStaticAccess(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir, HashSetRVM<InstrInfoWrapper> instrumentedInstrs) {
+    boolean isRead;
+    LocationOperand loc;
+    if (!lateInstr) {
+      isRead = GetStatic.conforms(inst);
+      loc = isRead ? GetStatic.getLocation(inst) : PutStatic.getLocation(inst);
+    } else {
+      isRead = Load.conforms(inst);
+      loc = isRead ? Load.getLocation(inst) : Store.getLocation(inst);
+      if (VM.VerifyAssertions) { VM._assert(loc.isFieldAccess()); }
+      Operand tempRef = isRead ? Load.getAddress(inst) : Store.getAddress(inst);
+      if (VM.VerifyAssertions) { VM._assert(tempRef.isIntConstant() && tempRef.asIntConstant().value == Magic.getTocPointer().toInt()); }
+    }
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    if (VM.VerifyAssertions && isResolved) { VM._assert(field.isStatic()); }
+
+    int fieldInfo = 0;
+    if (InstrDecisions.passFieldInfo()) {
+      if (isResolved && InstrDecisions.useFieldOffset()) {
+        fieldInfo = getFieldOffset(field);
+      } else {
+        fieldInfo = fieldRef.getId();
+      }
+    }
+
+    NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(ir.getMethod(), isRead, true, isResolved, true, inst.hasRedundantBarrier(), isSpecializedMethod(ir));
+    Instruction barrierCall;
+    barrierCall = Call.create1(CALL,
+                                null,
+                                IRTools.AC(barrierMethod.getOffset()),
+                                MethodOperand.STATIC(barrierMethod),
+                                IRTools.IC(fieldInfo)); // need to pass the field ID even if field info isn't needed,
+                                                        // since it's needed to get the metadata offset    
+    barrierCall.position = inst.position;
+    barrierCall.bcIndex = inst.bcIndex;
+    // Octet: LATER: try this
+    /*
+    if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+      barrierCall.markAsNonPEI();
+    }
+     */
+    finishParams(inst, fieldRef, barrierCall);
+    insertBarrier(barrierCall, inst, isRead, null, field, isResolved, callsToInline, ir);
+    
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      NormalMethod postBarrierMethod = isResolved ? Entrypoints.velodromeUnlockMetadataForStaticResolvedMethod
+                                                  : Entrypoints.velodromeUnlockMetadataForStaticUnresolvedMethod;
+      Instruction postBarrierCall;
+      int info = 0;
+      int siteID = InstrDecisions.passSite() ? Site.getSite(inst) : 0;
+      int read = (isRead) ? 1 : 0 ;
+      if (isResolved) {
+        int writeOffset = Velodrome.UNITIALIZED_OFFSET;;
+        if (Velodrome.addPerFieldVelodromeMetadata()) {
+          writeOffset = field.getWriteMetadataOffset().toInt();
+        }
+        if (InstrDecisions.passFieldInfo() && InstrDecisions.useFieldOffset()) {
+          info = getFieldOffset(field);
+        }
+        postBarrierCall = Call.create4(CALL, 
+                                        null, 
+                                        IRTools.AC(postBarrierMethod.getOffset()), 
+                                        MethodOperand.STATIC(postBarrierMethod), 
+                                        IRTools.IC(writeOffset), 
+                                        IRTools.IC(info),
+                                        IRTools.IC(siteID),
+                                        IRTools.IC(read));
+      } else {
+        info = fieldRef.getId();
+        postBarrierCall = Call.create3(CALL, 
+                                        null, 
+                                        IRTools.AC(postBarrierMethod.getOffset()), 
+                                        MethodOperand.STATIC(postBarrierMethod), 
+                                        IRTools.IC(info),
+                                        IRTools.IC(siteID),
+                                        IRTools.IC(read));
+      }
+      postBarrierCall.position = inst.position;
+      postBarrierCall.bcIndex = inst.bcIndex;
+      InstrInfoWrapper wrapper = new InstrInfoWrapper();
+      wrapper.addInstrInfo(inst, postBarrierCall);
+      instrumentedInstrs.add(wrapper);
+    }    
+  }
+  
+  void instrumentArrayAccess(Instruction inst, HashSetRVM<Instruction> callsToInline, IR ir,
+      HashSetRVM<InstrInfoWrapper> instrumentedInstrs) {
+    boolean isRead = ALoad.conforms(inst);
+    LocationOperand loc = isRead ? ALoad.getLocation(inst) : AStore.getLocation(inst);
+    if (VM.VerifyAssertions) { VM._assert(loc.isArrayAccess()); }
+    Operand ref = isRead ? ALoad.getArray(inst) : AStore.getArray(inst);
+    Operand index = isRead ? ALoad.getIndex(inst) : AStore.getIndex(inst);
+
+    NormalMethod barrierMethod = Octet.getClientAnalysis().chooseBarrier(ir.getMethod(), isRead, false, true, false, inst.hasRedundantBarrier(), isSpecializedMethod(ir));
+    Instruction barrierCall = Call.create2(CALL,
+                                            null,
+                                            IRTools.AC(barrierMethod.getOffset()),
+                                            MethodOperand.STATIC(barrierMethod),
+                                            ref.copy(),
+                                            index.copy());
+    barrierCall.position = inst.position;
+    barrierCall.bcIndex = inst.bcIndex;
+    // Octet: LATER: try this
+    /*
+    if (!Octet.getClientAnalysis().barriersCanThrowExceptions()) {
+      barrierCall.markAsNonPEI();
+    }
+     */
+    
+    // Add site id and array element size 
+    finishParams(inst, null, barrierCall);
+    insertBarrier(barrierCall, inst, isRead, ref, null, true, callsToInline, ir);
+    
+    // Velodrome: Inserting instrumentation to release metadata lock
+    if (Velodrome.insertPostBarriers()) {
+      Operand base = ref.copy();
+      // First make a backup of the object reference
+      if (isRead) { // Getfield
+        // This code block assumes early assertion, this assertion helps in sanity check
+        if (VM.VerifyAssertions) { VM._assert(!lateInstr); }
+        if (GetField.getResult(inst).isRegister() && GetField.getRef(inst).isRegister()) { // LHS is a register operand
+          if (GetField.getResult(inst).getRegister() == GetField.getRef(inst).asRegister().getRegister()) {
+            // Register is same on LHS and RHS
+            RegisterOperand t = ir.regpool.makeTempAddress();
+            Instruction backupObjRef = Move.create(REF_MOVE, t, ref.copy());
+            backupObjRef.position = inst.position;
+            backupObjRef.bcIndex = inst.bcIndex;
+            inst.insertBefore(backupObjRef);
+            base = t;
+          }
+        }
+      }
+
+      NormalMethod postBarrierMethod = Entrypoints.velodromeArrayPostBarrierMethod; 
+      int siteID = InstrDecisions.passSite() ? Site.getSite(inst) : 0;
+      int read = (isRead) ? 1 : 0;
+      Instruction postBarrierCall = Call.create4(CALL,
+                                                  null,
+                                                  IRTools.AC(postBarrierMethod.getOffset()),
+                                                  MethodOperand.STATIC(postBarrierMethod),
+                                                  base.copy(),
+                                                  index.copy(),
+                                                  IRTools.IC(siteID),
+                                                  IRTools.IC(read));
+      postBarrierCall.position = inst.position;
+      postBarrierCall.bcIndex = inst.bcIndex;
+      InstrInfoWrapper wrapper = new InstrInfoWrapper();
+      wrapper.addInstrInfo(inst, postBarrierCall);
+      instrumentedInstrs.add(wrapper);
+    }
+    
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptSelection.java workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptSelection.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptSelection.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/compilers/opt/VelodromeOptSelection.java	2014-04-03 17:43:43.925673516 -0400
@@ -0,0 +1,93 @@
+package org.jikesrvm.compilers.opt;
+
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.compilers.opt.escape.FI_EscapeSummary;
+import org.jikesrvm.compilers.opt.ir.ALoad;
+import org.jikesrvm.compilers.opt.ir.AStore;
+import org.jikesrvm.compilers.opt.ir.GetField;
+import org.jikesrvm.compilers.opt.ir.GetStatic;
+import org.jikesrvm.compilers.opt.ir.IR;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.compilers.opt.ir.PutField;
+import org.jikesrvm.compilers.opt.ir.PutStatic;
+import org.jikesrvm.compilers.opt.ir.operand.LocationOperand;
+import org.jikesrvm.compilers.opt.ir.operand.Operand;
+import org.jikesrvm.velodrome.Velodrome;
+import org.jikesrvm.velodrome.VelodromeInstrDecisions;
+
+public class VelodromeOptSelection extends OctetOptSelection {
+  
+  public VelodromeOptSelection() {
+    
+  }
+  
+  @Override
+  public String getName() {
+    return "Velodrome read and write selection";
+  }
+
+  @Override
+  void processInst(Instruction inst, FI_EscapeSummary escapeSummary, IR ir) {
+    boolean shouldInstrument = false;
+    if (GetField.conforms(inst) || PutField.conforms(inst)) {
+      shouldInstrument = shouldInstrumentInstPosition(inst, ir) && shouldInstrumentScalarAccess(inst, escapeSummary);
+    } else if (ALoad.conforms(inst) || AStore.conforms(inst)) {
+      // Conditional instrumentation of array accesses
+      if (Velodrome.instrumentArrays()) {
+        shouldInstrument = shouldInstrumentInstPosition(inst, ir) && shouldInstrumentArrayAccess(inst, escapeSummary);
+      }
+    } else if (GetStatic.conforms(inst) || PutStatic.conforms(inst)) {
+      shouldInstrument = shouldInstrumentInstPosition(inst, ir) && shouldInstrumentStaticAccess(inst);
+    }
+    if (shouldInstrument) {
+      inst.markAsPossibleSharedMemoryAccess();
+    }
+  }
+
+  @Override
+  boolean shouldInstrumentScalarAccess(Instruction inst, FI_EscapeSummary escapeSummary) {
+    // are we early or late in the compilation process?  use a different strategy in each case
+    boolean isRead = GetField.conforms(inst);
+    LocationOperand loc = isRead ? GetField.getLocation(inst) : PutField.getLocation(inst);
+    Operand ref = isRead ? GetField.getRef(inst) : PutField.getRef(inst);
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    boolean mightHaveMetadata;
+    if (isResolved) {
+      mightHaveMetadata = VelodromeInstrDecisions.objectOrFieldHasVelodromeMetadata(field);
+    } else {
+      mightHaveMetadata = VelodromeInstrDecisions.objectOrFieldMightHaveVelodromeMetadata(fieldRef);
+    }
+    if (mightHaveMetadata) {
+      if (mightEscape(ref, escapeSummary)) {
+        return true;
+      } else {
+        // Helps with debugging
+        // inst.markThreadLocal();
+      }
+    }
+    return false;
+  }
+
+  @Override
+  boolean shouldInstrumentStaticAccess(Instruction inst) {
+    boolean isRead = GetStatic.conforms(inst);
+    LocationOperand loc = isRead ? GetStatic.getLocation(inst) : PutStatic.getLocation(inst);
+    FieldReference fieldRef = loc.getFieldRef();
+    RVMField field = fieldRef.peekResolvedField();
+    boolean isResolved = (field != null);
+    boolean mightHaveMetadata;
+    if (isResolved) {
+      mightHaveMetadata = VelodromeInstrDecisions.staticFieldHasVelodromeMetadata(field);
+    } else {
+      mightHaveMetadata = VelodromeInstrDecisions.staticFieldMightHaveVelodromeMetadata(fieldRef);
+    }
+    if (mightHaveMetadata) {
+      return true;
+    }
+    return false;
+  }
+
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommForceNoInlining.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommForceNoInlining.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommForceNoInlining.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommForceNoInlining.java	2014-04-03 17:43:46.411681687 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class BarriersNoCommForceNoInlining extends BarriersNoComm {
+
+  @Override @Pure
+  public boolean inlineBarriers() { return false; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommForceUseJikesInliner.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommForceUseJikesInliner.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommForceUseJikesInliner.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommForceUseJikesInliner.java	2014-04-03 17:43:46.401681653 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class BarriersNoCommForceUseJikesInliner extends BarriersNoComm {
+
+  @Override @Pure
+  public boolean forceUseJikesInliner() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoComm.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoComm.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoComm.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoComm.java	2014-04-03 17:43:46.399681647 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class BarriersNoComm extends HeaderWordAlloc {
+
+  @Override @Pure
+  public boolean insertBarriers() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommNoRba.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommNoRba.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommNoRba.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommNoRba.java	2014-04-03 17:43:46.404681664 -0400
@@ -0,0 +1,18 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class BarriersNoCommNoRba extends BarriersNoComm {
+
+  @Override
+  @Pure
+  @Interruptible
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() {
+    return RedundantBarrierRemover.AnalysisLevel.NONE;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommSafeOptimisticRba.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommSafeOptimisticRba.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommSafeOptimisticRba.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommSafeOptimisticRba.java	2014-04-03 17:43:46.407681675 -0400
@@ -0,0 +1,25 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class BarriersNoCommSafeOptimisticRba extends BarriersNoComm {
+
+  @Override
+  @Pure
+  @Interruptible
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() {
+    return RedundantBarrierRemover.AnalysisLevel.OPTIMISTIC_SAFE;
+  }
+
+  /** Required because safe optimistic RBA is being used. */
+  @Override
+  @Pure
+  public boolean forceEarlyInstrumentation() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommUnsafeOptimisticRba.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommUnsafeOptimisticRba.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BarriersNoCommUnsafeOptimisticRba.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BarriersNoCommUnsafeOptimisticRba.java	2014-04-03 17:43:46.407681675 -0400
@@ -0,0 +1,18 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class BarriersNoCommUnsafeOptimisticRba extends BarriersNoComm {
+
+  @Override
+  @Pure
+  @Interruptible
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() {
+    return RedundantBarrierRemover.AnalysisLevel.OPTIMISTIC_UNSAFE;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BaseConfig.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BaseConfig.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/BaseConfig.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/BaseConfig.java	2014-04-03 17:43:46.403681660 -0400
@@ -0,0 +1,220 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.jikesrvm.octet.ClientAnalysis;
+import org.jikesrvm.octet.NullAnalysis;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+
+@Uninterruptible
+public class BaseConfig {
+
+  public BaseConfig() {
+    // Consistency check: Pessimistic barriers should disable IR-based inlining
+    if (VM.VerifyAssertions) {
+      if (usePessimisticBarriers()) {
+        VM._assert(forceUseJikesInliner() || !inlineBarriers());
+      }
+    }
+  }
+
+  /** Construct the client analysis to use. By default, "null" analysis. */
+  @Interruptible
+  public ClientAnalysis constructClientAnalysis() { return new NullAnalysis(); }
+  
+  // Enable Octet components
+  
+  /** Do objects have extra headers words (and do static fields each have a metadata word)? */
+  @Pure public boolean addHeaderWord() { return false; }
+
+  /** Should we instrument allocation sites?
+      This might just mean initializing the extra header word as part of allocation.
+      It also includes initializing the static field metadata. */
+  @Pure public boolean instrumentAllocation() { return false; }
+
+  /** Insert read and write barriers? */
+  @Pure public boolean insertBarriers() { return false; }
+
+  /** Perform roundtrip communication, i.e., the request-respond protocol? */
+  @Pure public boolean doCommunication() { return false; }
+  
+  // Configuration
+  
+  /** Insert the Java libraries in addition to the application? */
+  @Pure public boolean instrumentLibraries() { return true; }
+
+  // Stats
+  
+  /** Collect and report statistics? */
+  @Pure public boolean stats() { return false; }
+
+  // Optimizations or lack thereof
+
+  /** Use Jikes' built-in escape analysis to identify definitely non-escaping objects? */
+  @Pure public boolean useEscapeAnalysis() {
+    // Octet: TODO: Jikes escape analysis seems to very broken
+    return false;
+    //return true;
+  }
+
+  /** Inline Octet instrumentation in the optimizing compiler?  Note that stats() should be sure to disable inlining -- or at least IR-based barriers. */
+  @Pure public boolean inlineBarriers() { return true; }
+
+  // Debugging and tuning
+
+  /** Make the instrumentation slow path be an empty method? */
+  @Pure public boolean noSlowPath() { return false; }
+
+  /** Don't actually wait when doing communication?  Provides incorrect behavior but is useful for teasing apart performance. */
+  // Octet: LATER: won't work correctly for some cases, e.g., the queue-based implementation?
+  @Pure public boolean noWaitForCommunication() { return false; }
+
+  /** Don't actually wait when trying to move an object to the intermediate state?  Provides incorrect behavior but is useful for teasing apart performance. */
+  @Pure public boolean noWaitOnIntermediateState() { return false; }
+
+  @Pure public boolean instrumentBaselineCompiler() { return true; }
+
+  @Pure public boolean instrumentOptimizingCompiler() { return true; }
+
+  /** Force the opt compiler to perform Octet instrumentation early instead of late? */
+  @Pure public boolean forceEarlyInstrumentation() { return false; }
+
+  /** Force the opt compiler to use the Jikes inliner (instead of inserting IR-based barriers)? */
+  @Pure public boolean forceUseJikesInliner() { return false; }
+
+  /** Force IR-based barriers to check for WrEx and RdEx, not just RdEx, as part of the fast path. */
+  @Pure public boolean forceCheckBothExclStateIRBasedBarriers() { return false; }
+  
+  /** Force use of the communication queue, even for client analyses that don't need it (for testing purposes). */
+  @Pure public boolean forceUseCommunicationQueue() { return false; }
+
+  /** Force use of the hold state, even for client analyses that don't need it (for testing purposes). */
+  @Pure public boolean forceUseHoldState() { return false; }
+  
+  /** The level of redundant barrier analysis.
+      Client analyses can override this choice by overriding ClientAnalysis.newRedundantBarriersAnalysis(). */
+  @Interruptible // since enum accesses apparently call interruptible methods
+  @Pure public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() { return RedundantBarrierRemover.AnalysisLevel.DEFAULT_SAFE;}
+
+  /** Use pessimistic barriers, which always use a CAS or fence, instead of Octet's optimistic barriers. */
+  @Pure public boolean usePessimisticBarriers() { return false; }
+
+  /** Defines which type of pessimistic read to use.  It can't be @Pure because it has side effects! */
+  public void pessimisticRead(Address addr) { VM._assert(Constants.NOT_REACHED); }
+  
+  /** Defines which type of pessimistic write to use.  It can't be @Pure because it has side effects! */
+  public void pessimisticWrite(Address addr) { VM._assert(Constants.NOT_REACHED); }
+  
+  /** Whether the current analysis is field sensitive. */
+  @Pure public boolean isFieldSensitiveAnalysis() { return false; }
+
+  /** enable static race detection based instrumentation filtering */
+  @Pure public boolean enableStaticRaceDetection() { return false; }
+  
+  @Pure public boolean needsSites() { return false; }
+  
+  // Custom options that help with quickly testing new ideas
+  
+  @Pure public boolean custom1() { return false; }
+
+  @Pure public boolean custom2() { return false; }
+  
+  /****************Velodrome configurations*******************/
+  
+  @Pure
+  public boolean methodsAsTransactions() {
+    return false;
+  }
+  
+  @Pure
+  public boolean syncBlocksAsTransactions() {
+    return false;
+  }
+  
+  @Pure
+  public boolean createCrossThreadEdges() {
+    return false;
+  }
+  
+  @Pure
+  public boolean invokeCycleDetection() {
+    return false;
+  }
+  
+  @Pure
+  public boolean recordVelodromeStats() {
+    return false;
+  }
+  
+  @Pure
+  public boolean trackSynchronizationPrimitives() {
+    return false;
+  }
+  
+  @Pure
+  public boolean instrumentArrays() {
+    return true;
+  }
+
+  @Pure
+  public boolean trackThreadSynchronizationPrimitives() {
+    return false;
+  }
+  
+  @Pure
+  public boolean insertStartEndTransactionBarriers() {
+    return false;
+  }
+  
+  @Pure
+  public boolean inlineStartEndTransactions() {
+    return false;
+  }
+  
+  @Pure
+  public boolean insertPostBarriers() {
+    return false;
+  }
+  
+  @Pure
+  public boolean addPerFieldVelodromeMetadata() {
+    return false;
+  }
+  
+  @Pure
+  public boolean trackLastAccess() {
+    return false;
+  }
+  
+  @Pure
+  public boolean addMiscHeader() {
+    return false;
+  }
+  
+  @Pure
+  public boolean isVelodromeEnabled() {
+    return false;
+  }
+  
+  @Pure
+  public boolean checkStartTransactionInstrumentation() {
+    return false;
+  }
+  
+  @Pure
+  public boolean checkMethodContextAtProlog() {
+    return false;
+  }
+  
+  @Pure
+  public boolean isPerformanceRun() {
+    return false;
+  }
+  
+  /****************Velodrome configurations*******************/
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/HeaderWordAlloc.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/HeaderWordAlloc.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/HeaderWordAlloc.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/HeaderWordAlloc.java	2014-04-03 17:43:46.412681690 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class HeaderWordAlloc extends HeaderWordOnly {
+
+  @Override @Pure
+  public boolean instrumentAllocation() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/HeaderWordOnly.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/HeaderWordOnly.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/HeaderWordOnly.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/HeaderWordOnly.java	2014-04-03 17:43:46.411681687 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class HeaderWordOnly extends BaseConfig {
+
+  @Override @Pure
+  public boolean addHeaderWord() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetCheckRdEx.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetCheckRdEx.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetCheckRdEx.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetCheckRdEx.java	2014-04-03 17:43:46.412681690 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetCheckRdEx extends OctetDefault {
+
+  @Override @Pure
+  public boolean forceCheckBothExclStateIRBasedBarriers() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetCustom1.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetCustom1.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetCustom1.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetCustom1.java	2014-04-03 17:43:46.411681687 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetCustom1 extends OctetDefault {
+
+  @Override @Pure
+  public boolean custom1() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetDefault.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetDefault.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetDefault.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetDefault.java	2014-04-03 17:43:46.410681684 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetDefault extends BarriersNoComm {
+
+  @Override @Pure
+  public boolean doCommunication() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetDefaultStaticRaceFiltering.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetDefaultStaticRaceFiltering.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetDefaultStaticRaceFiltering.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetDefaultStaticRaceFiltering.java	2014-04-03 17:43:46.401681653 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetDefaultStaticRaceFiltering extends OctetDefault {
+
+  @Override @Pure
+  public boolean enableStaticRaceDetection() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceEarlyInstr.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceEarlyInstr.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceEarlyInstr.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceEarlyInstr.java	2014-04-03 17:43:46.396681638 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetForceEarlyInstr extends OctetDefault {
+
+  @Override @Pure
+  public boolean forceEarlyInstrumentation() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseHoldState.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseHoldState.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseHoldState.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseHoldState.java	2014-04-03 17:43:46.399681647 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetForceUseHoldState extends OctetDefault {
+
+  @Override @Pure
+  public boolean forceUseHoldState() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseJikesInliner.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseJikesInliner.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseJikesInliner.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseJikesInliner.java	2014-04-03 17:43:46.410681684 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetForceUseJikesInliner extends OctetDefault {
+
+  @Override @Pure
+  public boolean forceUseJikesInliner() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseQueueAndHoldState.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseQueueAndHoldState.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseQueueAndHoldState.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseQueueAndHoldState.java	2014-04-03 17:43:46.396681638 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetForceUseQueueAndHoldState extends OctetForceUseQueue {
+
+  @Override @Pure
+  public boolean forceUseHoldState() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseQueue.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseQueue.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetForceUseQueue.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetForceUseQueue.java	2014-04-03 17:43:46.398681644 -0400
@@ -0,0 +1,12 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetForceUseQueue extends OctetDefault {
+
+  @Override @Pure
+  public boolean forceUseCommunicationQueue() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetNoRba.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetNoRba.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetNoRba.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetNoRba.java	2014-04-03 17:43:46.413681693 -0400
@@ -0,0 +1,18 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetNoRba extends OctetDefault {
+
+  @Override
+  @Pure
+  @Interruptible
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() {
+    return RedundantBarrierRemover.AnalysisLevel.NONE;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetNoRbaStats.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetNoRbaStats.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetNoRbaStats.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetNoRbaStats.java	2014-04-03 17:43:46.398681644 -0400
@@ -0,0 +1,22 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetNoRbaStats extends OctetNoRba {
+
+  @Override
+  @Pure
+  public boolean stats() {
+    return true;
+  }
+
+  /** Required because stats are being used. */
+  @Override
+  @Pure
+  public boolean forceUseJikesInliner() {
+    return true;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRba.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRba.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRba.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRba.java	2014-04-03 17:43:46.394681631 -0400
@@ -0,0 +1,24 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetSafeOptimisticRba extends OctetDefault {
+
+  @Override
+  @Pure
+  @Interruptible
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() {
+    return RedundantBarrierRemover.AnalysisLevel.OPTIMISTIC_SAFE;
+  }
+  
+  /** Required because safe optimistic RBA is being used. */
+  @Override
+  @Pure
+  public boolean forceEarlyInstrumentation() {
+    return true;
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRbaStats.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRbaStats.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRbaStats.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetSafeOptimisticRbaStats.java	2014-04-03 17:43:46.411681687 -0400
@@ -0,0 +1,22 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetSafeOptimisticRbaStats extends OctetSafeOptimisticRba {
+
+  @Override
+  @Pure
+  public boolean stats() {
+    return true;
+  }
+
+  /** Required because stats are being used. */
+  @Override
+  @Pure
+  public boolean forceUseJikesInliner() {
+    return true;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetStats.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetStats.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetStats.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetStats.java	2014-04-03 17:43:46.412681690 -0400
@@ -0,0 +1,17 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class OctetStats extends OctetDefault {
+
+  @Override @Pure
+  public boolean stats() { return true; }
+
+  // Stats must disable IR-based inlining to get correct results
+  
+  @Override @Pure
+  public boolean forceUseJikesInliner() { return true; }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetStatsNoRba.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetStatsNoRba.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetStatsNoRba.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetStatsNoRba.java	2014-04-03 17:43:46.409681681 -0400
@@ -0,0 +1,32 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+/**
+ * A config for collecting stats in Octet when {@link RedundantBarrierRemover}
+ * analysis is not enabled.
+ * @author Meisam
+ *
+ */
+@Uninterruptible
+public class OctetStatsNoRba extends OctetDefault {
+
+  @Override
+  @Pure
+  @Interruptible
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() {
+    return RedundantBarrierRemover.AnalysisLevel.NONE;
+  }
+
+  @Override @Pure
+  public boolean stats() { return true; }
+
+  // Stats must disable inlining to get correct results
+  
+  @Override @Pure
+  public boolean inlineBarriers() { return false; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRba.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRba.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRba.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRba.java	2014-04-03 17:43:46.396681638 -0400
@@ -0,0 +1,24 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+/**
+ * A config for collecting stats in Octet when {@link RedundantBarrierRemover}
+ * analysis is not enabled.
+ * @author Meisam
+ *
+ */
+@Uninterruptible
+public class OctetUnsafeOptimisticRba extends OctetDefault {
+
+  @Override
+  @Pure
+  @Interruptible
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() {
+    return RedundantBarrierRemover.AnalysisLevel.OPTIMISTIC_UNSAFE;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRbaStats.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRbaStats.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRbaStats.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/OctetUnsafeOptimisticRbaStats.java	2014-04-03 17:43:46.401681653 -0400
@@ -0,0 +1,24 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+/**
+ * A config for collecting stats in Octet when {@link RedundantBarrierRemover}
+ * analysis is not enabled.
+ * @author Meisam
+ *
+ */
+@Uninterruptible
+public class OctetUnsafeOptimisticRbaStats extends OctetUnsafeOptimisticRba {
+
+  @Override @Pure
+  public boolean stats() { return true; }
+
+  // Stats must disable IR-based barriers to get correct results
+  
+  @Override @Pure
+  public boolean forceUseJikesInliner() { return true; }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriers.java	2014-04-03 17:43:46.411681687 -0400
@@ -0,0 +1,32 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.octet.PessimisticStateTransfers;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+
+/** Use pessimistic barriers, which use a CAS or fence instead of using Octet's optimistic barriers.
+    On the other hand, pessimistic barriers don't need communication.
+    They can't use IR-based inlining since there isn't support for that in OctetOptInstr. */
+@Uninterruptible
+public class PessimisticBarriers extends BarriersNoComm {
+
+  @Override @Pure
+  public boolean usePessimisticBarriers() { return true; }
+
+  @Override @Pure
+  public boolean forceUseJikesInliner() { return true; }
+  
+  /** Use the pessimistic read that performs a fence. */
+  @Override @Inline
+  public void pessimisticRead(Address addr) {
+    PessimisticStateTransfers.readWithFence(addr);
+  }
+
+  /** Use the pessimistic write that performs a fence. */
+  @Override @Inline
+  public void pessimisticWrite(Address addr) {
+    PessimisticStateTransfers.writeWithFence(addr);
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersNoFence.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersNoFence.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersNoFence.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersNoFence.java	2014-04-03 17:43:46.400681650 -0400
@@ -0,0 +1,23 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.octet.PessimisticStateTransfers;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+
+/** Pessimistic barriers with CAS but no fence. */
+@Uninterruptible
+public class PessimisticBarriersNoFence extends PessimisticBarriers {
+
+  /** Use the pessimistic read that skips the fence. */
+  @Override @Inline
+  public void pessimisticRead(Address addr) {
+    PessimisticStateTransfers.readWithoutFence(addr);
+  }
+
+  /** Use the pessimistic write that skips the fence. */
+  @Override @Inline
+  public void pessimisticWrite(Address addr) {
+    PessimisticStateTransfers.writeWithoutFence(addr);
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersNoInlining.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersNoInlining.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersNoInlining.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersNoInlining.java	2014-04-03 17:43:46.407681675 -0400
@@ -0,0 +1,14 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+/** A configuration that doesn't inline pessimistic barriers,
+    to help determine if they're stressing the opt-compiler. */
+@Uninterruptible
+public class PessimisticBarriersNoInlining extends PessimisticBarriers {
+
+  /** Don't inline barriers. */
+  @Override @Pure
+  public boolean inlineBarriers() { return false; }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersNoSync.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersNoSync.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersNoSync.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersNoSync.java	2014-04-03 17:43:46.409681681 -0400
@@ -0,0 +1,24 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.octet.PessimisticStateTransfers;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+
+/** Pessimistic barriers that don't actually perform any synchronization.
+    For comparison purposes (e.g., to see how much the pessimistic barriers are stressing the opt compiler). */
+@Uninterruptible
+public class PessimisticBarriersNoSync extends PessimisticBarriers {
+
+  /** Use the pessimistic read that skips all synchronization. */
+  @Override @Inline
+  public void pessimisticRead(Address addr) {
+    PessimisticStateTransfers.readWithoutSync(addr);
+  }
+
+  /** Use the pessimistic write that skips all synchronization. */
+  @Override @Inline
+  public void pessimisticWrite(Address addr) {
+    PessimisticStateTransfers.writeWithoutSync(addr);
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersStaticRaceFiltering.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersStaticRaceFiltering.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/PessimisticBarriersStaticRaceFiltering.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/PessimisticBarriersStaticRaceFiltering.java	2014-04-03 17:43:46.412681690 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class PessimisticBarriersStaticRaceFiltering extends PessimisticBarriers {
+
+  @Pure
+  @Override
+  public boolean  enableStaticRaceDetection() { 
+    return true; 
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeAddPerFieldMetadata.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeAddPerFieldMetadata.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeAddPerFieldMetadata.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeAddPerFieldMetadata.java	2014-04-03 17:43:46.410681684 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeAddPerFieldMetadata extends VelodromeBase {
+
+  @Pure
+  @Override
+  public boolean addPerFieldVelodromeMetadata() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASCrossThreadEdges.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASCrossThreadEdges.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASCrossThreadEdges.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASCrossThreadEdges.java	2014-04-03 17:43:46.402681656 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASCrossThreadEdges extends VelodromeASMiscHeader {
+
+  @Pure
+  @Override
+  public boolean createCrossThreadEdges() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyBarriers.java	2014-04-03 17:43:46.409681681 -0400
@@ -0,0 +1,20 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.VM;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefaultInlineOnlyBarriers extends VelodromeASDefault {
+
+  public VelodromeASDefaultInlineOnlyBarriers() {
+    if (VM.VerifyAssertions) { VM._assert(inlineBarriers()); }
+  }
+  
+  @Pure
+  @Override
+  public boolean inlineStartEndTransactions() {
+    return false;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyTransactions.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyTransactions.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyTransactions.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultInlineOnlyTransactions.java	2014-04-03 17:43:46.408681678 -0400
@@ -0,0 +1,20 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.VM;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefaultInlineOnlyTransactions extends VelodromeASDefault {
+
+  public VelodromeASDefaultInlineOnlyTransactions() {
+    if (VM.VerifyAssertions) { VM._assert(inlineStartEndTransactions()); }
+  }
+  
+  @Pure
+  @Override
+  public boolean inlineBarriers() {
+    return false;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefault.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefault.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefault.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefault.java	2014-04-03 17:43:46.410681684 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefault extends VelodromeASCrossThreadEdges {
+
+  @Pure
+  @Override
+  public boolean invokeCycleDetection() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoCycle.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoCycle.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoCycle.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoCycle.java	2014-04-03 17:43:46.413681693 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefaultNoCycle extends VelodromeASDefault {
+
+  @Pure
+  @Override
+  public boolean invokeCycleDetection() {
+    return false;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoInline.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoInline.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoInline.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultNoInline.java	2014-04-03 17:43:46.410681684 -0400
@@ -0,0 +1,21 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefaultNoInline extends VelodromeASDefault {
+
+  @Pure
+  @Override
+  public boolean inlineStartEndTransactions() {
+    return false;
+  }
+
+  @Pure
+  @Override
+  public boolean inlineBarriers() {
+    return false;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArrays.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArrays.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArrays.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArrays.java	2014-04-03 17:43:46.403681660 -0400
@@ -0,0 +1,21 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.VM;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefaultWithArrays extends VelodromeASDefault {
+
+  public VelodromeASDefaultWithArrays() {
+    // Post barriers should be enabled if arrays are instrumented
+    if (VM.VerifyAssertions) { VM._assert(instrumentArrays() ? insertPostBarriers() : true); }
+  }
+  
+  @Pure
+  @Override
+  public boolean instrumentArrays() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArraysNoCycle.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArraysNoCycle.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArraysNoCycle.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithArraysNoCycle.java	2014-04-03 17:43:46.409681681 -0400
@@ -0,0 +1,22 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.VM;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefaultWithArraysNoCycle extends VelodromeASDefaultNoCycle {
+  
+  public VelodromeASDefaultWithArraysNoCycle() {
+    // Post barriers should be enabled if arrays are instrumented
+    if (VM.VerifyAssertions) { VM._assert(instrumentArrays() ? insertPostBarriers() : true); }
+    if (VM.VerifyAssertions) { VM._assert(!invokeCycleDetection()); }
+  }
+
+  @Pure
+  @Override
+  public boolean instrumentArrays() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithStaticRace.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithStaticRace.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithStaticRace.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASDefaultWithStaticRace.java	2014-04-03 17:43:46.410681684 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASDefaultWithStaticRace extends VelodromeASDefault {
+
+  @Pure
+  @Override
+  public boolean enableStaticRaceDetection() { 
+    return true; 
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASInsertBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASInsertBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASInsertBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASInsertBarriers.java	2014-04-03 17:43:46.402681656 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASInsertBarriers extends VelodromeASTransactionInstrumentation {
+
+  @Pure
+  @Override
+  public boolean insertBarriers() { 
+    return true; 
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASInsertPostBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASInsertPostBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASInsertPostBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASInsertPostBarriers.java	2014-04-03 17:43:46.404681664 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASInsertPostBarriers extends VelodromeASInsertBarriers {
+
+  @Pure
+  @Override
+  public boolean insertPostBarriers() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASMiscHeader.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASMiscHeader.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASMiscHeader.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASMiscHeader.java	2014-04-03 17:43:46.405681668 -0400
@@ -0,0 +1,27 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASMiscHeader extends VelodromeASTrackMetadata {
+
+  @Pure
+  @Override
+  public boolean addMiscHeader() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean trackSynchronizationPrimitives() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean trackThreadSynchronizationPrimitives() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASTrackMetadata.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASTrackMetadata.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASTrackMetadata.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASTrackMetadata.java	2014-04-03 17:43:46.405681668 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASTrackMetadata extends VelodromeASInsertPostBarriers {
+
+  @Pure
+  @Override
+  public boolean trackLastAccess() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASTransactionInstrumentation.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASTransactionInstrumentation.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASTransactionInstrumentation.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASTransactionInstrumentation.java	2014-04-03 17:43:46.406681672 -0400
@@ -0,0 +1,21 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASTransactionInstrumentation extends VelodromeAtomicitySpecifications {
+
+  @Pure
+  @Override
+  public boolean methodsAsTransactions() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean inlineStartEndTransactions() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASVerifyTransactionInstrumentation.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASVerifyTransactionInstrumentation.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeASVerifyTransactionInstrumentation.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeASVerifyTransactionInstrumentation.java	2014-04-03 17:43:46.412681690 -0400
@@ -0,0 +1,21 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeASVerifyTransactionInstrumentation extends VelodromeASDefault {
+
+  @Pure
+  @Override
+  public boolean checkStartTransactionInstrumentation() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean checkMethodContextAtProlog() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeAtomicitySpecifications.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeAtomicitySpecifications.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeAtomicitySpecifications.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeAtomicitySpecifications.java	2014-04-03 17:43:46.403681660 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeAtomicitySpecifications extends VelodromeAddPerFieldMetadata {
+
+  @Pure
+  @Override
+  public boolean isPerformanceRun() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeBase.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeBase.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeBase.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeBase.java	2014-04-03 17:43:46.411681687 -0400
@@ -0,0 +1,68 @@
+package org.jikesrvm.config;
+
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.jikesrvm.octet.ClientAnalysis;
+import org.jikesrvm.velodrome.VelodromeAnalysis;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeBase extends BaseConfig {
+
+  /** Construct the client analysis to use. */
+  @Interruptible
+  @Override
+  public ClientAnalysis constructClientAnalysis() { 
+    return new VelodromeAnalysis(); 
+  }
+  
+  @Pure
+  @Override
+  public boolean needsSites() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean insertBarriers() { 
+    return false; 
+  }
+  
+  @Pure 
+  @Override
+  public boolean instrumentLibraries() { 
+    return false; 
+  }
+  
+  @Pure
+  @Override
+  public boolean instrumentArrays() {
+    return false;
+  }
+  
+  @Pure 
+  public boolean inlineBarriers() { 
+    return true; 
+  }
+  
+  @Pure 
+  @Override
+  public boolean isFieldSensitiveAnalysis() { 
+    return true; 
+  }
+  
+  @Interruptible // since enum accesses apparently call interruptible methods
+  @Pure
+  @Override
+  public RedundantBarrierRemover.AnalysisLevel overrideDefaultRedundantBarrierAnalysisLevel() { 
+    return RedundantBarrierRemover.AnalysisLevel.NONE;
+  }
+  
+  @Pure
+  @Override
+  public boolean isVelodromeEnabled() {
+    return true;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeCustom1.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeCustom1.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeCustom1.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeCustom1.java	2014-04-03 17:43:46.395681635 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeCustom1 extends VelodromeASDefault { 
+
+  @Pure
+  @Override
+  public boolean invokeCycleDetection() {
+    return false;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeCustom2.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeCustom2.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeCustom2.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeCustom2.java	2014-04-03 17:43:46.406681672 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeCustom2 extends VelodromeASDefault {
+  
+  @Pure
+  @Override
+  public boolean invokeCycleDetection() {
+    return false;
+  }
+
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGenerateViolations.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGenerateViolations.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGenerateViolations.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGenerateViolations.java	2014-04-03 17:43:46.409681681 -0400
@@ -0,0 +1,16 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+/** This class is the base for using the exclusion list */
+@Uninterruptible
+public class VelodromeGenerateViolations extends VelodromeAddPerFieldMetadata {
+
+  @Pure
+  @Override
+  public boolean isPerformanceRun() {
+    return false;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVCrossThreadEdges.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVCrossThreadEdges.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVCrossThreadEdges.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVCrossThreadEdges.java	2014-04-03 17:43:46.394681631 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVCrossThreadEdges extends VelodromeGVMiscHeader {
+
+  @Pure
+  @Override
+  public boolean createCrossThreadEdges() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVDefault.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVDefault.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVDefault.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVDefault.java	2014-04-03 17:43:46.412681690 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVDefault extends VelodromeGVCrossThreadEdges {
+
+  @Pure
+  @Override
+  public boolean invokeCycleDetection() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVInsertBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVInsertBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVInsertBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVInsertBarriers.java	2014-04-03 17:43:46.395681635 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVInsertBarriers extends VelodromeGVTransactionInstrumentation {
+
+  @Pure
+  @Override
+  public boolean insertBarriers() { 
+    return true; 
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVInsertPostBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVInsertPostBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVInsertPostBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVInsertPostBarriers.java	2014-04-03 17:43:46.397681641 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVInsertPostBarriers extends VelodromeGVInsertBarriers {
+
+  @Pure
+  @Override
+  public boolean insertPostBarriers() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVMiscHeader.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVMiscHeader.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVMiscHeader.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVMiscHeader.java	2014-04-03 17:43:46.398681644 -0400
@@ -0,0 +1,27 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVMiscHeader extends VelodromeGVTrackMetadata {
+
+  @Pure
+  @Override
+  public boolean addMiscHeader() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean trackSynchronizationPrimitives() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean trackThreadSynchronizationPrimitives() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVTrackMetadata.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVTrackMetadata.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVTrackMetadata.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVTrackMetadata.java	2014-04-03 17:43:46.408681678 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVTrackMetadata extends VelodromeGVInsertPostBarriers {
+
+  @Pure
+  @Override
+  public boolean trackLastAccess() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVTransactionInstrumentation.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVTransactionInstrumentation.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVTransactionInstrumentation.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVTransactionInstrumentation.java	2014-04-03 17:43:46.400681650 -0400
@@ -0,0 +1,21 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVTransactionInstrumentation extends VelodromeGenerateViolations {
+
+  @Pure
+  @Override
+  public boolean methodsAsTransactions() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean inlineStartEndTransactions() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVVerifyTransactionInstrumentation.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVVerifyTransactionInstrumentation.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeGVVerifyTransactionInstrumentation.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeGVVerifyTransactionInstrumentation.java	2014-04-03 17:43:46.405681668 -0400
@@ -0,0 +1,21 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeGVVerifyTransactionInstrumentation extends VelodromeGVDefault {
+  
+  @Pure
+  @Override
+  public boolean checkStartTransactionInstrumentation() {
+    return true;
+  }
+  
+  @Pure
+  @Override
+  public boolean checkMethodContextAtProlog() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeStats.java workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeStats.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/config/VelodromeStats.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/config/VelodromeStats.java	2014-04-03 17:43:46.397681641 -0400
@@ -0,0 +1,15 @@
+package org.jikesrvm.config;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeStats extends VelodromeASDefault {
+
+  @Pure
+  @Override
+  public boolean recordVelodromeStats() {
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java workspace/velodrome-sound/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java	2014-04-03 17:43:47.314684656 -0400
@@ -27,6 +27,7 @@ import org.jikesrvm.ia32.MachineCode;
 import org.jikesrvm.ia32.ThreadLocalState;
 import org.jikesrvm.jni.JNICompiledMethod;
 import org.jikesrvm.objectmodel.ObjectModel;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.ArchEntrypoints;
 import org.jikesrvm.runtime.Entrypoints;
 import org.jikesrvm.runtime.Statics;
@@ -785,6 +786,11 @@ public abstract class JNICompiler implem
     doneLeaveJNIRef.resolve(asm);
     // END of code sequence to change state from IN_JNI to IN_JAVA
 
+    // Octet: unblock because we're calling from JNI into Java
+    if (Octet.getConfig().doCommunication()) {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.octetUnblockCommunicationRequestsMethod.getOffset()));
+    }
+
     // status is now IN_JAVA. GC can not occur while we execute on a processor
     // in this state, so it is safe to access fields of objects.
     // RVM TR register has been restored and EBX contains a pointer to
@@ -900,6 +906,11 @@ public abstract class JNICompiler implem
     asm.emitPUSH_Reg(T0);
     asm.emitPUSH_Reg(T1);
 
+    // Octet: block again because we're exiting from Java back into JNI
+    if (Octet.getConfig().doCommunication()) {
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(Entrypoints.octetBlockCommunicationRequestsMethod.getOffset()));
+    }
+
     // attempt to change the thread state to IN_JNI
     asm.emitMOV_Reg_Imm(T0, RVMThread.IN_JAVA);
     asm.emitMOV_Reg_Imm(T1, RVMThread.IN_JNI);
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/jni/ia32/JNIHelpers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/jni/ia32/JNIHelpers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/jni/ia32/JNIHelpers.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/jni/ia32/JNIHelpers.java	2014-04-03 17:43:47.316684662 -0400
@@ -14,6 +14,7 @@ package org.jikesrvm.jni.ia32;
 
 import java.lang.reflect.Constructor;
 import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.TypeReference;
@@ -49,7 +50,8 @@ public abstract class JNIHelpers extends
     // get the parameter list as Java class
     MemberReference mr = MemberReference.getMemberRef(methodID);
     TypeReference tr = java.lang.JikesRVMSupport.getTypeForClass(cls).getTypeRef();
-    RVMMethod mth = MemberReference.findOrCreate(tr, mr.getName(), mr.getDescriptor()).asMethodReference().resolve();
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+    RVMMethod mth = MemberReference.findOrCreate(tr, mr.getName(), mr.getDescriptor()).asMethodReference().resolve(Context.JNI_CONTEXT);
 
     Constructor<?> constMethod = java.lang.reflect.JikesRVMSupport.createConstructor(mth);
     if (!mth.isPublic()) {
@@ -262,7 +264,8 @@ public abstract class JNIHelpers extends
   static Object packageAndInvoke(Object obj, int methodID, Address argAddress, TypeReference expectReturnType,
                                  boolean skip4Args, boolean isVarArg) throws Exception {
 
-    RVMMethod targetMethod = MemberReference.getMemberRef(methodID).asMethodReference().resolve();
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+    RVMMethod targetMethod = MemberReference.getMemberRef(methodID).asMethodReference().resolve(Context.JNI_CONTEXT);
     TypeReference returnType = targetMethod.getReturnType();
 
     if (JNIFunctions.traceJNI) {
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/jni/JNIFunctions.java workspace/velodrome-sound/rvm/src/org/jikesrvm/jni/JNIFunctions.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/jni/JNIFunctions.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/jni/JNIFunctions.java	2014-04-03 17:43:47.373684849 -0400
@@ -20,6 +20,7 @@ import org.jikesrvm.ArchitectureSpecific
 import org.jikesrvm.VM;
 import org.jikesrvm.Properties;
 import org.jikesrvm.SizeConstants;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMArray;
 import org.jikesrvm.classloader.Atom;
 import org.jikesrvm.classloader.RVMClass;
@@ -672,10 +673,11 @@ public class JNIFunctions implements Siz
 
       // Find the target method
       final RVMMethod meth;
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
       if (methodString.equals("<init>")) {
-        meth = klass.findInitializerMethod(sigName);
+        meth = klass.findInitializerMethod(sigName, Context.JNI_CONTEXT);
       } else {
-        meth = klass.findVirtualMethod(methodName, sigName);
+        meth = klass.findVirtualMethod(methodName, sigName, Context.JNI_CONTEXT);
       }
 
       if (meth == null) {
@@ -2690,7 +2692,8 @@ public class JNIFunctions implements Siz
       }
 
       // Find the target method
-      RVMMethod meth = klass.findStaticMethod(methodName, sigName);
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      RVMMethod meth = klass.findStaticMethod(methodName, sigName, Context.JNI_CONTEXT);
       if (meth == null) {
         env.recordException(new NoSuchMethodError());
         return 0;
@@ -5524,7 +5527,8 @@ public class JNIFunctions implements Siz
         Atom sigName = Atom.findOrCreateAsciiAtom(sigString);
 
         // Find the target method
-        RVMMethod meth = klass.findDeclaredMethod(methodName, sigName);
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
+        RVMMethod meth = klass.findDeclaredMethod(methodName, sigName, Context.JNI_CONTEXT);
 
         if (meth == null || !meth.isNative()) {
           env.recordException(new NoSuchMethodError(klass + ": " + methodName + " " + sigName));
@@ -5594,6 +5598,7 @@ public class JNIFunctions implements Siz
 
     try {
       Object obj = env.getJNIRef(objJREF);
+      // Velodrome: Use the instrumented version of lock
       ObjectModel.genericLock(obj);
       return 0;
     } catch (Throwable unexpected) {
@@ -5614,6 +5619,7 @@ public class JNIFunctions implements Siz
 
     try {
       Object obj = env.getJNIRef(objJREF);
+      // Velodrome: Use the instrumented version of unlock
       ObjectModel.genericUnlock(obj);
       return 0;
     } catch (Throwable unexpected) {
@@ -5700,7 +5706,8 @@ public class JNIFunctions implements Siz
     if (traceJNI) VM.sysWrite("JNI called: ToReflectedMethod \n");
     RuntimeEntrypoints.checkJNICountDownToGC();
 
-    RVMMethod targetMethod = MemberReference.getMemberRef(methodID).asMethodReference().resolve();
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+    RVMMethod targetMethod = MemberReference.getMemberRef(methodID).asMethodReference().resolve(Context.JNI_CONTEXT);
     Object ret;
     if (targetMethod.isObjectInitializer()) {
       ret = java.lang.reflect.JikesRVMSupport.createConstructor(targetMethod);
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/mm/mminterface/Barriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/mm/mminterface/Barriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/mm/mminterface/Barriers.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/mm/mminterface/Barriers.java	2014-04-03 17:43:46.653682483 -0400
@@ -1251,6 +1251,31 @@ public class Barriers implements org.mmt
       VM._assert(VM.NOT_REACHED);
   }
 
+  // Octet: TODO: any places that directly call the above methods directly might need Octet instrumentation; need to check them
+  
+  // Octet: "pre-barriers" that act as generational write barriers without actually performing the write itself
+  
+  @Inline
+  @Entrypoint
+  public static void objectFieldWritePreBarrier(Object ref, Object value, Offset offset, int locationMetadata) {
+    if (NEEDS_OBJECT_GC_WRITE_BARRIER) {
+      ObjectReference src = ObjectReference.fromObject(ref);
+      Selected.Mutator.get().objectReferencePreWrite(src, src.toAddress().plus(offset), ObjectReference.fromObject(value), offset.toWord(), Word.fromIntZeroExtend(locationMetadata), INSTANCE_FIELD);
+    } else if (VM.VerifyAssertions)
+      VM._assert(false);
+  }
+
+  @Inline
+  @Entrypoint
+  public static void objectArrayWritePreBarrier(Object[] ref, int index, Object value) {
+    if (NEEDS_OBJECT_GC_WRITE_BARRIER) {
+      ObjectReference array = ObjectReference.fromObject(ref);
+      Offset offset = Offset.fromIntZeroExtend(index << MemoryManagerConstants.LOG_BYTES_IN_ADDRESS);
+      Selected.Mutator.get().objectReferencePreWrite(array, array.toAddress().plus(offset), ObjectReference.fromObject(value), offset.toWord(), Word.zero(), ARRAY_ELEMENT);
+    } else if (VM.VerifyAssertions)
+      VM._assert(false);
+  }
+  
   /**
    * Barrier for loads of objects from fields of instances (i.e. getfield).
    *
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/mm/mminterface/MemoryManager.java workspace/velodrome-sound/rvm/src/org/jikesrvm/mm/mminterface/MemoryManager.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/mm/mminterface/MemoryManager.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/mm/mminterface/MemoryManager.java	2014-04-03 17:43:46.651682477 -0400
@@ -15,7 +15,6 @@ package org.jikesrvm.mm.mminterface;
 import java.lang.ref.PhantomReference;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
-
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.VM;
 import org.jikesrvm.HeapLayoutConstants;
@@ -36,9 +35,11 @@ import org.jikesrvm.objectmodel.JavaHead
 import org.jikesrvm.objectmodel.ObjectModel;
 import org.jikesrvm.objectmodel.TIB;
 import org.jikesrvm.objectmodel.TIBLayoutConstants;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.options.OptionSet;
 import org.jikesrvm.runtime.BootRecord;
 import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
 import org.mmtk.plan.CollectorContext;
 import org.mmtk.plan.Plan;
 import org.mmtk.policy.Space;
@@ -458,6 +459,11 @@ public final class MemoryManager impleme
         isPrefix("Lorg/jikesrvm/jni/JNIEnvironment;", typeBA)) {
       allocator = Plan.ALLOC_NON_MOVING;
     }
+    // Octet: Need threads to go in the immortal space so their space won't get reused.  This allows
+    // GC to avoid the alternative, tracing each thread's extra header word.
+    if (Octet.getConfig().instrumentAllocation() && isPrefix("Lorg/jikesrvm/scheduler/RVMThread;", typeBA)) {
+      allocator = Plan.ALLOC_IMMORTAL;
+    }
     return allocator;
   }
 
@@ -1107,6 +1113,29 @@ public final class MemoryManager impleme
     return new SpecializedScanMethod(id, TypeReference.findOrCreate(traceClass));
   }
 
+  /** Octet: support allocation in uninterruptible code */
+  public static final void startAllocatingInUninterruptibleCode() {
+    RVMThread.getCurrentThread().disableYieldpoints();
+    Selected.Mutator.get().startAllocatingInUninterruptibleCode();
+  }
+  
+  /** Octet: support allocation in uninterruptible code */
+  public static final void stopAllocatingInUninterruptibleCode() {
+    RVMThread.getCurrentThread().enableYieldpoints();
+    Selected.Mutator.get().stopAllocatingInUninterruptibleCode();
+  }
+  
+  /** Octet: check whether the "allocating in uninterruptible code" flag is set. */
+  public static final boolean isAllocatingInUninterruptibleCode() {
+    return Selected.Mutator.get().isAllocatingInUninterruptibleCode();
+  }
+  
+  /** Octet: are we inside the performance-measuring harness? */
+  @Inline
+  public static final boolean inHarness() {
+    return Plan.insideHarness;
+  }
+  
   /***********************************************************************
    *
    * Header initialization
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/mm/mminterface/SpecializedScanMethod.java workspace/velodrome-sound/rvm/src/org/jikesrvm/mm/mminterface/SpecializedScanMethod.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/mm/mminterface/SpecializedScanMethod.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/mm/mminterface/SpecializedScanMethod.java	2014-04-03 17:43:46.651682477 -0400
@@ -18,6 +18,7 @@ import org.jikesrvm.ArchitectureSpecific
 import org.jikesrvm.SizeConstants;
 import org.jikesrvm.VM;
 import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.RVMType;
@@ -91,7 +92,8 @@ public final class SpecializedScanMethod
       /* Compile our specialized methods when we are opt compiling */
       RVMClass myClass = specializedScanMethodType.peekType().asClass();
       for(int i=0; i < PATTERNS; i++) {
-        RVMMethod method = myClass.findStaticMethod(templateMethodName(i), specializedMethodDescriptor);
+        // Octet: Static cloning: Support multiple resolve methods for each method reference.
+        RVMMethod method = myClass.findStaticMethod(templateMethodName(i), specializedMethodDescriptor, Context.VM_CONTEXT);
         specializedMethods[i] = compileSpecializedMethod(method, specializedSignature);
       }
     }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/FieldLayoutContext.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/FieldLayoutContext.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/FieldLayoutContext.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/FieldLayoutContext.java	2014-04-03 17:43:47.945686730 -0400
@@ -13,6 +13,7 @@
 package org.jikesrvm.objectmodel;
 
 import org.jikesrvm.SizeConstants;
+import org.jikesrvm.UnimplementedError;
 import org.jikesrvm.runtime.Memory;
 
 /**
@@ -44,6 +45,11 @@ public abstract class FieldLayoutContext
 
   /** Return the offset of a new field of the given size */
   abstract int nextOffset(int size, boolean isReference);
+  
+  /** Velodrome: for allocating direct field metadata */
+  int nextOffsetUnaligned(int size) {
+    throw new UnimplementedError();
+  }
 
   /* *****************************************************************
   *                        Initialization
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/FieldLayout.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/FieldLayout.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/FieldLayout.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/FieldLayout.java	2014-04-03 17:43:47.944686726 -0400
@@ -16,6 +16,7 @@ import org.jikesrvm.VM;
 import org.jikesrvm.SizeConstants;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.unboxed.Offset;
 
 /**
@@ -119,6 +120,11 @@ public abstract class FieldLayout implem
         if (!field.isStatic() && !field.hasOffset()) {
           if (field.getSize() == BYTES_IN_LONG) {
             layoutField(fieldLayout, klass, field, BYTES_IN_LONG);
+            
+            // Velodrome: layout field metadata
+            if (Velodrome.addPerFieldVelodromeMetadata()) {
+              layoutFieldMetadata(fieldLayout, klass, field);
+            }
           }
         }
       }
@@ -129,6 +135,13 @@ public abstract class FieldLayout implem
       if (!field.isStatic() && !field.hasOffset()) {              // Allocate space in the object?
         layoutField(fieldLayout, klass, field, fieldSize);
       }
+      // Velodrome: layout field metadata
+      if (Velodrome.addPerFieldVelodromeMetadata()) {
+        if (!field.isStatic()) {
+          layoutFieldMetadata(fieldLayout, klass, field);
+        }
+      }
+      
     }
     // JavaHeader requires objects to be int sized/aligned
     if (VM.VerifyAssertions) VM._assert((fieldLayout.getObjectSize() & 0x3) == 0);
@@ -192,4 +205,31 @@ public abstract class FieldLayout implem
     boolean isRef = field.isReferenceType();
     setOffset(klass, field, layout.nextOffset(fieldSize, isRef));
   }
+  
+  /** Velodrome: make room for per-field metadata */
+  private boolean layoutFieldMetadata(FieldLayoutContext layout, RVMClass klass, RVMField field) {
+    if (Velodrome.shouldAddPerFieldVelodromeMetadata(field)) {
+      if (!field.hasVelodromeMetadataOffset()) {
+        int numFields = Velodrome.getNumFields(field); // Currently is two
+        Offset metadataOffset;
+        if (numFields > 1) {
+          metadataOffset = Offset.fromIntSignExtend(layout.nextOffsetUnaligned(Velodrome.FIELD_SIZE * numFields));
+        } else {
+          metadataOffset = Offset.fromIntSignExtend(layout.nextOffset(Velodrome.FIELD_SIZE, true));
+        }
+        setVelodromeMetadataOffset(klass, field, metadataOffset);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Velodrome: set metadata offset */
+  protected void setVelodromeMetadataOffset(RVMClass klass, RVMField field, Offset offset) {
+    if (VM.VerifyAssertions) { VM._assert(offset.sGE(Offset.zero())); }
+    Offset metadataOffset = offset.plus(JavaHeader.objectStartOffset(klass)).plus(ObjectModel.computeScalarHeaderSize(klass));
+    field.setWriteMetadataOffset(metadataOffset);
+    field.setReadMetadataOffset(metadataOffset.plus(BYTES_IN_ADDRESS));
+  }
+
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/FieldLayoutPacked.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/FieldLayoutPacked.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/FieldLayoutPacked.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/FieldLayoutPacked.java	2014-04-03 17:43:47.946686733 -0400
@@ -126,6 +126,26 @@ public class FieldLayoutPacked extends F
 
       return result;
     }
+    
+    // Velodrome: for allocating field metadata, copied from PACER. Here we are forcing words to be
+    // laid out side by side which by the way is not necessary.
+    @Override
+    int nextOffsetUnaligned(int size) {
+      //if (VM.VerifyAssertions) { VM._assert(size > MAX_SLOT_SIZE); }
+      int refSlot = get(LOG_BYTES_IN_ADDRESS);
+      int end = getObjectSize();
+      int result;
+      // if there's a 4-bite "hole" at the end of the object, start from there and move the hole
+      if (refSlot == end  && refSlot != 0) {
+        result = refSlot;
+        set(LOG_BYTES_IN_ADDRESS, result + size);
+        // otherwise, add the data at the end and leave existing holes
+      } else {
+        result = end;
+      }
+      ensureObjectSize(result + size);
+      return result;
+    }    
   }
 
   public FieldLayoutPacked(boolean largeFieldsFirst, boolean clusterReferenceFields) {
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/JavaHeaderConstants.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/JavaHeaderConstants.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/JavaHeaderConstants.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/JavaHeaderConstants.java	2014-04-03 17:43:47.945686730 -0400
@@ -50,16 +50,19 @@ public interface JavaHeaderConstants ext
   /** Size of GC and miscellaneous headers */
   int OTHER_HEADER_BYTES = GC_HEADER_BYTES + MISC_HEADER_BYTES;
 
+  // Octet: Put MiscHeader *between* JavaHeader and fields? Helps with Octet because then the lowest bit of the MiscHeader word doesn't need to be 0.
+  final boolean miscHeaderAfter = true;
+
   /** Offset of array length from object reference */
   Offset ARRAY_LENGTH_OFFSET = Offset.fromIntSignExtend(-ARRAY_LENGTH_BYTES);
   /** Offset of the first field from object reference */
   Offset FIELD_ZERO_OFFSET = ARRAY_LENGTH_OFFSET;
   /** Offset of the Java header from the object reference */
-  Offset JAVA_HEADER_OFFSET = ARRAY_LENGTH_OFFSET.minus(JAVA_HEADER_BYTES);
+  Offset JAVA_HEADER_OFFSET = ARRAY_LENGTH_OFFSET.minus(JAVA_HEADER_BYTES + (miscHeaderAfter ? MISC_HEADER_BYTES : 0));
   /** Offset of the miscellaneous header from the object reference */
-  Offset MISC_HEADER_OFFSET = JAVA_HEADER_OFFSET.minus(MISC_HEADER_BYTES);
+  Offset MISC_HEADER_OFFSET = (miscHeaderAfter ? ARRAY_LENGTH_OFFSET : JAVA_HEADER_OFFSET).minus(MISC_HEADER_BYTES);
   /** Offset of the garbage collection header from the object reference */
-  Offset GC_HEADER_OFFSET = MISC_HEADER_OFFSET.minus(GC_HEADER_BYTES);
+  Offset GC_HEADER_OFFSET = (miscHeaderAfter ? JAVA_HEADER_OFFSET : MISC_HEADER_OFFSET).minus(GC_HEADER_BYTES);
   /** Offset of first element of an array */
   Offset ARRAY_BASE_OFFSET = Offset.zero();
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/JavaHeader.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/JavaHeader.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/JavaHeader.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/JavaHeader.java	2014-04-03 17:43:47.947686736 -0400
@@ -25,6 +25,8 @@ import org.jikesrvm.runtime.Memory;
 import org.jikesrvm.scheduler.Lock;
 import org.jikesrvm.scheduler.ThinLock;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.velodrome.Velodrome;
+import org.jikesrvm.velodrome.VelodromeMetadataHelper;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.Interruptible;
 import org.vmmagic.pragma.NoInline;
@@ -562,19 +564,48 @@ public class JavaHeader implements JavaH
     // nothing to do (all objects have thin locks in this object model);
   }
 
+  // Velodrome: Changes for lock acquire()/release()
   /**
-   * Generic lock
+   * Generic lock with Velodrome instrumentation
    */
   @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
   public static void genericLock(Object o) {
     ThinLock.lock(o, STATUS_OFFSET);
+    if (Velodrome.trackSynchronizationPrimitives()) {
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.addMiscHeader()); }
+      if (RVMThread.getCurrentThread().isOctetThread()) {
+        VelodromeMetadataHelper.trackLockAcquire(o);
+      }
+    }
+  }
+  
+  /**
+   * Generic lock without Velodrome instrumentation
+   */
+  @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
+  public static void genericLockWithoutInstrumentation(Object o) {
+    ThinLock.lock(o, STATUS_OFFSET);
   }
 
   /**
-   * Generic unlock
+   * Generic unlock with Velodrome instrumentation
    */
   @Unpreemptible("No interruption unless of exceptions")
   public static void genericUnlock(Object o) {
+    if (Velodrome.trackSynchronizationPrimitives()) {
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.addMiscHeader()); }
+      if (RVMThread.getCurrentThread().isOctetThread()) {
+          VelodromeMetadataHelper.trackLockRelease(o);
+        }
+    }
+    ThinLock.unlock(o, STATUS_OFFSET);
+  }
+  
+  /**
+   * Generic unlock without Velodrome instrumentation
+   */
+  @Unpreemptible("No interruption unless of exceptions")
+  public static void genericUnlockWithoutInstrumentation(Object o) {
     ThinLock.unlock(o, STATUS_OFFSET);
   }
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/MiscHeaderConstants.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/MiscHeaderConstants.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/MiscHeaderConstants.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/MiscHeaderConstants.java	2014-04-03 17:43:47.949686742 -0400
@@ -14,6 +14,8 @@ package org.jikesrvm.objectmodel;
 
 import org.jikesrvm.Constants;
 import org.jikesrvm.mm.mminterface.MemoryManagerConstants;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.velodrome.Velodrome;
 
 /**
  * Defines other header words not used for
@@ -33,8 +35,21 @@ public interface MiscHeaderConstants ext
       (MemoryManagerConstants.GENERATE_GC_TRACE ? 3 : 0);
   int GC_TRACING_HEADER_BYTES = GC_TRACING_HEADER_WORDS << LOG_BYTES_IN_ADDRESS;
 
+  /** Octet: number of extra header bytes; also used below to calculate NUM_BYTES_HEADER */
+  int OCTET_HEADER_BYTES = Octet.getConfig().addHeaderWord() ? BYTES_IN_WORD : 0;
+  
+  /** Velodrome: Add an extra word to keep track of metadata for locks */
+  int VELODROME_HEADER_BYTES = Octet.getConfig().addMiscHeader() ? BYTES_IN_WORD : 0;
+  
+  /** Velodrome: Adding two extra words to track read/write accesses for arrays */
+  int VELODROME_WRITE_METADATA_BYTES = Velodrome.instrumentArrays() ? BYTES_IN_WORD : 0;
+  int VELODROME_READ_METADATA_BYTES = Velodrome.instrumentArrays() ? BYTES_IN_WORD : 0;  
+
   /**
    * How many bytes are used by all misc header fields?
    */
-  int NUM_BYTES_HEADER = GC_TRACING_HEADER_BYTES; // + YYY_HEADER_BYTES;
+  // Velodrome: Included count for header bytes
+  int NUM_BYTES_HEADER = GC_TRACING_HEADER_BYTES + OCTET_HEADER_BYTES + VELODROME_HEADER_BYTES + 
+                          VELODROME_WRITE_METADATA_BYTES + VELODROME_READ_METADATA_BYTES; // + YYY_HEADER_BYTES;
+
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/MiscHeader.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/MiscHeader.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/MiscHeader.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/MiscHeader.java	2014-04-03 17:43:47.949686742 -0400
@@ -15,7 +15,11 @@ package org.jikesrvm.objectmodel;
 import org.jikesrvm.VM;
 import org.jikesrvm.Constants;
 import org.jikesrvm.mm.mminterface.MemoryManagerConstants;
+import org.jikesrvm.octet.OctetState;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.Stats;
 import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.Entrypoint;
 import org.vmmagic.pragma.Interruptible;
 import org.vmmagic.pragma.Uninterruptible;
@@ -44,6 +48,16 @@ public final class MiscHeader implements
   /* offset from object ref to .link field, in bytes */
   static final Offset OBJECT_LINK_OFFSET = OBJECT_DEATH_OFFSET.plus(BYTES_IN_ADDRESS);
 
+  /** Octet: extra header word's offset */
+  public static final Offset OCTET_OFFSET = MISC_HEADER_START;
+  
+  /** Velodrome: Offset for the word */
+  public static final Offset VELODROME_OFFSET = OCTET_OFFSET.plus(OCTET_HEADER_BYTES);
+  
+  /** Velodrome: Offset for the read/write metadata for array accesses */
+  public static final Offset VELODROME_WRITE_OFFSET = VELODROME_OFFSET.plus(VELODROME_HEADER_BYTES);
+  public static final Offset VELODROME_READ_OFFSET = VELODROME_WRITE_OFFSET.plus(VELODROME_WRITE_METADATA_BYTES);
+
   /////////////////////////
   // Support for YYY (an example of how to add a word to all objects)
   /////////////////////////
@@ -87,13 +101,36 @@ public final class MiscHeader implements
    */
   @Uninterruptible
   public static void initializeHeader(Object obj, TIB tib, int size, boolean isScalar) {
+    
+    // Octet: initialize the metadata
+    if (Octet.getConfig().instrumentAllocation()) {
+      //if (VM.VerifyAssertions) { VM._assert(Octet.headerWord()); }
+      Word metadata =  OctetState.getInitial();
+      OctetState.check(metadata);
+      ObjectReference.fromObject(obj).toAddress().store(metadata, MiscHeader.OCTET_OFFSET);
+      Stats.Alloc.inc();
+    }
+    
+    // Velodrome: initialize the metadata
+    if (Velodrome.addMiscHeader()) {
+      ObjectReference.fromObject(obj).toAddress().store(Word.zero(), VELODROME_OFFSET);
+    }
+    // Velodrome: Initialize the array read/write metadata words
+    if (Velodrome.instrumentArrays()) {
+      ObjectReference.fromObject(obj).toAddress().store(Word.zero(), VELODROME_WRITE_OFFSET);
+      ObjectReference.fromObject(obj).toAddress().store(Word.zero(), VELODROME_READ_OFFSET);
+    }
+    
+    
     /* Only perform initialization when it is required */
+    /*
     if (MemoryManagerConstants.GENERATE_GC_TRACE) {
       Address ref = Magic.objectAsAddress(obj);
       ref.store(oid, OBJECT_OID_OFFSET);
       ref.store(time, OBJECT_DEATH_OFFSET);
       oid = oid.plus(Word.fromIntSignExtend((size - GC_TRACING_HEADER_BYTES) >> LOG_BYTES_IN_ADDRESS));
     }
+    */
   }
 
   /**
@@ -107,6 +144,23 @@ public final class MiscHeader implements
   @Interruptible("Only called during boot iamge creation")
   public static void initializeHeader(BootImageInterface bootImage, Address ref, TIB tib, int size,
                                       boolean isScalar) {
+    
+    // Octet: initialize boot image objects
+    if (Octet.getConfig().instrumentAllocation()) {
+      Word metadata = OctetState.getInitial();
+      bootImage.setAddressWord(ref.plus(OCTET_OFFSET), metadata, false, false);
+    }
+    
+    // Velodrome: initialize boot image objects
+    if (Velodrome.addMiscHeader()) {
+      bootImage.setAddressWord(ref.plus(VELODROME_OFFSET), Word.zero(), false, false);
+    }
+    // Velodrome: Initialize the array read/write metadata words
+    if (Velodrome.instrumentArrays()) {
+      bootImage.setAddressWord(ref.plus(VELODROME_WRITE_METADATA_BYTES), Word.zero(), false, false);
+      bootImage.setAddressWord(ref.plus(VELODROME_READ_METADATA_BYTES), Word.zero(), false, false);
+    }
+    
     /* Only perform initialization when it is required */
     if (MemoryManagerConstants.GENERATE_GC_TRACE) {
       bootImage.setAddressWord(ref.plus(OBJECT_OID_OFFSET), oid, false, false);
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java	2014-04-03 17:43:47.946686733 -0400
@@ -461,23 +461,42 @@ public class ObjectModel implements Java
     JavaHeader.allocateThinLock(t);
   }
 
+  // Velodrome: Changes for tracking lock acquire/releases
   /**
-   * Generic lock
+   * Generic lock with Velodrome instrumentation
    */
   @Entrypoint
   @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
   public static void genericLock(Object o) {
     JavaHeader.genericLock(o);
   }
+  
+  /**
+   * Generic lock without Velodrome instrumentation
+   */
+  @Entrypoint
+  @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
+  public static void genericLockWithoutInstrumentation(Object o) {
+    JavaHeader.genericLockWithoutInstrumentation(o);
+  }
 
   /**
-   * Generic unlock
+   * Generic unlock with Velodrome instrumentation
    */
   @Entrypoint
   @Unpreemptible("No preemption normally, but may raise exceptions")
   public static void genericUnlock(Object o) {
     JavaHeader.genericUnlock(o);
   }
+  
+  /**
+   * Generic unlock without Velodrome instrumentation
+   */
+  @Entrypoint
+  @Unpreemptible("No preemption normally, but may raise exceptions")
+  public static void genericUnlockWithoutInstrumentation(Object o) {
+    JavaHeader.genericUnlockWithoutInstrumentation(o);
+  }  
 
   /**
    * @param obj an object
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/CFGVisualization.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/CFGVisualization.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/CFGVisualization.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/CFGVisualization.java	2014-04-03 17:43:46.971683526 -0400
@@ -0,0 +1,237 @@
+package org.jikesrvm.octet;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Enumeration;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.RVMClass;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.compilers.opt.ir.BasicBlock;
+import org.jikesrvm.compilers.opt.ir.Call;
+import org.jikesrvm.compilers.opt.ir.IR;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+
+/**
+ * 
+ * @author aritra
+ *
+ */
+// SB: We could do some potential enhancements, like deleting all existing files before 
+// generating new files. It should help managing files getting generated. Then, creating/deleting
+// the directory depending on whether it exists/or not.
+public class CFGVisualization {
+
+  BufferedWriter out = null;
+  static int countCfg = 1;
+
+  public CFGVisualization(IR ir, String prefix) {
+    try {
+      File dir;
+      if (VM.octetIODir != null) {
+        dir = new File(VM.octetIODir);
+      } else {
+        dir = new File(System.getProperty("user.home"), "/CFGS");
+      }
+      RVMMethod method = ir.getMethod();
+      String fileName = prefix + (countCfg++) + "_" +
+                        method.getDeclaringClass().getDescriptor().classNameFromDescriptor() + "_" +
+                        method.getName() + "_" +
+                        /*method.getSignature() + "_" + */
+                        "opt" + ir.options.getOptLevel() + ".graph";
+      FileWriter fstream = new FileWriter(new File(dir, fileName));
+      out = new BufferedWriter(fstream);
+    } catch (IOException io) {
+      System.out.println(io);
+    }
+  }
+  /** method to set color for headers in sce analysis **/
+  public static void setColorForBasicBlocks(BasicBlock bb) {
+
+    if(bb !=  null) {
+      bb.setScratch(-101);
+    }
+  }
+  public boolean isOctetBarrier(Instruction inst) {
+    boolean returnVar = false;
+    if (Call.conforms(inst)) {
+      RVMClass classBarrier;
+      if (Call.getMethod(inst).hasTarget()) {
+        classBarrier = Call.getMethod(inst).getTarget().getDeclaringClass();
+        if (classBarrier.getTypeRef() == TypeReference.OctetBarriers) {
+          returnVar = true;
+        }
+      }
+    }
+    return returnVar; 
+  }
+
+  /** format Call instructions */
+  protected String handleCalls(Instruction inst) { 
+    String s = "";
+
+    if (Call.getMethod(inst).hasTarget()) { 
+      s += Call.getMethod(inst).getTarget().getDeclaringClass() + ":";
+      s += Call.getMethod(inst).getTarget().getName() + ":";
+      s += Call.getMethod(inst).getTarget().getDescriptor() + ":";
+      int params = Call.getNumberOfParams(inst);
+      for (int i = 1; i <= params; i++) {
+        String comma = "";
+        if(i < params) {
+          comma = ", ";
+        } else {
+          comma ="; ";
+        }
+        s += Call.getParam(inst, i-1).toString() + comma;
+      }
+    }  
+    return s;
+  }
+
+  /** Format Octet barriers and calls */
+  protected String shrinkInstruction(Instruction inst) {
+    if (isOctetBarrier(inst)) {
+      //String s=inst.toString().substring(44, inst.toString().length());
+      String s = "OctetBarrier " + handleCalls(inst);
+      return s;
+    } else if (Call.conforms(inst)) {   
+      String s = "CALL " + handleCalls(inst);
+      return s;
+    } else {
+      return inst.toString();
+    }
+  }
+  /** Reset scratch objects of basic blocks used in DFS */
+  protected void resetScratchObjects(IR ir) {
+    BasicBlock bb;
+    for (Enumeration<BasicBlock> e = ir.getBasicBlocks(); e.hasMoreElements();) {
+      bb = e.nextElement();
+      bb.scratchObject = "0";
+    }
+  }
+
+  /** Print entry block and call dfsCFG for the rest of the graph */
+  public void visualizeCFG(IR ir) {
+    //BasicBlockEnumeration blockEnumeration = ir.getBasicBlocks();
+    String color = "";
+    resetScratchObjects(ir);
+    String entryLabel = "";
+    try {
+      writeCFG("digraph G {\n node [shape=box];\n");
+      entryLabel += "ENTRY" + "[ label=\"" + "ENTRY" + "\\n";
+      entryLabel += enumerateAndFormatInstructions(ir.cfg.entry());
+      entryLabel += "\"" + color + "];\n";
+      writeCFG(entryLabel);
+      dfsCFG(ir.cfg.entry(), ir);
+      writeCFG("}");
+      out.close();
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+  
+  protected void writeCFG(String str) {
+    try {
+      out.write(str);
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+
+  /** print formatted instructions in a basic block */
+  protected String enumerateAndFormatInstructions(BasicBlock succBB) {
+    Instruction inst;
+    String next = "";
+    for (Enumeration<Instruction> e = succBB.forwardInstrEnumerator(); e.hasMoreElements();) {
+      inst = e.nextElement();
+      int sc1 = 0;
+      String s=shrinkInstruction(inst);
+      s = s.replaceAll("\n", " ");
+      s = s.replaceAll("\"", "\\\\\"");
+      if (inst.position!=null) {  
+        sc1 = inst.position.getMethod().getLineNumberForBCIndex(inst.getBytecodeIndex());
+      }
+      next += s + " " + ((Integer)inst.getBytecodeIndex()).toString() + "," + ((Integer)sc1).toString() + "\\n";
+    }
+    return next;
+  }
+
+  /** Generate control-flow edges for basic blocks */
+  protected WrapperString setDirectionalEdges(BasicBlock succBB, IR ir, BasicBlock bb, WrapperString obj) {
+    if (bb == ir.cfg.entry() || succBB.isExit()) {
+      if (bb == ir.cfg.entry() && (!succBB.isExit())) {  
+        obj.setTo("BB"+succBB.getNumber());  
+        obj.setStr("ENTRY" + "->" + "{"+ obj.getTo() + "}" + ";\n"); 
+      } else if (!(bb == ir.cfg.entry()) && (succBB.isExit())) {  
+        obj.setTo("EXIT");
+        obj.setStr("BB" + bb.getNumber() + "->" + "{" + obj.getTo() + "}" + ";\n");
+      }
+    } else { 
+      obj.setTo("BB"+succBB.getNumber());
+      if (succBB == ir.cfg.entry()) {
+        obj.setTo("ENTRY");
+      }
+      obj.setStr("BB" + bb.getNumber() + "->" + "{" + obj.getTo() + "}" + ";\n");
+    }
+    return obj;
+  }
+
+  /** Wrapper for a method returning two strings*/
+  public class WrapperString {
+    String to = "";
+    String str = "";
+    public String getTo() {
+      return to;
+    }
+    public void setTo(String to) {
+      this.to = to;
+    }
+    public String getStr() {
+      return str;
+    }
+    public void setStr(String str) {
+      this.str = str;
+    }
+  }
+
+  /** DFS to print the entire CFG */
+  protected void dfsCFG(BasicBlock bb, IR ir) {
+    bb.scratchObject = "1";
+    String color = "";
+    Enumeration<BasicBlock> successors = bb.getOutNodes();
+    while (successors.hasMoreElements()) {
+      String str = "";
+      String to = "";
+      String next = "";
+      BasicBlock succBB = successors.nextElement();
+      WrapperString obj = new WrapperString();
+      WrapperString returnObj = setDirectionalEdges(succBB, ir, bb, obj);
+      to = returnObj.getTo();
+      str = returnObj.getStr();
+      try {
+        if (!("".equalsIgnoreCase(to))) {
+          next += to + "[ label=\"" + to + "\\n";
+        }
+        next += enumerateAndFormatInstructions(succBB);
+        if (!("".equalsIgnoreCase(to))) {
+          next += "\"" + color + "];\n";
+        }
+        writeCFG(str);
+        writeCFG(next);
+      } catch (Exception e) {
+        e.printStackTrace();
+      }
+      if (succBB.scratchObject instanceof String) { 
+        if (((String)succBB.scratchObject).equalsIgnoreCase("0")) {
+          dfsCFG(succBB,ir);
+        }
+      }
+    }
+    bb.scratchObject = "2";
+  }
+
+}
+
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/ClientAnalysis.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/ClientAnalysis.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/ClientAnalysis.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/ClientAnalysis.java	2014-04-03 17:43:46.971683526 -0400
@@ -0,0 +1,324 @@
+package org.jikesrvm.octet;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.compilers.baseline.ia32.OctetBaselineInstr;
+import org.jikesrvm.compilers.opt.OctetOptInstr;
+import org.jikesrvm.compilers.opt.OctetOptSelection;
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+
+/** Octet: abstract class for integrating with client analyses */
+@Uninterruptible
+public abstract class ClientAnalysis {
+
+  /** Allows the client analysis to do something when the VM is booting. */
+  @Interruptible
+  protected void boot() {
+    // some analyses won't want to do anything, so that's the default behavior
+  }
+  
+  // Handlers for transitions.
+  
+  /** Callback for RdEx->RdSh upgrading transition, called from the thread moving the object to RdSh state. */
+  @Inline
+  protected void handleRdExToRdShUpgradingTransition(RVMThread oldThread, Word newMetadata, int siteID) {
+    // Many analyses won't need to do anything.
+  }
+  
+  /** Callback for fenced reads in RdSh state. */
+  @Inline
+  protected void handleRdShFenceTransition(Word metadata, int siteID) {
+    // Many analyses won't need to do anything.
+  }
+  
+  /** Called by the responding thread for each element on its request queue. Only called if request queues are used. */
+  @Inline
+  protected void handleRequestOnRespondingThread(RVMThread requestingThread) {
+    // most analyses probably don't need to do anything here, so that's the default behavior
+  }
+  
+  /** Called by the responding thread once, after it responds to all the requesting threads. */
+  @Inline
+  protected void handleResponsesUpdated(int oldRequestsCounter, int newResponsesCounter) {
+    // most analyses probably don't need to do anything here, so that's the default behavior
+  }
+  
+  /** Callback for upgrading transition from RdEx -> WrEx, called from the requester thread */
+  @Inline
+  protected void handleRdExToWrExUpgradingTransition(Word newMetadata, int siteID) {
+    // most analyses probably don't need to do anything for this transition, so that's the default behavior
+  }
+  
+  /** Callback from fairly early in thread termination, before JikesRVMSupport.threadDied() is called,
+      which apparently makes I/O no longer possible. */
+  @Interruptible
+  public void handleThreadTerminationEarly() {
+    // Default behavior is nothing.
+    // This used to be where libraryCalledByVM was set to true permanently.
+  }
+  
+  /** Callback from fairly late in thread termination.  Client analyses that override this will almost
+      certainly want to include a call to super.handleThreadTermination()! */
+  public void handleThreadTerminationLate() {
+    // Octet: handle thread termination
+    if (Octet.getConfig().doCommunication()) {
+      Stats.blockCommTerminate.inc();
+      // Set the thread to blocked and *dead*.
+      Communication.blockCommunicationRequestsAndMakeDead();
+    }
+    // A potentially useful assertion
+    if (VM.VerifyAssertions) { VM._assert(!MemoryManager.isAllocatingInUninterruptibleCode()); }
+  }
+
+  /** Let the client analysis to provide support for conflict detection on the requesting thread.
+      Note that the remote thread might be dead.
+      This hook is called whether or not the holding state is used.  If the holding state is used, the
+      responding thread will be in the holding state when this hook is called. */
+  @Inline
+  public void handleConflictForBlockedThread(RVMThread remoteThread, Address baseAddr, Offset offset, Word oldMetadata, Word newState, 
+      boolean remoteThreadIsDead, int newRemoteRequests, int fieldOffset, int siteID) {
+    // Do nothing since some analyses won't need it.
+  }
+
+  /** Called by the requesting thread after it sends a request to an unblocked thread. */
+  @Inline
+  public void handleRequestSentToUnblockedThread(RVMThread remoteThread, int newRemoteRequests, int siteID) {
+    // Do nothing since some analyses won't need it.
+  }
+
+  /** Callback for a roundtrip communication receiving a response. */
+  // Octet: TODO: Can there just be one call for all received responses?  Might be simpler -- and even more efficient in the general case.
+  public void handleReceivedResponse(RVMThread respondingThread, Word oldMetadata, Word newState) {
+    // Do nothing since most analyses won't need it.
+  }
+
+  /** Callback for handling events after unblocking. */
+  @Inline
+  public void handleEventsAfterUnblockCommunication() {
+    // Do nothing since most analyses won't need it.
+  }
+
+  /** Callback for handling events after unblocking.  Only called if requests were received while blocked. */
+  @Inline
+  public void handleEventsAfterUnblockIfRequestsReceivedWhileBlocked(int newRequestCounter) {
+    // Do nothing since most analyses won't need it.
+  }
+  
+  /** handle events before starting communication*/
+  @Inline
+  public void handleEventBeforeCommunication(Address baseAddr, Offset offset, Word oldMetadata, Word newState, int fieldOffset, int siteID) {
+    // Do nothing since most analyses won't need it.
+  }
+
+  /** handle events after finishing communication*/
+  @Inline
+  public void handleEventAfterCommunication(Address baseAddr, Offset offset, Word oldMetadata) {
+    // Do nothing since most analyses won't need it.
+  }
+
+  /** Callback for handling events when a thread is looping in the slow path */
+  @Inline
+  public boolean handleEventsInSlowPathLoop(boolean isRead, Address baseAddr, Offset octetOffset, Word oldMetadata, int fieldOrIndexInfo, int siteID) {
+    // Most analyses won't need to do anything of end the slow path loop.
+    return false;
+  }
+  
+  /** Callback before the global read share counter is updated. */
+  @Inline
+  public void handleBeforeUpdatingGlobalRdShCounter() {
+    // Do nothing, most analyses do not require it
+  }
+  
+  /** Let the client analysis decide whether it will use the communication queue. */
+  @Inline
+  public boolean needsCommunicationQueue() {
+    // Basic Octet doesn't need the communication queue at all, but it can be enabled as a build option.
+    return Octet.getConfig().forceUseCommunicationQueue();
+  }
+ 
+  /** Let the client analysis decide whether the current responding thread should ignore elements on the communication queue.
+      Some analyses (e.g., STM) may only want to check the queue sometimes. */
+  @Inline
+  public boolean responseShouldCheckCommunicationQueue() {
+    // STM will want to return something like currentThread.inTransaction, right?
+    return needsCommunicationQueue();
+  }
+  
+  /** Let the client analysis to specify whether using holding state */
+  @Inline
+  protected boolean useHoldingState() {
+    return Octet.getConfig().forceUseHoldState();
+  }
+  
+  /** Should the Octet barriers pass any field or array index info? */
+  @Inline
+  protected boolean needsFieldInfo() {
+    // at least some analyses won't need this, so let's make that the default
+    return false;
+  }
+  
+  /** Should the Octet barrier pass the field ID (value = false) or the field offset (value = true)?
+      Only relevant if needsFieldInfo() == true */
+  @Inline
+  protected boolean useFieldOffset() {
+    // most analyses probably either don't care about fields or will be okay with the field ID
+    return false;
+  }
+  
+  @Inline
+  public boolean needsSites() {
+    // most analyses probably don't need sites, so the default behavior is false, unless stats is enabled
+    // Velodrome: Changing this to a build-time parameter
+    //return Octet.getConfig().stats();
+    return Octet.getConfig().needsSites();
+  }
+  
+  @Inline
+  protected boolean needsUniqueSites() {
+    // most analyses probably don't need unique sites, so the default behavior is false, unless stats is enabled
+    return Octet.getConfig().stats();
+  }
+  
+  @Inline
+  protected void handleNewSite(Site site) {
+    // most analysis probably don't need to do anything here, so that's the default behavior
+  }
+
+  // Octet: LATER: We used to have the ability to override what gets instrumented, before static cloning was added and changed everything.
+  // Not sure what's the best way to support this now. Depends on what client analyses need.
+
+  /*
+  @Inline
+  @Pure
+  public boolean shouldInstrumentMethod(RVMMethod method) {
+    // the default behavior: ???
+  }
+
+  @Inline
+  @Pure
+  public boolean shouldAddMetadataForStaticField(FieldReference fieldRef) {
+    // the default behavior: ???
+  }
+  */
+
+  /** Let the client analysis specify alternate slow path behavior.  Returning true means the regular slow path does not execute. */
+  @Inline
+  protected boolean alternateSlowPath(boolean isRead, Address baseAddr, Offset octetOffset, Word oldMetadata, int fieldOrIndexInfo, int siteID) {
+    // the default behavior is to do the regular slow path
+    return false;
+  }
+  
+  /** Let the client analysis specify alternate read slow path behavior.  Returning true means the regular slow path does not execute. */
+  @Inline
+  protected boolean alternateReadSlowPath(Address baseAddr, Offset octetOffset, Word oldMetadata, int fieldOrIndexInfo, int siteID) {
+    // the default behavior is to do the regular slow path
+    return false;
+  }
+  
+  /** Let the client analysis specify alternate write slow path behavior.  Returning true means the regular slow path does not execute. */
+  @Inline
+  protected boolean alternateWriteSlowPath(Address baseAddr, Offset octetOffset, Word oldMetadata, int fieldOrIndexInfo, int siteID) {
+    // the default behavior is to do the regular slow path
+    return false;
+  }
+  
+  /** Let the client analysis specify the chooseBarrier. */
+  public NormalMethod chooseBarrier(NormalMethod method, boolean isRead, boolean isField, boolean isResolved, boolean isStatic, boolean hasRedundantBarrier, boolean isSpecialized) {
+    return InstrDecisions.chooseBarrier(isRead, isField, isResolved, isStatic);
+  }
+  
+  /** Support overriding/customizing barrier insertion in the baseline compiler */
+  @Interruptible
+  public OctetBaselineInstr newBaselineInstr() {
+    return new OctetBaselineInstr();
+  }
+  
+  /** Support overriding/customizing the choice of which instructions the opt compiler should instrument */
+  @Interruptible
+  public OctetOptSelection newOptSelect() {
+    return new OctetOptSelection();
+  }
+  
+  /** Analyses that want to always override the redundant barrier analysis level should override this method,
+      rather than overriding BaseConfig.overrideDefaultRedundantBarrierAnalysisLevel() it in their derived configs. */
+  @Interruptible
+  public RedundantBarrierRemover newRedundantBarriersAnalysis() {
+    return new RedundantBarrierRemover(Octet.getConfig().overrideDefaultRedundantBarrierAnalysisLevel());
+  }
+
+  /** Support overriding/customizing barrier insertion in the opt compiler */
+  @Interruptible
+  public OctetOptInstr newOptInstr(boolean lateInstr, RedundantBarrierRemover redundantBarrierRemover) {
+    return new OctetOptInstr(lateInstr, redundantBarrierRemover);
+  }
+  
+  /** Let client analyses throw exceptions from barriers. */
+  @Inline
+  public boolean barriersCanThrowExceptions() {
+    return false;
+  }
+
+  /** Does the client analysis provide support for inserting individual IR instructions as barriers?
+      Your analysis should return *false* unless you've added functionality in the opt compiler to insert IR instructions for barriers! */
+  public abstract boolean supportsIrBasedBarriers();
+  
+  /** Does the client analysis increment the request counter when using implicit communication protocol?
+      Your analysis should enable this option if it needs precise HB relationship when the responding thread is blocked.
+      Currently only Roctet enables this option.*/
+  @Pure
+  public abstract boolean incRequestCounterForImplicitProtocol();
+  
+  /** Should the client analysis insert barriers during the LIR phase (instead of during HIR->LIR)? */
+  @Inline
+  public boolean useLateOptInstrumentation() {
+    // By default, it makes sense to do late instrumentation if the compiler can insert IR instructions for barriers (since inlining won't work).
+    // Octet: TODO: if inlining is disabled, should we also use late instrumentation?  Maybe we need another option to specify what to do in that case.
+    return supportsIrBasedBarriers();
+  }
+  
+  /**
+   * Decide whether to execute hooks in the slow path. By default, we believe all client analyses will want to avoid invoking 
+   * hooks/processing when the slow path is entered due to library calls made on behalf of the VM from the requesting context, 
+   * but we want to execute the hooks from the responding thread's context. 
+   * @return
+   */
+  public boolean shouldExecuteSlowPathHooks(boolean notInRespondingContext) {
+    if (VM.VerifyAssertions) { VM._assert(RVMThread.getCurrentThread().isOctetThread()); }
+    return true;
+  }
+
+  /**
+   * On a read access, should the IR-based barrier implementation check for both WrEx and RdEx
+   * (instead of checking only WrEx) before checking for the RdSh state?
+   * @author Aritra 
+   */
+  public boolean checkBothExclStateIRBasedBarriers() {
+    return Octet.getConfig().forceCheckBothExclStateIRBasedBarriers();
+  }
+  
+  /** Decide whether we should instrument instructions having redundant barriers. Field sensitive analysis might need to turn this on to instrument accesses that have redundant barriers.*/
+  public boolean instrInstructionHasRedundantBarrier(Instruction inst) { 
+    return false; 
+  }
+
+  @Inline
+  public boolean isSpecializedMethod(NormalMethod method) {
+    return false;
+  }
+  
+  /** Call this when the client analysis only want to instrument a set of selected methods. By default, it returns true, which means all methods will be considered as candidates for instrumentation.*/
+  @Inline
+  public boolean isSelectedInstrMethod(NormalMethod method) {
+    return true;
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Communication.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Communication.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Communication.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Communication.java	2014-04-03 17:43:46.972683530 -0400
@@ -0,0 +1,631 @@
+package org.jikesrvm.octet;
+
+import static org.jikesrvm.runtime.SysCall.sysCall;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.runtime.Time;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoCheckStore;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+
+/** Octet: send, receive, and respond to communication requests */
+@Uninterruptible
+public final class Communication extends OctetState {
+
+  // Several methods to check for communication requests or block communication requests:
+  
+  @Entrypoint
+  static final void blockCommunicationRequests() {
+    Stats.blockCommEntrypoint.inc();
+    blockCommunicationRequests(true);
+  }
+
+  @Inline
+  public static final void blockCommunicationRequests(boolean mayBeRecursive) {
+    if (RVMThread.getCurrentThread().isOctetThread()) {
+      
+      int depth = RVMThread.getCurrentThread().octetBlockedCommunicationRequestDepth;
+      // Octet: LATER: this assertion isn't always true, at least for one client (RR):
+      // a read/write barrier will execute when RR logs are being recorded,
+      // at which point the thread is already "permanently blocked" because it is dying
+      //if (VM.VerifyAssertions) { VM._assert(mayBeRecursive || depth == 0); }
+      RVMThread.getCurrentThread().octetBlockedCommunicationRequestDepth = depth + 1;
+      if (depth == 0) {
+        checkForCommunicationRequests(true);
+      }
+    }
+  }
+  
+  public static final void blockCommunicationRequestsAndMakeDead() {
+    RVMThread myThread = RVMThread.getCurrentThread();
+    if (VM.VerifyAssertions) {
+      VM._assert(myThread.isOctetThread());
+      VM._assert(RVMThread.getCurrentThread().octetBlockedCommunicationRequestDepth == 0);
+    }
+    RVMThread.getCurrentThread().octetBlockedCommunicationRequestDepth = 1;
+    checkForCommunicationRequests(true, true);
+  }
+  
+  @Entrypoint
+  public static final void unblockCommunicationRequests() {
+    RVMThread myThread = RVMThread.getCurrentThread();
+    if (myThread.isOctetThread()) {
+      int depth = myThread.octetBlockedCommunicationRequestDepth;
+      if (VM.VerifyAssertions) { VM._assert(depth > 0); }
+      myThread.octetBlockedCommunicationRequestDepth = depth - 1;
+      if (depth == 1) {
+        do {
+          Word oldRequests = ObjectReference.fromObject(myThread).toAddress().prepareWord(Entrypoints.octetRequestsField.getOffset());
+          if (VM.VerifyAssertions) { VM._assert(CommunicationQueue.isBlockedAssertNotDead(oldRequests)); }
+          // If the thread is held by at least one thread, yield since we may have to wait for a while.
+          if (Octet.getClientAnalysis().useHoldingState() && CommunicationQueue.getHoldCount(oldRequests) > 0) {
+            RVMThread.yieldNoHandshake();
+          // Otherwise, let's try to unblock.
+          } else {
+            Word newRequests = CommunicationQueue.unblock(oldRequests);
+            boolean result = ObjectReference.fromObject(myThread).toAddress().attempt(oldRequests, newRequests, Entrypoints.octetRequestsField.getOffset());
+            if (result) {
+              // Let the client analysis handle leaving the blocked state.
+              if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(false)) {
+                Octet.getClientAnalysis().handleEventsAfterUnblockCommunication();
+              }
+              // Octet: TODO: Mike guesses that we do not need both hooks -- probably just the handleEventsAfterUnblockIfRequestsReceived() hook
+              int newRequestCounter = CommunicationQueue.getCounter(newRequests);
+              if (requestSeen(myThread.octetResponses, newRequestCounter)) {
+              //if (newRequestCounter > myThread.octetResponses) {
+                // Let the client analysis handle leaving the blocked state.
+                if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(false)) {
+                  Octet.getClientAnalysis().handleEventsAfterUnblockIfRequestsReceivedWhileBlocked(newRequestCounter);
+                }
+                myThread.octetResponses = newRequestCounter;
+              }
+              break;
+            } else {
+              // The unblock should only be able to fail if the holding state is enabled.
+              if (VM.VerifyAssertions) { Octet.getClientAnalysis().useHoldingState(); }
+              Magic.pause();
+            }
+          }
+        } while (true);
+      }
+    }
+  }
+
+  static final void checkForCommunicationRequests(boolean blockRequests) {
+    checkForCommunicationRequests(blockRequests, false);
+  }
+  
+  @Inline
+  private static final void checkForCommunicationRequests(boolean blockRequests, boolean makeBlockedAndDead) {
+    if (VM.VerifyAssertions) { VM._assert(!makeBlockedAndDead || blockRequests); }
+    RVMThread myThread = RVMThread.getCurrentThread();
+    Word oldRequests;
+    while (true) {    
+      oldRequests = ObjectReference.fromObject(myThread).toAddress().prepareWord(Entrypoints.octetRequestsField.getOffset());
+      // There's a race here, and this thread will only see the queue element if it wins the race.
+      // If it loses the race, it'll see the queue element on some later call to checkForCommunicationRequests, which is fine.
+      if (blockRequests ||
+          requestSeen(myThread.octetResponses, CommunicationQueue.getCounter(oldRequests))){
+          //CommunicationQueue.getCounter(oldRequests) > myThread.octetResponses) {
+        Word newRequests;
+        if (blockRequests) {
+          if (makeBlockedAndDead) {
+            newRequests = CommunicationQueue.makeDead();
+          } else {
+            newRequests = CommunicationQueue.block(oldRequests);
+          }
+        } else {
+          if (Octet.getClientAnalysis().needsCommunicationQueue()) {
+            newRequests = CommunicationQueue.clearRequests(oldRequests);
+          } else {
+            // If the client analysis doesn't use the queues, there's no need to change the value.
+            if (VM.VerifyAssertions) { VM._assert(CommunicationQueue.getThreadID(oldRequests) == 0); }
+            break;
+          }
+        }
+
+        // Before responding, atomically put the request queue in a local variable
+        if (VM.VerifyAssertions) { VM._assert(oldRequests.NE(newRequests)); }
+        boolean result = ObjectReference.fromObject(myThread).toAddress().attempt(oldRequests, newRequests, Entrypoints.octetRequestsField.getOffset());
+        if (result) {
+          // Recursively handle requests, unless currently (or always) disabled.
+          if (Octet.getClientAnalysis().responseShouldCheckCommunicationQueue()) {
+            int firstThreadID = CommunicationQueue.getThreadID(oldRequests);
+            if (firstThreadID != 0) {
+              handleRequests(firstThreadID);
+            }
+          }
+          break;
+        }
+        Magic.pause();
+      } else {
+        break;
+      }
+    }
+    
+    // Octet: LATER: if we don't always do the monitor enter-broadcast-exit, then we'll need fences of some sort so the store doesn't move above the load
+    //Magic.sfence(); // don't let the store move earlier -- probably needs to be an mfence since we also don't want the load above to move down
+
+    // Octet: LATER: Can we avoid always broadcasting on a monitor?
+    // This thread would need some way of knowing that the requesting thread has started waiting on this thread's monitor.
+
+    // Respond to all requests (if any) in one step
+    // Octet: TODO: As Minjia pointed out, it might be better in some cases
+    // to respond after handling each queue element.
+    if (requestSeen(myThread.octetResponses, CommunicationQueue.getCounter(oldRequests))) {
+    //if (CommunicationQueue.getCounter(oldRequests) > myThread.octetResponses) {
+      sysCall.sysMonitorEnter(myThread.octetMonitor);
+      Magic.writeFloor(); // so everything before the store below will be visible to other threads (that use an lfence, of course)
+      int oldOctetResponses = myThread.octetResponses;
+      myThread.octetResponses = CommunicationQueue.getCounter(oldRequests);
+      sysCall.sysMonitorBroadcast(myThread.octetMonitor);
+      sysCall.sysMonitorExit(myThread.octetMonitor);
+      // Let the client analysis handle the response.
+      if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(false)) {
+        Octet.getClientAnalysis().handleResponsesUpdated(oldOctetResponses, myThread.octetResponses);
+      }
+    }
+  }
+
+  static final void handleRequests(int threadID) {
+    if (VM.VerifyAssertions) { VM._assert(Octet.getClientAnalysis().needsCommunicationQueue() && Octet.getClientAnalysis().responseShouldCheckCommunicationQueue()); }
+    // First do recursion, so the queue, which is really a stack, is processed in reverse order.
+    RVMThread myThread = RVMThread.getCurrentThread();
+    RVMThread requestingThread = RVMThread.threadBySlot[threadID];
+    int nextThreadID = requestingThread.nextRequestQueueThread[myThread.threadSlot];
+    if (nextThreadID != 0) {
+      handleRequests(nextThreadID);
+    }
+    // Now let the client analysis handle the response.
+    if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(false)) {
+      Octet.getClientAnalysis().handleRequestOnRespondingThread(requestingThread);
+    }
+  }
+  
+  /** Communicate with other thread(s) so we can be sure they'll
+      see we put the object in the intermediate state */
+  static final void communicate(Address baseAddr, Offset offset, Word oldMetadata, Word newState, int fieldOffset, int siteID) {
+    
+    // Octet: TODO: need to add a call to a hook somewhere for client analyses to set information to send to the other thread (like the conflicting object)? 
+
+    // first send communication to threads (or identify that a thread is blocked and doesn't need to stop and communicate)
+    RVMThread myThread = RVMThread.getCurrentThread();
+    int numThreadsSentRequest = 0;
+    if (isExclState(oldMetadata)) {
+      RVMThread remoteThread = getThreadFromExclusive(oldMetadata);
+      if (VM.VerifyAssertions) { VM._assert(remoteThread != myThread); }
+      if (isValidOtherThread(remoteThread, myThread)) {
+        numThreadsSentRequest = sendRequest(baseAddr, offset, remoteThread, numThreadsSentRequest, oldMetadata, newState, fieldOffset, siteID);
+      }
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(getState(oldMetadata).EQ(READ_SHARED)); }
+      if (VM.VerifyAssertions) { VM._assert(isReadSharedPossiblyUnfenced(oldMetadata)); }
+      // Octet: TODO: wrong way to loop; might miss a thread that gets a new number
+      // other than that issue, i don't think we need synchronization on this way of grabbing all the threads because we don't care about
+      // newly created threads (because they're guaranteed to see the intermediate state) or threads that have recently died (because they go into the blocked state permanently)
+      for (int i = 0; i < RVMThread.numThreads; i++) {
+        RVMThread remoteThread = RVMThread.threads[i];
+        if (isValidOtherThread(remoteThread, myThread) &&
+            // Octet: TODO: this condition seems necessary in case a new thread has been created but
+            // can't get started (e.g., if a GC gets triggered)
+            remoteThread.getExecStatus() != RVMThread.NEW) {
+          // check the read-shared counter to avoid unnecessary communication
+          // Octet: LATER: is there a dangerous data race here? -- i think so, so i'm moving the sendRequest() call outside of the conditional
+          // We could make this safe with more synchronization (all accesses to octetReadSharedCounter have to CAS)
+          int oldNumThreads = numThreadsSentRequest;
+          numThreadsSentRequest = sendRequest(baseAddr, offset, remoteThread, numThreadsSentRequest, oldMetadata, newState, fieldOffset, siteID);
+          if (remoteThread.octetReadSharedCounter.LE(oldMetadata)) {
+            // moved sendRequest() above because of likely dangerous race
+          } else {
+            Stats.readSharedCounterAvoidsSendRequestCall.inc();
+            if (oldNumThreads != numThreadsSentRequest) {
+              Stats.readSharedCounterAvoidsActualSendRequest.inc();
+            }
+          }
+        }
+      }
+    }
+    Stats.threadsWaitedFor.incBin(numThreadsSentRequest);    
+    
+    receiveResponses(numThreadsSentRequest, oldMetadata, newState);
+    
+    /*
+    // Now receive responses (only if at least one thread sent a request)
+    if (numThreadsSentRequest > 0 && !Octet.noCommunuicationWait()) {
+      long startTime = (Octet.stats() || VM.VerifyAssertions) ? Time.nanoTime() : 0;
+      int iter;
+      boolean stillWaiting;
+      for (iter = 0; (stillWaiting = myThread.octetThreadsWaitedFor > 0) && iter < Octet.waitSpinCount(); iter++) {
+        Magic.pause();
+      }
+      if (stillWaiting) {
+        int stopIter = iter + Octet.waitYieldCount();
+        for (; (stillWaiting = myThread.octetThreadsWaitedFor > 0) && iter < stopIter; iter++) {
+          if (Octet.doYields()) {
+            RVMThread.yield();
+          }
+        }
+        if (stillWaiting) {
+          // now we'll try waiting via pthreads; to make sure this happens atomically, let's switch to using negative numbers
+          sysCall.sysMonitorEnter(myThread.octetMonitor);
+          boolean result;
+          do {
+            int threadsWaitedFor = myThread.octetThreadsWaitedFor;
+            if (VM.VerifyAssertions) { VM._assert(threadsWaitedFor >= 0); }
+            if (threadsWaitedFor == 0) {
+              stillWaiting = false;
+              break;
+            }
+            result = Synchronization.tryCompareAndSwap(myThread, Entrypoints.octetThreadsWaitedForField.getOffset(), threadsWaitedFor, -threadsWaitedFor);
+          } while (!result);
+
+          if (stillWaiting) {
+            do {
+              iter++;
+              if (VM.VerifyAssertions) {
+                // wait for 100 milliseconds, then check for timeout
+                sysCall.sysMonitorTimedWaitAbsolute(myThread.octetMonitor, Time.nanoTime() + 100*1000*1000);
+                checkForResponseTimeout(threadsSentRequest, theRemoteThread, startTime, 90*1000*1000);
+              } else {
+                sysCall.sysMonitorWait(myThread.octetMonitor);
+              }
+            } while (myThread.octetThreadsWaitedFor < 0);
+          }
+          if (VM.VerifyAssertions) { VM._assert(myThread.octetThreadsWaitedFor == 0); }
+          sysCall.sysMonitorExit(myThread.octetMonitor);
+        }
+      }
+      Stats.logTimeCommunicateRequests.incTime(startTime);
+      Stats.waitIter.incBin(iter);
+    }
+    */
+  }
+
+  @NoCheckStore // due to storing to RVMThread.octetRespondingThreads[i]
+  static final void receiveResponses(int numThreadsSentRequest, Word oldMetadata, Word newState) {
+    if (numThreadsSentRequest > 0 && !Octet.getConfig().noWaitForCommunication()) {
+      RVMThread myThread = RVMThread.getCurrentThread();
+      RVMThread[] respondingThreads = myThread.octetRespondingThreads;
+      int[] respondingThreadCounters = myThread.octetRespondingThreadCounters;
+      long startTime = (Octet.getConfig().stats() || VM.VerifyAssertions) ? Time.nanoTime() : 0;
+      int iter;
+      for (iter = 0; ; iter++) {
+        // check all threads
+        boolean stillWaiting = false;
+        for (int i = 0; i < numThreadsSentRequest; i++) {
+          RVMThread respondingThread = respondingThreads[i];
+          if (respondingThread != null) {
+            int respondingThreadCounter = respondingThreadCounters[i];
+            if (responseReceived(respondingThread.octetResponses, respondingThreadCounter)) { 
+            //if (respondingThread.octetResponses >= respondingThreadCounter) {
+              // We received a response
+              respondingThreads[i] = null;
+
+              // Let the client analysis handle receiving the response.
+              Magic.readCeiling(); // Use a load fence to ensure happens-before edge from other thread's write to octetResponse to this point.
+              if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+                Octet.getClientAnalysis().handleReceivedResponse(respondingThread, oldMetadata, newState);
+              }
+            } else {
+              stillWaiting = true;
+              break;
+            }
+          }
+        }
+        if (!stillWaiting) {
+          break;
+        }
+        if (VM.VerifyAssertions) {
+          checkForResponseTimeout(numThreadsSentRequest, null /* it would be nice to send the remote thread instead */, startTime, 90*1000*1000);
+        }
+        if (iter >= Octet.waitSpinCount()) {
+          if (iter >= Octet.waitSpinCount() + Octet.waitYieldCount()) {
+            for (int i = 0 ; i < numThreadsSentRequest; i++) {
+              // Double-checked locking should be okay here
+              RVMThread respondingThread = respondingThreads[i];
+              if (respondingThread != null) {
+                int respondingThreadCounter = respondingThreadCounters[i];
+                if (!responseReceived(respondingThread.octetResponses, respondingThreadCounter)) {
+                //if (respondingThread.octetResponses < respondingThreadCounter) {
+                  sysCall.sysMonitorEnter(respondingThread.octetMonitor);
+                  while (!responseReceived(respondingThread.octetResponses, respondingThreadCounter)) {
+                  //while (respondingThread.octetResponses < respondingThreadCounter) {
+                    sysCall.sysMonitorWait(respondingThread.octetMonitor);
+                  }
+                  sysCall.sysMonitorExit(respondingThread.octetMonitor);
+                }
+                // Setting it to null isn't absolutely necessary since loop exits below, but it'll help threads get GC'd.
+                // Note that we had previously discussed making RVMThread.octetRespondingThreads @Untraced, but that wouldn't
+                // work because we want only the array elements to be untraced, not the array itself!
+                respondingThreads[i] = null;
+                
+                // Let the client analysis handle receiving the response.
+                // Doing a load fence here to ensure a happens-before from the write of octetResponse to this point.
+                // Note that the monitor stuff above may not execute, and even if it does, monitorExit might not include lfence behavior (just sfence behavior?).
+                Magic.readCeiling();
+                if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+                  Octet.getClientAnalysis().handleReceivedResponse(respondingThread, oldMetadata, newState);
+                }
+              }
+            }
+            break; // exit the outer loop
+          } else {
+            RVMThread.yieldNoHandshake();
+          }
+        } else {
+          Magic.pause();
+        }
+      }
+      // Ensure happens-before between loads of other threads' response counter and later loads.
+      // (Not currently needed since there's an lfence before each handleReceivedResponse() above.
+      //Magic.lfence();
+      
+      Stats.logTimeCommunicateRequests.incTime(startTime);
+      Stats.logWaitIter.incBin(iter);
+    }
+
+  }
+  
+  /** Helper method that sends a request to a single thread */
+  @NoCheckStore // due to setting the RVMThread.octetRespondingThreads[i]
+  static final int sendRequest(Address baseAddr, Offset offset, RVMThread remoteThread, int numThreadsSentRequest, Word oldMetadata, Word newState, int fieldOffset, int siteID) {
+    RVMThread myThread = RVMThread.getCurrentThread();
+    while (true) {
+      Word oldRequests = ObjectReference.fromObject(remoteThread).toAddress().prepareWord(Entrypoints.octetRequestsField.getOffset());
+//      boolean isDead = Magic.attemptObject(remoteThread, Entrypoints.octetRequestQueueHeadField.getOffset(), OctetRequestElement.octetDeathState, OctetRequestElement.octetDeathState);
+//      if (isDead) {
+//        return numThreadsSentRequest;
+//      }
+      
+      // Check that if the thread's request word isn't marked dead, it really isn't dead.
+      // But we need to double-check that the request word is marked dead, to deal with race conditions.
+      // Note that this is just an assertion, so it's just best-effort checking.
+      // For the lfences below to be completely effective, there needs to be sfence behavior on the remote thread (which there might be because of the CAS on the blocked state).
+      if (VM.VerifyAssertions) {
+        if (!CommunicationQueue.isDead(oldRequests)) {
+          Magic.readCeiling();
+          if (remoteThread.getIsAboutToTerminate() ||
+              remoteThread.getExecStatus() == RVMThread.TERMINATED ||
+              RVMThread.threadBySlot[remoteThread.threadSlot] != remoteThread) {
+            Magic.readCeiling();
+            VM._assert(!CommunicationQueue.isDead(oldRequests)); 
+          }
+        }
+      }
+      
+      // ABA might happen here, but that's okay.
+      // see http://en.wikipedia.org/wiki/ABA_problem
+      if (CommunicationQueue.isBlockedOrDead(oldRequests)) {
+        boolean isDead = CommunicationQueue.isDead(oldRequests);
+        boolean result;
+        Word newRequests = Word.zero();
+        if (isDead) {
+          // We don't need to CAS a on dead thread, but let's be sure we "see" everything it did before dying.
+          Magic.readCeiling();
+          result = true;
+        } else {
+          if (Octet.getClientAnalysis().useHoldingState()) {
+            newRequests = Octet.getClientAnalysis().incRequestCounterForImplicitProtocol() ?
+                          CommunicationQueue.addHoldAndIncrement(oldRequests) :
+                          CommunicationQueue.addHold(oldRequests);
+          } else {
+            // This CAS is needed to create the correct HB relationship.
+            // Otherwise there's no guarantee the remote thread will "see" the object in the intermediate state.
+            // With the CAS, when the request queue unblocks, it'll be guaranteed to see that the object is in the Int state or the new state.
+            // The increment will help some analyses, like Roctet.
+            if (Octet.getClientAnalysis().incRequestCounterForImplicitProtocol()) {
+              newRequests = CommunicationQueue.inc(oldRequests);
+            } else {
+              newRequests = oldRequests;
+            }
+          }
+          result = ObjectReference.fromObject(remoteThread).toAddress().attempt(oldRequests, newRequests, Entrypoints.octetRequestsField.getOffset());
+        }
+        if (result) {
+          // Call the hook, then unhold the thread if the holding state is being used.  The thread might be dead.
+          if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+            Octet.getClientAnalysis().handleConflictForBlockedThread(remoteThread, baseAddr, offset, oldMetadata, newState, isDead,
+                                                                     CommunicationQueue.getCounter(newRequests), fieldOffset, siteID);
+          }
+          // Remove the hold state, if applicable.
+          if (!isDead && Octet.getClientAnalysis().useHoldingState()) {
+            oldRequests = newRequests; // we now want to decrement the held count by one
+            while (true) {
+              newRequests = CommunicationQueue.removeHold(oldRequests);
+              result = ObjectReference.fromObject(remoteThread).toAddress().attempt(oldRequests, newRequests, Entrypoints.octetRequestsField.getOffset());
+              if (result) {
+                break;
+              }
+              oldRequests = ObjectReference.fromObject(remoteThread).toAddress().prepareWord(Entrypoints.octetRequestsField.getOffset());
+            }
+          }
+
+          if (VM.VerifyAssertions) {
+            if (Octet.getClientAnalysis().incRequestCounterForImplicitProtocol() && !isDead) {
+              //The first argument is true, because the remote thread could have already responded the requests,
+              //making the response counter greater than newRequests.
+              //So we just check the absolute difference between the two counters.
+              checkCounterRange(true, remoteThread.octetResponses, CommunicationQueue.getCounter(newRequests));
+            }
+          }
+          return numThreadsSentRequest;
+        }
+      } else {
+        // oldRequests is not blocked or dead, we should use explicit protocol
+        Word newRequests;
+        if (Octet.getClientAnalysis().needsCommunicationQueue()) {
+          int oldHeadThreadID = CommunicationQueue.getThreadID(oldRequests);
+          myThread.nextRequestQueueThread[remoteThread.threadSlot] = oldHeadThreadID; // important even if oldHeadThreadID==0
+          newRequests = CommunicationQueue.push(oldRequests, myThread.threadSlot);
+        } else {
+          newRequests = CommunicationQueue.inc(oldRequests);
+          if (VM.VerifyAssertions) { VM._assert(newRequests.EQ(CommunicationQueue.push(oldRequests, 0))); }
+        }
+        
+        boolean result = ObjectReference.fromObject(remoteThread).toAddress().attempt(oldRequests, newRequests, Entrypoints.octetRequestsField.getOffset());
+        if (result) {
+          // Set the yield point flag, so the remote thread will stop as soon as possible.
+          remoteThread.takeYieldpoint = 1;
+          // Call the appropriate handler.
+          if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+            Octet.getClientAnalysis().handleRequestSentToUnblockedThread(remoteThread, CommunicationQueue.getCounter(newRequests), siteID);
+          }
+          // Keep track of the communicated-with threads and the request counters that we set.
+          myThread.octetRespondingThreads[numThreadsSentRequest] = remoteThread;
+          myThread.octetRespondingThreadCounters[numThreadsSentRequest] = CommunicationQueue.getCounter(newRequests);
+          
+          if (VM.VerifyAssertions) {
+            checkCounterRange(true, remoteThread.octetResponses, CommunicationQueue.getCounter(newRequests));
+          }
+          return numThreadsSentRequest + 1;
+        }
+      }
+    }
+  }
+
+  /** Helper method to check whether we care about a thread*/
+  @Inline
+  public static final boolean isValidOtherThread(RVMThread remoteThread, RVMThread myThread) {
+    return remoteThread != null &&
+           remoteThread.isOctetThread() &&
+           remoteThread != myThread;
+  }
+  
+  /** For debugging purposes */
+  static final void checkForResponseTimeout(int numThreadsSentRequest, RVMThread theRemoteThread, long startTime, long timeout) {
+    RVMThread myThread = RVMThread.getCurrentThread();
+    if (/*RVMThread.getCurrentThread().octetThreadsWaitedFor > 0 ||*/ Stats.nsElapsed(startTime) > timeout) {
+      //sysCall.sysMonitorExit(myThread.octetMonitor);
+      RVMThread.debugLock.lockNoHandshake();
+      VM.sysWriteln("Thread ", myThread.threadSlot, " waited for a while but no response, microSecElapsed = ", Stats.nsElapsed(startTime));
+      VM.sysWriteln("numThreadsSentRequest = ", numThreadsSentRequest);
+      if (theRemoteThread != null) {
+        VM.sysWriteln("theRemoteThread slot = ", theRemoteThread.threadSlot);
+      }
+      for (RVMThread otherThread : RVMThread.threadBySlot) {
+        
+        if (isValidOtherThread(otherThread, myThread)) {
+          /*
+          Request request = myThread.octetRequests[remoteThread.threadSlot];
+          if (request.clock == newClock) {
+            VM.sysWriteln("Sent a request to thread ", remoteThread.threadSlot);
+            if (remoteThread.octetResponses[myThread.threadSlot] != newClock) {
+              VM.sysWriteln("No response from thread ", remoteThread.threadSlot);
+            }
+          } else */ {
+            VM.sysWriteln("Other thread ", otherThread.threadSlot);
+          }
+          Stats.tryToPrintStack(otherThread.framePointer);
+        }
+      }
+      RVMThread.debugLock.unlock();
+      //sysCall.sysMonitorEnter(myThread.octetMonitor);
+      VM.sysFail("Got stuck");
+    }
+  }
+
+  private static final Word HIGHEST_COUNTER_BIT_MASK = Word.one().lsh(CommunicationQueue.COUNTER_BITS - 1);
+
+  private static final int maxDiff = Octet.getClientAnalysis().incRequestCounterForImplicitProtocol()?
+      /** In this case we assume the difference between the two counter values
+       *  should not exceed one third of the entire range.
+       *  The trick of shifting n-1 bits then times 2 is to avoid negative number.*/
+      (1 << (CommunicationQueue.COUNTER_BITS - 1)) / 3 * 2 :
+      // Actually, this should be the max number of live octet threads that the application can have.
+      RVMThread.MAX_THREADS;
+                                     
+  // This method should only be called by the REQUESTING thread
+  @Inline
+  private static final boolean responseReceived(int response, int oldRequest) {
+    if (VM.VerifyAssertions) {
+      checkCounterRange(true, response, oldRequest);
+    }
+    return respGEreq(response, oldRequest);
+  }
+  
+  // This method should only be called by the RESPONDING thread
+  @Inline
+  private static final boolean requestSeen(int response, int newRequest) {
+    if (VM.VerifyAssertions) {
+      // The newRequest counter should not grow too fast.
+      checkCounterRange(false, response, newRequest);
+    }
+    return !respGEreq(response, newRequest);
+  }
+  
+  /** If response>=request, then the response has been received;
+   * for handling overflow, the condition is: (response-request)%(2^k) is within [0, 2^(k-1)-1],
+   * where k is COUNTER_BITS, and we assume that the amount of increment for the counter should not exceed half of 2^k.
+   * It is equivalent to checking if the highest counter bit of (response-request) is zero,
+   * the AND op for computing %(2^k) is not even needed for implementation. */
+  @Inline
+  private static final boolean respGEreq(int response, int request){
+    return Word.fromIntSignExtend(response - request).and(HIGHEST_COUNTER_BIT_MASK).isZero();
+  }
+  
+  private static final void checkCounterRange(boolean isOldRequest, int response, int request) {
+    boolean failed = false;
+    if (Octet.getClientAnalysis().incRequestCounterForImplicitProtocol()) {
+      int diff;
+      if (isOldRequest && respGEreq(response, request)) {
+        diff = getDiff(response, request);
+      } else {
+        diff = getDiff(request, response); 
+      }
+      if (diff > maxDiff) {
+        failed = true;
+        VM.sysWriteln("diff: ", diff);
+        VM.sysWriteln("maxDiff: ", maxDiff);
+        VM.sysWriteln("The difference of the two counters is larger than 1/3 of the entire value range!");
+      }
+    } else {
+      if (isOldRequest && respGEreq(response, request)) {
+        // no need to check this case
+        return;
+      }
+      int diff = getDiff(request, response);
+      if (diff > maxDiff - 1) {
+        failed = true;
+        if (isOldRequest) {
+          // Response counter should not be inside the "no-man's-land zone" of the counter range.
+          // If this check fails, our assumption will not hold: "the amount of increment for the counter should not exceed half of 2^k".
+          // This means the requesting thread is so slow in checking the responding thread that it missed the response.
+          VM.sysWrite("Requesting thread's slot: ", RVMThread.getCurrentThreadSlot());
+          VM.sysWriteln(" diff: ", diff);
+          VM.sysWriteln("Response counter grows too fast for requesting thread, already exceeds half of counter range!");
+        } else {
+          // The invariant "the responding thread can receive at most n-1 requests before it responds" is violated.
+          VM.sysWrite("Responding thread's slot: ", RVMThread.getCurrentThreadSlot());
+          VM.sysWriteln(" diff: ", diff);
+          VM.sysWriteln("Too many requests received for responding thread, max # of live octet threads is ", maxDiff);
+        }
+      }
+    }
+    
+    if (failed) {
+      VM.sysWriteln("response: ", response);
+      VM.sysWriteln("request: ", request);
+      RVMThread.dumpStack();
+      VM.sysFail("Request/response counters out of range");
+    }
+  }
+  
+  private static final int getDiff(int larger, int smaller) {
+    int diff;
+    if (larger >= smaller){
+      diff = larger - smaller;
+    } else {
+      // Man: "<<" has lower precedence than "+" or "-"
+      diff = (1 << CommunicationQueue.COUNTER_BITS) + larger - smaller;
+    }
+    return diff;
+  }
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/CommunicationQueue.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/CommunicationQueue.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/CommunicationQueue.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/CommunicationQueue.java	2014-04-03 17:43:46.969683520 -0400
@@ -0,0 +1,150 @@
+package org.jikesrvm.octet;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Word;
+
+/** Octet: helper methods for managing each thread's communication queue word. */
+@Uninterruptible
+public final class CommunicationQueue implements Constants {
+
+  /** The high bit of the request word indicates whether the thread is in the blocked state (including the dead state). */
+  private static final int BLOCKED_OR_DEAD_STATE_BITS = 1;
+  
+  /** The middle bits of the request word store a requesting thread's ID.
+      Zero (an invalid thread ID) indicates that the request queue is empty.
+      If the thread is in the blocked state, then these bits instead represent the number of holding threads. */
+  private static final int THREAD_OR_HOLD_BITS =
+    (Octet.getClientAnalysis().useHoldingState() ||
+     Octet.getClientAnalysis().needsCommunicationQueue()) ?
+    RVMThread.LOG_MAX_THREADS : 0; // Don't need any bits if we're not using queues or the hold state
+
+  /** The low bits of the request word are the request-respond counter. */
+  public static final int COUNTER_BITS = BITS_IN_WORD - THREAD_OR_HOLD_BITS - BLOCKED_OR_DEAD_STATE_BITS;
+
+  private static final Word BLOCKED_OR_DEAD_STATE_MASK = Word.max().lsh(BITS_IN_WORD - BLOCKED_OR_DEAD_STATE_BITS);
+  private static final Word DEAD_STATE = Word.max();
+  private static final Word THREAD_OR_HOLD_MASK = Word.one().lsh(THREAD_OR_HOLD_BITS).minus(Word.one()).lsh(COUNTER_BITS);
+  private static final Word COUNTER_MASK = Word.one().lsh(COUNTER_BITS).minus(Word.one());
+  //Man: This mask covers both THREAD_OR_HOLD_MASK and BLOCKED_OR_DEAD_STATE_MASK
+  private static final Word HIGHBITS_MASK = COUNTER_MASK.not();
+  static {
+    if (VM.VerifyAssertions) {
+      if (THREAD_OR_HOLD_BITS == 0) {
+        VM._assert(THREAD_OR_HOLD_MASK.isZero());
+      }
+    }
+  }
+
+  @Inline
+  public static final boolean isBlockedOrDead(Word requests) {
+    return !requests.and(BLOCKED_OR_DEAD_STATE_MASK).isZero();
+  }
+  
+  @Inline
+  public static final boolean isBlockedAssertNotDead(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(!isDead(requests)); }
+    return isBlockedOrDead(requests);
+  }
+  
+  /** In the dead state, all bits are set. */
+  @Inline
+  static final boolean isDead(Word requests) {
+    return requests.EQ(DEAD_STATE);
+  }
+  
+  @Inline
+  static final Word makeDead() {
+    return DEAD_STATE;
+  }
+  
+  @Inline
+  static final int getThreadID(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(!isBlockedAssertNotDead(requests)); }
+    return requests.rshl(COUNTER_BITS).toInt();
+  }
+  
+  @Inline
+  static final int getHoldCount(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(isBlockedAssertNotDead(requests)); }
+    return requests.and(THREAD_OR_HOLD_MASK).rshl(COUNTER_BITS).toInt();
+  }
+
+  @Inline
+  public static final int getCounter(Word requests) {
+    return requests.and(COUNTER_MASK).toInt();
+  }
+
+  @Inline
+  static final Word block(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(!isBlockedAssertNotDead(requests)); }
+    Word newRequests = requests.or(BLOCKED_OR_DEAD_STATE_MASK).and(THREAD_OR_HOLD_MASK.not());
+    if (VM.VerifyAssertions) { VM._assert(isBlockedAssertNotDead(newRequests)); }
+    if (VM.VerifyAssertions) { VM._assert(getHoldCount(newRequests) == 0); }
+    return newRequests;
+  }
+  
+  @Inline
+  static final Word unblock(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(isBlockedAssertNotDead(requests)); }
+    if (VM.VerifyAssertions) { VM._assert(getHoldCount(requests) == 0); }
+    Word newRequests = requests.and(BLOCKED_OR_DEAD_STATE_MASK.not());
+    if (VM.VerifyAssertions) { VM._assert(!isBlockedAssertNotDead(newRequests)); }
+    return newRequests;
+  }
+
+  @Inline
+  static final Word clearRequests(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(getThreadID(requests) != 0); }
+    Word newRequests = requests.and(THREAD_OR_HOLD_MASK.not());
+    if (VM.VerifyAssertions) { VM._assert(getThreadID(newRequests) == 0); }
+    return newRequests;
+  }
+
+  @Inline
+  static final Word push(Word requests, int newHeadThreadID) {
+    if (VM.VerifyAssertions) { VM._assert(!isBlockedAssertNotDead(requests)); }
+    Word oldCounter = requests.and(COUNTER_MASK);
+    // Man: commented out this assertion because we are now allowing counter to overflow
+    // if (VM.VerifyAssertions) { VM._assert(oldCounter.NE(COUNTER_MASK)); }
+    // return Word.fromIntZeroExtend(newHeadThreadID).lsh(COUNTER_BITS).or(oldCounter).plus(Word.one());
+    return Word.fromIntZeroExtend(newHeadThreadID).lsh(COUNTER_BITS).or(oldCounter.plus(Word.one()).and(COUNTER_MASK));
+  }
+
+  /** Increment the counter of the number of requests. */
+  @Inline
+  static final Word inc(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(!isDead(requests)); }
+    // if (VM.VerifyAssertions) { VM._assert(requests.and(COUNTER_MASK).NE(COUNTER_MASK)); }
+    // return requests.plus(Word.one());
+    return requests.and(HIGHBITS_MASK).or(requests.plus(Word.one()).and(COUNTER_MASK));
+  }
+  
+  /** Add a hold (i.e., increment the hold count) and also increment the number of requests. */
+  @Inline
+  static final Word addHoldAndIncrement(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(isBlockedAssertNotDead(requests)); }
+    if (VM.VerifyAssertions) { VM._assert(requests.and(THREAD_OR_HOLD_MASK).NE(THREAD_OR_HOLD_MASK)); }
+    // if (VM.VerifyAssertions) { VM._assert(requests.and(COUNTER_MASK).NE(COUNTER_MASK)); }
+    // return requests.plus(Word.one().lsh(COUNTER_BITS).plus(Word.one()));
+    return requests.and(HIGHBITS_MASK).plus(Word.one().lsh(COUNTER_BITS)).or(requests.plus(Word.one()).and(COUNTER_MASK));
+  }
+  
+  @Inline
+  static final Word addHold(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(isBlockedAssertNotDead(requests)); }
+    if (VM.VerifyAssertions) { VM._assert(requests.and(THREAD_OR_HOLD_MASK).NE(THREAD_OR_HOLD_MASK)); }
+    return requests.plus(Word.one().lsh(COUNTER_BITS));
+  }
+
+  @Inline
+  static final Word removeHold(Word requests) {
+    if (VM.VerifyAssertions) { VM._assert(isBlockedAssertNotDead(requests)); }
+    if (VM.VerifyAssertions) { VM._assert(!requests.and(THREAD_OR_HOLD_MASK).isZero()); }
+    return requests.minus(Word.one().lsh(COUNTER_BITS));
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/InstrDecisions.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/InstrDecisions.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/InstrDecisions.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/InstrDecisions.java	2014-04-03 17:43:46.971683526 -0400
@@ -0,0 +1,175 @@
+// Octet: decisions about adding instrumentation to the program
+package org.jikesrvm.octet;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.runtime.Entrypoints;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public final class InstrDecisions implements Constants {
+
+  /** Pass info about the particular field or array element accessed? */
+  @Inline public static final boolean passFieldInfo() {
+    return Octet.getClientAnalysis().needsFieldInfo();
+  }
+  /** If passing field info, should the field be passed as an offset (otherwise it's passed as a field ID)? */
+  @Inline public static final boolean useFieldOffset() {
+    return Octet.getClientAnalysis().useFieldOffset();
+  }
+  /** Helper method for getting field info, which can be an offset or a field ID. */
+  @Inline public static final int getFieldInfo(RVMField field) {
+    if (passFieldInfo()) {
+      if (useFieldOffset()) {
+        return field.getOffset().toInt();
+      } else {
+        return field.getId();
+      }
+    } else {
+      return 0;
+    }
+  }
+  
+  /** Pass information about the site (program location)? */
+  @Inline public static final boolean passSite() {
+    return Octet.getClientAnalysis().needsSites();
+  }
+
+  // decide about field and object metadata
+
+  public static final boolean staticFieldMightHaveMetadata(FieldReference fieldRef) {
+    //if (VM.VerifyAssertions) { VM._assert(!fieldRef.isResolved()); }
+    if (Octet.getConfig().addHeaderWord()) {
+      return Octet.shouldAddMetadataForField(fieldRef);
+    } else {
+      return false;
+    }
+  }
+
+  public static final boolean staticFieldHasMetadata(RVMField field) {
+    if (Octet.getConfig().addHeaderWord()) {
+      boolean hasMetadata = field.hasMetadataOffset();
+      // at least for now, we expect the metadata to provide the same result as for an unresolved field,
+      // except that the metadata should also be avoiding final fields
+      if (VM.VerifyAssertions) { VM._assert(hasMetadata == (staticFieldMightHaveMetadata(field.getMemberRef().asFieldReference()) && !field.isFinal())); }
+      return hasMetadata;
+    } else {
+      return false;
+    }
+  }
+
+  public static final boolean objectOrFieldMightHaveMetadata(FieldReference fieldRef) {
+    return Octet.getConfig().addHeaderWord();
+  }
+
+  public static final boolean objectOrFieldHasMetadata(RVMField field) {
+    // ignore final fields
+    return !field.isFinal() &&
+           objectOrFieldMightHaveMetadata(field.getMemberRef().asFieldReference());
+  }
+
+  /** The client analysis will call this if it doesn't want to change the default behavior. */
+  static final NormalMethod chooseBarrier(boolean isRead, boolean isField, boolean isResolved, boolean isStatic) {
+    // If pessimistic barriers are enabled, use those instead.
+    if (Octet.getConfig().usePessimisticBarriers()) {
+      return choosePessimisticBarrier(isRead, isField, isResolved, isStatic);
+    }
+    
+    if (isField) {
+      // scalar fields and statics
+      if (isRead) {
+        if (isResolved) {
+          if (isStatic) {
+            return Entrypoints.octetFieldReadBarrierStaticResolvedMethod;
+          } else {
+            return Entrypoints.octetFieldReadBarrierResolvedMethod;
+          }
+        } else {
+          if (isStatic) {
+            return Entrypoints.octetFieldReadBarrierStaticUnresolvedMethod;
+          } else {
+            return Entrypoints.octetFieldReadBarrierUnresolvedMethod;
+          }
+        }
+      } else {
+        if (isResolved) {
+          if (isStatic) {
+            return Entrypoints.octetFieldWriteBarrierStaticResolvedMethod;
+          } else {
+            return Entrypoints.octetFieldWriteBarrierResolvedMethod;
+          }
+        } else {
+          if (isStatic) {
+            return Entrypoints.octetFieldWriteBarrierStaticUnresolvedMethod;
+          } else {
+            return Entrypoints.octetFieldWriteBarrierUnresolvedMethod;
+          }
+        }
+      }
+    } else {
+      // arrays
+      if (VM.VerifyAssertions) { VM._assert(isResolved); } // array accesses can't be unresolved
+      if (isRead) {
+        return Entrypoints.octetArrayReadBarrierMethod;
+      } else {
+        return Entrypoints.octetArrayWriteBarrierMethod;
+      }
+    }
+  }
+
+  /** Chooses a pessimistic barrier, which is a barrier that always uses a CAS or fence, instead of being optimistic. */
+  static final NormalMethod choosePessimisticBarrier(boolean isRead, boolean isField, boolean isResolved, boolean isStatic) {
+    if (VM.VerifyAssertions) { VM._assert(Octet.getConfig().usePessimisticBarriers()); }
+    
+    if (isField) {
+      // scalar fields and statics
+      if (isRead) {
+        if (isResolved) {
+          if (isStatic) {
+            return Entrypoints.octetPessimisticFieldReadBarrierStaticResolvedMethod;
+          } else {
+            return Entrypoints.octetPessimisticFieldReadBarrierResolvedMethod;
+          }
+        } else {
+          if (isStatic) {
+            return Entrypoints.octetPessimisticFieldReadBarrierStaticUnresolvedMethod;
+          } else {
+            return Entrypoints.octetPessimisticFieldReadBarrierUnresolvedMethod;
+          }
+        }
+      } else {
+        if (isResolved) {
+          if (isStatic) {
+            return Entrypoints.octetPessimisticFieldWriteBarrierStaticResolvedMethod;
+          } else {
+            return Entrypoints.octetPessimisticFieldWriteBarrierResolvedMethod;
+          }
+        } else {
+          if (isStatic) {
+            return Entrypoints.octetPessimisticFieldWriteBarrierStaticUnresolvedMethod;
+          } else {
+            return Entrypoints.octetPessimisticFieldWriteBarrierUnresolvedMethod;
+          }
+        }
+      }
+    } else {
+      // arrays
+      if (VM.VerifyAssertions) { VM._assert(isResolved); } // array accesses can't be unresolved
+      if (isRead) {
+        return Entrypoints.octetPessimisticArrayReadBarrierMethod;
+      } else {
+        return Entrypoints.octetPessimisticArrayWriteBarrierMethod;
+      }
+    }
+  }
+  /** returns a call for getting metadata operand of unresolved statics at runtime. */
+  public static final NormalMethod resolveStatic() {
+    return Entrypoints.octetResolveMethod;
+  }
+
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/LoadDataRaces.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/LoadDataRaces.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/LoadDataRaces.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/LoadDataRaces.java	2014-04-03 17:43:46.973683534 -0400
@@ -0,0 +1,79 @@
+package org.jikesrvm.octet;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.StringTokenizer;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.util.HashSetRVM;
+
+public class LoadDataRaces {
+ 
+  public static void readRaces() {
+    String chordDirectory = VM.staticRaceDir;
+    if (VM.VerifyAssertions) { VM._assert((chordDirectory != null) && (chordDirectory.length() > 0)); }
+    
+    // Allocate hash set here. The VM is already supposed to be running.
+    Site.raceSites = new HashSetRVM<Site>();
+    
+    try {
+      BufferedReader reader = new BufferedReader(new FileReader(chordDirectory));
+      String line = null;
+      try {
+        StringTokenizer st;
+        while ((line = reader.readLine()) != null) {      
+          if (line.length() == 0) { 
+            continue;
+          }
+          st = new StringTokenizer(line,"|\n");
+          String methodName = "";
+          String methodDesc = "";
+          String classDesc = "";
+          String bcIndex = "";
+          String lineNo = "";
+          String accessType = "";
+          int count = 0;
+          while (st.hasMoreTokens()) {
+            count++;
+            String s = (String)st.nextElement();
+            s = s.trim();
+            String split[] = s.split(":");
+            switch(count) {
+            case 1:
+              methodName = split[1];
+              break;
+            case 2:
+              methodDesc = split[1];
+              break;
+            case 3:
+              classDesc = split[1];
+              break;
+            case 4:
+              bcIndex = split[1];
+              break;
+            case 5:            
+              lineNo = split[1];
+              break;
+            case 6:
+              accessType = split[1];
+              break;
+            default:
+              VM.sysFail("Case not found while reading race file");
+            }                       
+          }            
+          Site.registerRaceSite(Atom.findOrCreateAsciiAtom(classDesc), Atom.findOrCreateAsciiAtom(methodName), Atom.findOrCreateAsciiAtom(methodDesc), Integer.parseInt(bcIndex), Integer.parseInt(lineNo), null);          
+        } 
+      } catch(IOException e) {
+        System.out.println(e.toString());
+      } finally {
+        reader.close();
+      }
+    } catch(IOException e) {
+      VM.sysWrite("Cannot read data races from file ");
+      VM.sysFail("Failed to read race file");
+    }
+  }  
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/NullAnalysis.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/NullAnalysis.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/NullAnalysis.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/NullAnalysis.java	2014-04-03 17:43:46.969683520 -0400
@@ -0,0 +1,22 @@
+/** Octet: a client analysis that doesn't really do anything */
+package org.jikesrvm.octet;
+
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public final class NullAnalysis extends ClientAnalysis {
+
+  @Override
+  public final boolean supportsIrBasedBarriers() {
+    // OctetOptInstr will insert IR instructions that are correct for the basic Octet barriers,
+    // but not for any client analyses that modify the default Octet barrier behavior.
+    return true;
+  }
+  
+  @Override
+  @Pure
+  public boolean incRequestCounterForImplicitProtocol() {
+    return false;
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/OctetBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/OctetBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/OctetBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/OctetBarriers.java	2014-04-03 17:43:46.974683538 -0400
@@ -0,0 +1,174 @@
+// Octet: instrumentation added to the program
+package org.jikesrvm.octet;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.objectmodel.MiscHeader;
+import org.jikesrvm.runtime.Magic;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+
+@Uninterruptible
+public final class OctetBarriers implements Constants {
+
+  @Inline
+  @Entrypoint
+  static final boolean readObject(Object o, int fieldOrIndexInfo, int siteID) {
+    return StateTransfers.read(ObjectReference.fromObject(o).toAddress(), MiscHeader.OCTET_OFFSET, fieldOrIndexInfo, siteID);
+  }
+  
+  @Inline
+  @Entrypoint
+  static final boolean writeObject(Object o, int fieldOrIndexInfo, int siteID) {
+    return StateTransfers.write(ObjectReference.fromObject(o).toAddress(), MiscHeader.OCTET_OFFSET, fieldOrIndexInfo, siteID);
+  }
+  
+  @Inline
+  @Entrypoint
+  static final boolean readStatic(Offset octetOffset, int fieldInfo, int siteID) {
+    return StateTransfers.read(Magic.getJTOC(), octetOffset, fieldInfo, siteID);
+  }
+
+  @Inline
+  @Entrypoint
+  static final boolean writeStatic(Offset octetOffset, int fieldInfo, int siteID) {
+    return StateTransfers.write(Magic.getJTOC(), octetOffset, fieldInfo, siteID);
+  }
+
+  @Entrypoint
+  @Inline
+  public static final void fieldReadBarrierResolved(Object o, int fieldInfo, int siteID) {
+    readObject(o, fieldInfo, siteID);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldWriteBarrierResolved(Object o, int fieldInfo, int siteID) {
+    writeObject(o, fieldInfo, siteID);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldReadBarrierStaticResolved(Offset octetOffset, int fieldInfo, int siteID) {
+    readStatic(octetOffset, fieldInfo, siteID);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldWriteBarrierStaticResolved(Offset octetOffset, int fieldInfo, int siteID) {
+    writeStatic(octetOffset, fieldInfo, siteID);
+  }
+  
+  // Octet: TODO: field might not actually be resolved here if inserted in the opt compiler during early instrumentation!
+  
+  // Octet: TODO: can we resolve a field?  is that interruptible?  how does that work in Jikes?
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldReadBarrierUnresolved(Object o, int fieldID, int siteID) {
+    int fieldInfo = getFieldInfo(fieldID);
+    readObject(o, fieldInfo, siteID);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldWriteBarrierUnresolved(Object o, int fieldID, int siteID) {
+    int fieldInfo = getFieldInfo(fieldID);
+    writeObject(o, fieldInfo, siteID);
+  }
+  
+  // Octet: LATER: the hasMetadataOffset checks are necessary because some fields --
+  // in particular, *final* fields -- might get instrumentation added for them at
+  // "unresolved static" accesses, but their resolved fields won't have a metadata offset.
+  
+  @Entrypoint
+  @NoInline
+  public static final void fieldReadBarrierStaticUnresolved(int fieldID, int siteID) {
+    RVMField field = handleUnresolvedField(fieldID);
+    if (field.hasMetadataOffset()) {
+      int fieldInfo = getFieldInfo(field, fieldID);
+      readStatic(field.getMetadataOffset(), fieldInfo, siteID);
+    }
+  }
+  
+  @Entrypoint
+  @NoInline
+  public static final void fieldWriteBarrierStaticUnresolved(int fieldID, int siteID) {
+    RVMField field = handleUnresolvedField(fieldID);
+    if (field.hasMetadataOffset()) {
+      int fieldInfo = getFieldInfo(field, fieldID);
+      writeStatic(field.getMetadataOffset(), fieldInfo, siteID);
+    }
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void arrayReadBarrier(Object o, int index, int siteID) {
+    readObject(o, index, siteID);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void arrayWriteBarrier(Object o, int index, int siteID) {
+    writeObject(o, index, siteID);
+  }
+
+  // Helper methods:
+  
+  @Inline
+  public static final RVMField handleUnresolvedField(int fieldID) {
+    FieldReference fieldRef = FieldReference.getMemberRef(fieldID).asFieldReference();
+    return fieldRef.getResolvedField();
+  }
+  
+  @Inline
+  public static final int getFieldInfo(int fieldID) {
+    if (InstrDecisions.passFieldInfo()) {
+      if (InstrDecisions.useFieldOffset()) {
+        return handleUnresolvedField(fieldID).getOffset().toInt();
+      } else {
+        return fieldID;
+      }
+    } else {
+      return 0;
+    }
+  }
+  
+  @Inline
+  public static final int getFieldInfo(RVMField field, int fieldID) {
+    if (InstrDecisions.passFieldInfo()) {
+      if (InstrDecisions.useFieldOffset()) {
+        return field.getOffset().toInt();
+      } else {
+        return fieldID;
+      }
+    } else {
+      return 0;
+    }
+  }
+  
+  /** takes field ID of an unresolved static and returns its metadata; it is resolved at runtime before the access */
+  @Entrypoint
+  @NoInline
+  public static final Word getResolved(int fieldID) {
+    // FieldReference fieldRef = FieldReference.getMemberRef(fieldID).asFieldReference();
+    // RVMField field = fieldRef.getResolvedField();
+    RVMField field = handleUnresolvedField(fieldID);
+    // Man: actually getAddressAtOffset() performs the actual load word from the memory address, but why not use the easier-to-understand idiom? 
+    // Address addr = Magic.getAddressAtOffset( Magic.getJTOC(), field.getMetadataOffset());
+    // return addr.loadWord();
+    if (field.hasMetadataOffset()) {
+      return Magic.getTocPointer().prepareWord(field.getMetadataOffset());
+    }
+    /** Man: returning zero will make the IR call the slowpath method, which is fieldReadBarrierStaticUnresolved() or fieldWriteBarrierStaticUnresolved().
+     *  It will try to resolve the fieldID again, then just returns without executing the barrier.
+     */
+    return Word.zero();
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Octet.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Octet.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Octet.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Octet.java	2014-04-03 17:43:46.969683520 -0400
@@ -0,0 +1,132 @@
+// Octet: centralized location for various settings and functionality
+// Octet: TODO: Should we remove trailing spaces in our source (according to http://jikesrvm.org/Coding+Style)?
+
+package org.jikesrvm.octet;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.config.BaseConfig;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public final class Octet implements Constants {
+  
+  /** Get the actual build configuration */
+  @Inline @Pure
+  public static final BaseConfig getConfig() {
+    return VM.octetConfig;
+  }
+  
+  private static final ClientAnalysis clientAnalysis = getConfig().constructClientAnalysis();
+  
+  @Inline @Pure
+  public static final ClientAnalysis getClientAnalysis() {
+    return clientAnalysis;
+  }
+  
+  /** How much debugging info to print? */
+  public static final int verbosity = VM.VerifyAssertions ? 2 : 1;
+
+  // Optimizations or lack thereof
+  
+  @Inline
+  public static final boolean useEscapeAnalysis() {
+    // Octet: LATER: Jikes escape analysis seems to very broken
+    return false;
+    //return !VM.octetNoEscapeAnalysis;
+  }
+
+  // Debugging and tuning
+  
+  /** When waiting, how many spin loops to do before switching to pthread yield? */
+  @Inline static final int waitSpinCount() { return VM.octetWaitSpinCount; }
+  
+  /** When waiting, how many yields to do before switching to a pthread condition wait? */
+  @Inline static final int waitYieldCount() { return VM.octetWaitYieldCount; }
+  
+  // Decisions about which code, objects, and fields to instrument
+  
+  /** Is the site a racy site based on static race detection? */
+  @Interruptible @Inline
+  public static final boolean shouldInstrumentCheckRace(RVMMethod method, int bci) {
+    // Octet: TODO: Most libraries are instrumented during bootimage build time. However, we don't check for racy accesses
+    // during bootimage build, the racy accesses are populated in the hash set later. This is done so that the hash 
+    // set containing racy sites can grow. An alternative would be to allow the hash set to grow even when the VM is not
+    // running. Moreover, we are also not absolutely sure about the thoroughness of Chord's output with all library 
+    // packages. Hence we conservatively instrument all library classes when the VM is not yet running.
+    if (!VM.runningVM) {
+      return true;
+    }
+    return Site.isRegisteredRacySite(method.getDeclaringClass().getDescriptor(), method.getName(), method.getDescriptor(), bci, 0, null);
+  }
+
+  /** Instrument a method? */
+  @Inline @Pure
+  public static final boolean shouldInstrumentMethod(RVMMethod method) {
+    // Octet: LATER: it doesn't really make sense to do static cloning of the libraries if getConfig().instrumentLibraries() == false
+    // Velodrome: Context: APP context now means TRANS/NONTRANS
+    return (method.getStaticContext() == Context.TRANS_CONTEXT || method.getStaticContext() == Context.NONTRANS_CONTEXT) && 
+            (getConfig().instrumentLibraries() || 
+            !Context.isLibraryPrefix(method.getDeclaringClass().getTypeRef()) && !Context.isVMPrefix(method.getDeclaringClass().getTypeRef()))  &&
+            !method.getDeclaringClass().getDescriptor().isPrefix(EXCLUDED_PREFIXES) && getClientAnalysis().isSelectedInstrMethod((NormalMethod)method);
+  }
+
+  /** Instrument a class? */
+  @Inline @Pure
+  public static final boolean shouldInstrumentClass(TypeReference tRef) {
+    return (getConfig().instrumentLibraries() || !Context.isLibraryPrefix(tRef)) &&
+           !Context.isVMPrefix(tRef) &&
+           !tRef.getName().isPrefix(EXCLUDED_PREFIXES);
+  }
+
+  /** Instrument an access to a field? */
+  @Inline @Pure
+  public static final boolean shouldInstrumentFieldAccess(FieldReference fieldRef) {
+    TypeReference typeRef = fieldRef.getType();
+    return (Context.isApplicationPrefix(typeRef) ||
+            // Octet: TODO: Even if library instrumentation is disabled, should we instrument accesses to library objects?
+            (Context.isLibraryPrefix(typeRef) && getConfig().instrumentLibraries())) /*&&
+            !typeRef.getName().isPrefix(EXCLUDED_PREFIXES)*/;
+  }
+
+  /** Add metadata for a field? Applies to static fields only. */
+  @Inline @Pure
+  public static final boolean shouldAddMetadataForField(FieldReference fieldRef) {
+    return shouldInstrumentFieldAccess(fieldRef);
+  }
+
+  private static final byte[][] EXCLUDED_PREFIXES = {
+    // Instances of the following types are immutable (so are some others, but according to the statistics for DaCapo, the others aren't a big problem)
+    // Octet: TODO: However, it's still possible that there could be methods (e.g., static methods) that access shared, mutable data.
+    // Need to check more carefully.  It's really that just these classes' data should be considered immutable.
+    // For example, some String methods read from a StringBuffer, which may need to trigger an Octet slow path.
+    // So this needs to be fixed.
+    "Ljava/lang/String".getBytes(),
+    "Ljava/lang/Integer".getBytes(),
+    "Ljava/lang/Character".getBytes(),
+  };
+
+  /** Tolerate exceptions inside barriers, which are uninterruptible (and would normally cause the VM to fail). */
+  @Inline
+  public static final boolean tolerateExceptionsInUninterruptibleCode() {
+    return getConfig().insertBarriers();
+  }
+  
+  /** Boot-time activities. */
+  @Interruptible
+  public static final void boot() {
+    if (Octet.getConfig().enableStaticRaceDetection()) {
+      LoadDataRaces.readRaces();
+    }
+    Octet.getClientAnalysis().boot();
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/OctetState.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/OctetState.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/OctetState.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/OctetState.java	2014-04-03 17:43:46.970683523 -0400
@@ -0,0 +1,278 @@
+package org.jikesrvm.octet;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+
+/** Octet: representation of Octet state in Octet metadata */
+@Uninterruptible
+public class OctetState implements Constants {
+
+  // General layout for all:
+  // lowest 3 bits: state (lowest bit is 0, which is a Jikes requirement)
+  // highest 2 bits: 11 for read-shared; 00, 01, or 10 for all others
+  // In current implementation, the highest 2 bits cannot be 00,
+  // because we limit the RVMThread address to be at least 0x40000000.
+  
+  // Layout for write-excl, read-excl, and intermediate:
+  // bit 0: 0 (Jikes requirement)
+  // bit 1: 0 if write-excl; 1 if read-excl or intermediate
+  // bit 2: 1 if write-excl or read-excl (works nicely because this bit is always 1 in the RVMThread address); 0 if intermediate
+  // high 29 bits: high 29 bits of owner RVMThread object (won't be 11 because that maps to kernel addresses)
+
+  // Thus, for write-excl, metadata == RVMThread address
+  
+  // Layout for read-shared:
+  // lowest 3 bits: 000
+  // middle bits: value of global read-shared counter when object become read-shared
+  // highest 2 bits: 11
+  
+  // Thus, metadata is read-shared iff metadata >= 1100..00 (binary)
+  
+  static final int STATE_BITS = 3;
+  static final int READ_SHARED_HIGH_BITS = 2;
+
+  static final Word WRITE_EXCL = Word.fromIntZeroExtend(0x4); // 100
+  static final Word READ_EXCL = Word.fromIntZeroExtend(0x6); // 110
+  static final Word READ_SHARED = Word.fromIntZeroExtend(0x0); // 000
+  static final Word INTERMEDIATE = Word.fromIntZeroExtend(0x2); // 010
+
+  private static final Word EXCL_MASK = Word.fromIntZeroExtend(0x4); // 100
+  private static final Word INTERMEDIATE_XOR_MASK = Word.fromIntZeroExtend(0x6); // 110
+  static final Word STATE_MASK = Word.one().lsh(STATE_BITS).minus(Word.one()); // 111
+  public static final Word THREAD_MASK_FOR_EXCL_STATE = Word.fromIntZeroExtend(~0x3); // 111..11100
+
+  // read shared counter stuff; relies on top 2 bits being available (not used by other states)
+  public static final Word MIN_READ_SHARED = Word.max().lsh(BITS_IN_WORD - READ_SHARED_HIGH_BITS); // 1100...00
+  public static final Word MAX_READ_SHARED = Word.max().lsh(STATE_BITS); // 11...11000
+  public static final Word READ_SHARED_DEC = Word.one().lsh(STATE_BITS); // 000...001000
+  @Entrypoint
+  public static Word globalReadSharedCounter = MAX_READ_SHARED;
+  
+  // Changes for RdEx -> RdSh transition
+  // Values to lock the read shared counter: 000...0 means locked  
+  public static final Word READ_SHARED_COUNTER_LOCKED = Word.zero();
+  
+  // constructing metadata for various states and threads:
+  
+  @Inline
+  static final Word getExclusive(Word state) {
+    if (VM.VerifyAssertions) { VM._assert(state.EQ(WRITE_EXCL) || state.EQ(READ_EXCL)); }
+    return ObjectReference.fromObject(RVMThread.getCurrentThread()).toAddress().toWord().or(state);
+  }
+  
+  @Inline
+  public static final Word getInitial() {
+    if (VM.runningVM) {
+      return getExclusive(WRITE_EXCL);
+    } else {
+      // The "uninitialized state"
+      return MIN_READ_SHARED;
+    }
+  }
+  
+  @Inline
+  public static final Word getIntermediate() {
+    return ObjectReference.fromObject(RVMThread.getCurrentThread()).toAddress().toWord().xor(INTERMEDIATE_XOR_MASK);
+  }
+  
+  @Inline
+  static final Word decReadSharedCounter() {
+    // first decrement the counter
+    Word oldValue;
+    Word newValue;
+    Offset offset = Entrypoints.octetGlobalReadSharedCounterField.getOffset(); 
+    do {
+      oldValue = Magic.getTocPointer().prepareWord(offset);
+      newValue = oldValue.minus(READ_SHARED_DEC);
+    } while (!Magic.getTocPointer().attempt(oldValue, newValue, offset));
+    return newValue;
+  }
+  
+  @Inline
+  static final Word lockReadSharedCounter() {
+    Word oldValue;
+    Offset offset = Entrypoints.octetGlobalReadSharedCounterField.getOffset();
+    boolean result = false;
+    do {
+      oldValue = Magic.getTocPointer().prepareWord(offset);
+      // If the gRdShCtr is already locked, wait until it's unlocked.
+      if (oldValue.NE(READ_SHARED_COUNTER_LOCKED)) {
+        Word newValue = READ_SHARED_COUNTER_LOCKED;
+        result = Magic.getTocPointer().attempt(oldValue, newValue, offset);
+      }
+    } while (!result);
+    return oldValue;
+  }
+  
+  // queries about states:
+  
+  @Inline
+  public static final boolean isWriteExclForCurrentThread(Word metadata) {
+    return metadata.EQ(ObjectReference.fromObject(RVMThread.getCurrentThread()).toAddress().toWord());
+  }
+  
+  @Inline
+  public static final boolean isWriteExclForGivenThread(RVMThread thread, Word metadata) {
+    return metadata.EQ(ObjectReference.fromObject(thread).toAddress().toWord());
+  }
+  
+  @Inline
+  public static final boolean isReadExcl(Word metadata) {
+    return metadata.and(STATE_MASK).EQ(READ_EXCL);
+  }
+
+  @Inline
+  public static final boolean isExclForCurrentThread(Word metadata) {
+    Word thread = ObjectReference.fromObject(RVMThread.getCurrentThread()).toAddress().toWord();
+    return metadata.and(THREAD_MASK_FOR_EXCL_STATE).EQ(thread);
+  }
+  
+  @Inline
+  public static final boolean isReadExclForCurrentThread(Word metadata) {    
+    return metadata.and(STATE_MASK).EQ(READ_EXCL);
+  }
+  
+  /** Does the metadata represent the RdSh state? */
+  @Inline
+  public static final boolean isReadSharedPossiblyUnfenced(Word metadata) {
+    boolean result = metadata.GE(MIN_READ_SHARED);
+    if (VM.VerifyAssertions) {
+      VM._assert(!result || !isExclState(metadata));
+    }
+    return result;
+  }
+
+  /** Does the metadata represent the RdSh state but needs a fence transition? */
+  @Inline
+  public static final boolean isReadSharedUnfenced(Word metadata) {
+    if (isReadSharedPossiblyUnfenced(metadata)) {
+      return RVMThread.getCurrentThread().octetReadSharedCounter.GT(metadata);
+    }
+    return false;
+  }
+  
+  /** Does the metadata represent the RdSh state and doesn't need a fence transition? */
+  @Inline
+  public static final boolean isReadSharedAndFenced(Word metadata) {
+    // the value of the metadata will be greater than the local counter
+    boolean result = RVMThread.getCurrentThread().octetReadSharedCounter.LE(metadata);
+    if (VM.VerifyAssertions) {
+      VM._assert(!result || !isExclState(metadata));
+    }
+    return result;
+  }
+  
+  @Inline
+  static final Word getState(Word metadata) {
+    return metadata.and(STATE_MASK);
+  }
+
+  @Inline
+  public static final boolean isExclState(Word metadata) {
+    if (VM.VerifyAssertions) { VM._assert(getState(metadata).NE(INTERMEDIATE)); }
+    return !metadata.and(EXCL_MASK).isZero();
+  }
+  
+  @Inline
+  public static final boolean isExclStateWithoutAssert(Word metadata) {
+    return !metadata.and(EXCL_MASK).isZero();
+  }
+
+  // getting threads from metadata:
+  
+  @Inline
+  public static final RVMThread getThreadFromExclusive(Word metadata) {
+    if (VM.VerifyAssertions) { VM._assert(getState(metadata).EQ(READ_EXCL) || getState(metadata).EQ(WRITE_EXCL)); }
+    Word value = metadata.and(THREAD_MASK_FOR_EXCL_STATE);
+    return Magic.objectAsThread(value.toAddress().toObjectReference().toObject());
+  }
+  
+  @Inline
+  static final RVMThread getThreadFromIntermediate(Word metadata) {
+    if (VM.VerifyAssertions) { VM._assert(getState(metadata).EQ(INTERMEDIATE)); }
+    Word value = metadata.xor(INTERMEDIATE_XOR_MASK);
+    return Magic.objectAsThread(value.toAddress().toObjectReference().toObject());
+  }
+
+  /** Combined read check: checks for WrEx, RdEx, and fenced RdSh with one conditional.
+      It turns out to be *slower* than checking for WrEx/RdEx and then checking for RdSh if that fails. */
+  @Inline
+  static final boolean isReadable(Word metadata) {
+    // mask will be 0xffffffff for fenced RdSh;
+    // otherwise: a small number (0x0, 0x1, or 0x2)
+    Word mask = metadata.minus(RVMThread.getCurrentThread().octetReadSharedCounter).rshl(BITS_IN_WORD - READ_SHARED_HIGH_BITS).minus(Word.one());
+    // make a WrEx or RdEx both look like the thread address by masking out the second-lowest bit,
+    // then OR by the mask, which yields 0xffffffff for fenced RdSh, but otherwise leaves the top 30 bits unaffected
+    Word maskedMetadata = metadata.and(THREAD_MASK_FOR_EXCL_STATE).or(mask);
+    // also mask the thread, which yields 0xffffffff for fenced RdSh, but otherwise leaves the top 30 bits unaffected
+    Word maskedThread  = ObjectReference.fromObject(RVMThread.getCurrentThread()).toAddress().toWord().or(mask);
+    return maskedMetadata.EQ(maskedThread);
+  }
+  
+  // sanity checking:
+  
+  @Inline
+  public static final void check(Word metadata) {
+    if (VM.VerifyAssertions) {
+      checkNoInline(metadata);
+    }
+  }
+
+  @NoInline
+  private static final void checkNoInline(Word metadata) {
+    Word state = getState(metadata);
+    if (state.EQ(WRITE_EXCL) || state.EQ(READ_EXCL) || state.EQ(INTERMEDIATE)) {
+      RVMThread otherThread;
+      if (state.EQ(WRITE_EXCL) || state.EQ(READ_EXCL)) {
+        otherThread = getThreadFromExclusive(metadata);
+      } else {
+        otherThread = getThreadFromIntermediate(metadata);
+      }
+
+      // Octet: LATER: fix?
+      /*
+      // is it some kind of thread?
+      // is it either our current thread or a regular RVMThread or the FinalizerThread?
+      RVMType otherType = ObjectModel.getObjectType(otherThread);
+      myAssert(TypeReference.Thread.peekType().isAssignableFrom(otherType), metadata);
+      TypeReference otherTypeRef = otherType.getTypeRef();
+      if (!(otherTypeRef == TypeReference.Thread ||
+            otherTypeRef == TypeReference.FinalizerThread ||
+            otherTypeRef == TypeReference.CompilationThread ||
+            otherTypeRef == TypeReference.ControllerThread ||
+            otherThread == RVMThread.getCurrentThread())) {
+        VM.sysWriteln(otherTypeRef.getName());
+        VM.sysWriteln(ObjectModel.getObjectType(RVMThread.getCurrentThread()).getDescriptor());
+      }
+      
+      myAssert(otherTypeRef == TypeReference.Thread ||
+               otherTypeRef == TypeReference.FinalizerThread ||
+               otherTypeRef == TypeReference.CompilationThread ||
+               otherTypeRef == TypeReference.ControllerThread ||
+               otherThread == RVMThread.getCurrentThread(), metadata);
+      */
+
+    } else if (state.EQ(READ_SHARED)) {
+      myAssert(isReadSharedPossiblyUnfenced(metadata), metadata);
+    } else {
+      myAssert(false, metadata);
+    }
+  }
+  
+  private static final void myAssert(boolean b, Word metadata) {
+    if (!b) {
+      VM.sysWriteln("Metadata: ", metadata);
+    }
+    VM._assert(b);
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/PessimisticBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/PessimisticBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/PessimisticBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/PessimisticBarriers.java	2014-04-03 17:43:46.973683534 -0400
@@ -0,0 +1,112 @@
+package org.jikesrvm.octet;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.objectmodel.MiscHeader;
+import org.jikesrvm.runtime.Magic;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+
+/** Octet: pessimistic barriers that always use a CAS or fence instead of Octet's optimistic approach */
+@Uninterruptible
+public final class PessimisticBarriers implements Constants {
+
+  @Inline
+  static final void readObject(Object o) {
+    Octet.getConfig().pessimisticRead(ObjectReference.fromObject(o).toAddress().plus(MiscHeader.OCTET_OFFSET));
+  }
+  
+  @Inline
+  static final void writeObject(Object o) {
+    Octet.getConfig().pessimisticWrite(ObjectReference.fromObject(o).toAddress().plus(MiscHeader.OCTET_OFFSET));
+  }
+  
+  @Inline
+  static final void readStatic(Offset octetOffset) {
+    Octet.getConfig().pessimisticRead(Magic.getJTOC().plus(octetOffset));
+  }
+
+  @Inline
+  static final void writeStatic(Offset octetOffset) {
+    Octet.getConfig().pessimisticWrite(Magic.getJTOC().plus(octetOffset));
+  }
+
+  @Entrypoint
+  @Inline
+  public static final void fieldReadBarrierResolved(Object o, int fieldInfo, int siteID) {
+    readObject(o);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldWriteBarrierResolved(Object o, int fieldInfo, int siteID) {
+    writeObject(o);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldReadBarrierStaticResolved(Offset octetOffset, int fieldInfo, int siteID) {
+    readStatic(octetOffset);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldWriteBarrierStaticResolved(Offset octetOffset, int fieldInfo, int siteID) {
+    writeStatic(octetOffset);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldReadBarrierUnresolved(Object o, int fieldID, int siteID) {
+    readObject(o);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void fieldWriteBarrierUnresolved(Object o, int fieldID, int siteID) {
+    writeObject(o);
+  }
+  
+  @Entrypoint
+  @NoInline
+  public static final void fieldReadBarrierStaticUnresolved(int fieldID, int siteID) {
+    RVMField field = handleUnresolvedField(fieldID);
+    if (field.hasMetadataOffset()) {
+      readStatic(field.getMetadataOffset());
+    }
+  }
+  
+  @Entrypoint
+  @NoInline
+  public static final void fieldWriteBarrierStaticUnresolved(int fieldID, int siteID) {
+    RVMField field = handleUnresolvedField(fieldID);
+    if (field.hasMetadataOffset()) {
+      writeStatic(field.getMetadataOffset());
+    }
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void arrayReadBarrier(Object o, int index, int siteID) {
+    readObject(o);
+  }
+  
+  @Entrypoint
+  @Inline
+  public static final void arrayWriteBarrier(Object o, int index, int siteID) {
+    writeObject(o);
+  }
+
+  // Helper method:
+  
+  @Inline
+  private static final RVMField handleUnresolvedField(int fieldID) {
+    FieldReference fieldRef = FieldReference.getMemberRef(fieldID).asFieldReference();
+    return fieldRef.getResolvedField();
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/PessimisticStateTransfers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/PessimisticStateTransfers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/PessimisticStateTransfers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/PessimisticStateTransfers.java	2014-04-03 17:43:46.973683534 -0400
@@ -0,0 +1,173 @@
+package org.jikesrvm.octet;
+
+import org.jikesrvm.runtime.Magic;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.Word;
+
+/** Octet: implementation of pessimistic barriers, which always use a CAS or fence instead of Octet's optimistic approach */
+@Uninterruptible
+public final class PessimisticStateTransfers extends OctetState {
+
+  /** Pessimistic read barrier that always uses both a CAS and fence. */
+  @Inline
+  public static final void readWithFence(Address addr) {
+    Word oldMetadata = lockMetadata(addr);
+    Word newMetadata = getNewReadState(oldMetadata);
+    /* Client analysis-specific cross-thread dependence handling would go here */
+    unlockAndUpdateMetadata(addr, newMetadata);
+  }
+  
+  /** Pessimistic write barrier that always uses both a CAS and fence. */
+  @Inline
+  public static final void writeWithFence(Address addr) {
+    Word oldMetadata = lockMetadata(addr);
+    Word newMetadata = getNewWriteState(oldMetadata);
+    /* Client analysis-specific cross-thread dependence handling would go here */
+    unlockAndUpdateMetadata(addr, newMetadata);
+  }
+
+  /** Pessimistic read barrier that always uses a CAS but no fence. */
+  @Inline
+  public static final void readWithoutFence(Address addr) {
+    Word oldMetadata = addr.prepareWord();
+    Word newMetadata = getNewReadState(oldMetadata);
+    /* Client analysis-specific cross-thread dependence handling would go here */
+    if (!addr.attempt(oldMetadata, newMetadata)) {
+      // Retry out-of-line
+      readWithoutFenceSlowPath(addr);
+    }
+  }
+
+  /** Pessimistic write barrier that always uses a CAS but no fence. */
+  @Inline
+  public static final void writeWithoutFence(Address addr) {
+    Word oldMetadata = addr.prepareWord();
+    Word newMetadata = getNewWriteState(oldMetadata);
+    /* Client analysis-specific cross-thread dependence handling would go here */
+    if (!addr.attempt(oldMetadata, newMetadata)) {
+      // Retry out-of-line
+      writeWithoutFenceSlowPath(addr);
+    }
+  }
+
+  /** Pessimistic read barrier that uses no synchronization (for performance testing). */
+  @Inline
+  public static final void readWithoutSync(Address addr) {
+    Word oldMetadata = lockMetadataWithoutSync(addr);
+    Word newMetadata = getNewReadState(oldMetadata);
+    /* Client analysis-specific cross-thread dependence handling would go here */
+    addr.store(newMetadata);
+  }
+
+  /** Pessimistic write barrier that uses no synchronization (for performance testing). */
+  @Inline
+  public static final void writeWithoutSync(Address addr) {
+    Word oldMetadata = lockMetadataWithoutSync(addr);
+    Word newMetadata = getNewWriteState(oldMetadata);
+    /* Client analysis-specific cross-thread dependence handling would go here */
+    addr.store(newMetadata);
+  }
+
+  /** Compute the new state for a read (based on WrEx and RdSh states only). */
+  @Inline
+  static final Word getNewReadState(Word oldMetadata) {
+    if (!isWriteExclForCurrentThread(oldMetadata) &&
+        !isReadSharedPossiblyUnfenced(oldMetadata)) {
+      return MAX_READ_SHARED; // doesn't really matter which read-shared value we use
+    }
+    return oldMetadata;
+  }
+
+  /** Compute the new state for a write (based on WrEx and RdSh states only). */
+  @Inline
+  static final Word getNewWriteState(Word oldMetadata) {
+    if (!isWriteExclForCurrentThread(oldMetadata)) {
+      return getExclusive(WRITE_EXCL);
+    }
+    return oldMetadata;
+  }
+
+  @Inline
+  static final Word lockMetadata(Address addr) {
+    Word oldMetadata = addr.prepareWord();
+    //check(oldMetadata);
+    // Use intermediate state as locked state
+    if (oldMetadata.EQ(INTERMEDIATE) ||
+        !addr.attempt(oldMetadata, INTERMEDIATE)) { 
+      return lockMetadataSlowPath(addr);
+    }
+    return oldMetadata;
+  }
+
+  /** If first attempt to lock fails, we call this out-of-line method
+      to do the looping behavior. */
+  @NoInline
+  static final Word lockMetadataSlowPath(Address addr) {
+    Word oldMetadata;
+    do {
+      Magic.pause(); // If we are here, a CAS just failed 
+      oldMetadata = addr.prepareWord();
+      check(oldMetadata);
+    } while (oldMetadata.EQ(INTERMEDIATE) ||
+             !addr.attempt(oldMetadata, INTERMEDIATE));
+    return oldMetadata;
+  }
+
+  /** Lock the metadata incorrectly -- without using synchronization (for performance testing). */
+  @Inline
+  static final Word lockMetadataWithoutSync(Address addr) {
+    Word oldMetadata = addr.loadWord();
+    //check(oldMetadata);
+    // Use intermediate state as locked state
+    if (oldMetadata.EQ(INTERMEDIATE)) {
+      return lockMetadataWithoutSyncSlowPath(addr);
+    }
+    addr.store(INTERMEDIATE);
+    return oldMetadata;
+  }
+
+  /** If first attempt to (incorrectly) lock fails, we call this out-of-line method to do the looping behavior. */
+  @NoInline
+  static final Word lockMetadataWithoutSyncSlowPath(Address addr) {
+    Word oldMetadata;
+    do {
+      oldMetadata = addr.loadWord();
+      check(oldMetadata);
+    } while (oldMetadata.EQ(INTERMEDIATE));
+    addr.store(INTERMEDIATE);
+    return oldMetadata;
+  }
+
+  /** Unlock and update the metadata, including an mfence. */
+  @Inline
+  static final void unlockAndUpdateMetadata(Address addr, Word newMetadata) {
+    Magic.fence();
+    //if (VM.VerifyAssertions) { VM._assert(addr.loadWord().EQ(INTERMEDIATE)); }
+    addr.store(newMetadata);
+  }
+
+  @NoInline
+  static final void readWithoutFenceSlowPath(Address addr) {
+    Word oldMetadata, newMetadata;
+    do {
+      Magic.pause(); // If we are here, a CAS just failed
+      oldMetadata = addr.prepareWord();
+      newMetadata = getNewReadState(oldMetadata);
+      /* Client analysis-specific cross-thread dependence handling would go here */
+    } while (!addr.attempt(oldMetadata, newMetadata));
+  }
+
+  @NoInline
+  static final void writeWithoutFenceSlowPath(Address addr) {
+    Word oldMetadata, newMetadata;
+    do {
+      Magic.pause(); // If we are here, a CAS just failed
+      oldMetadata = addr.prepareWord();
+      newMetadata = getNewWriteState(oldMetadata);
+      /* Client analysis-specific cross-thread dependence handling would go here */
+    } while (!addr.attempt(oldMetadata, newMetadata));
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Site.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Site.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Site.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Site.java	2014-04-03 17:43:46.972683530 -0400
@@ -0,0 +1,289 @@
+package org.jikesrvm.octet;
+
+import java.io.PrintStream;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.compilers.opt.inlining.InlineSequence;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.util.HashMapRVM;
+import org.jikesrvm.util.HashSetRVM;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Uninterruptible;
+
+/** Octet: represents a static program location */
+@Uninterruptible
+public final class Site {
+
+  // The key information for a site
+  private final Atom className;
+  private final Atom methodName;
+  private final Atom methodDesc;
+  private final int bci;
+  private final Site caller; // caller call site (for inlined call sites)
+
+  // Extra information
+  private final int line;
+
+  // global variables
+  // Octet: LATER: avoid hardcoding this value and making it public
+  public static final int MAX_SITES = 1 << 18; // 256K sites
+  private static final Site[] sites; // this is the global we'll synchronize on
+  private static final HashMapRVM<Site, Integer> siteMap; // only needed if sites are supposed to be unique
+  private static int numSites;
+  static HashSetRVM<Site> raceSites; // datarace static sites given by Chord
+
+  static {
+    if (Octet.getClientAnalysis().needsSites()) {
+      sites = new Site[MAX_SITES];
+      if (Octet.getClientAnalysis().needsUniqueSites()) {
+        siteMap = new HashMapRVM<Site, Integer>(MAX_SITES);
+      } else {
+        siteMap = null;
+      }
+    } else {
+      sites = null;
+      siteMap = null;
+    }
+    raceSites = null; // Don't allocate now in the bootimage, allocate it only after the VM is running
+  }
+
+  @Interruptible
+  public static int getSite(Instruction inst) {
+    return getSite(inst.position, inst.bcIndex);
+  }
+
+  @Interruptible
+  static int getSite(InlineSequence position, int bci) {
+    Site caller = null;
+    if (position.getCaller() != null) {
+      caller = Site.lookupSite(Site.getSite(position.getCaller(), position.bcIndex));
+    }
+    return getSite(position.getMethod(), bci, caller);
+  }
+  
+  @Interruptible
+  public static int getSite(RVMMethod method, int bci, Site caller) {
+    // Site will include some uninstrumented methods that still have application context (like String methods).
+    // Velodrome: Context: APP context now means TRANS/NONTRANS
+    // This assertion won't work always, especially when a library calls gets inlined into an application method
+    // This for now happens with lusearch9, SimpleMapCache.get() gets inlined into TermInfosReader.get(), and 
+    // LinkedHashMap.get() gets inlined into SimpleMapCache.get(). But the RVMMethod corresponding to LinkedHashMap.get()
+    // is of VM_CONTEXT.
+    if (VM.VerifyAssertions && caller == null) { VM._assert(method.getStaticContext() == Context.TRANS_CONTEXT ||
+                                                            method.getStaticContext() == Context.NONTRANS_CONTEXT); }
+    //if (VM.VerifyAssertions) { VM._assert(Octet.shouldInstrumentMethod(method)); }
+
+    // This type cast should be okay 
+    int line = ((NormalMethod)method).getLineNumberForBCIndex(bci);
+    return getSite(method.getDeclaringClass().getDescriptor(), method.getName(), method.getDescriptor(), bci, line, caller);
+  }
+
+  @Interruptible
+  public static int getSite(Atom classDesc, Atom methodDesc, Atom signature, int bci, int line, Site caller) {
+    Site site = new Site(classDesc, methodDesc, signature, bci, line, caller);
+    return registerSite(site);
+  }
+  
+  @Interruptible
+  public static void registerRaceSite(Atom className, Atom methodName, Atom methodDesc, int bci, int line, Site caller) {
+    Site site = new Site(className, methodName, methodDesc, bci, line, caller);
+    registerRace(site);
+  }
+  
+  @Interruptible
+  public static void registerRace(Site site) {      
+    if (raceSites != null) {           
+      raceSites.add(site);            
+    }
+  }
+  
+  @Interruptible
+  public static boolean isRegisteredRacySite(Atom className, Atom methodName, Atom methodDesc, int bci, int line, Site caller) {      
+    Site site = new Site(className, methodName, methodDesc, bci, line, caller);
+    if (VM.VerifyAssertions) { VM._assert(raceSites != null); }
+    return raceSites.contains(site);            
+  }
+
+  @Interruptible
+  private static int registerSite(Site site) {
+    if (VM.VerifyAssertions) { VM._assert(sites != null); }
+    synchronized (sites) {
+      Integer intObj = null;
+      if (siteMap != null) {
+        intObj = siteMap.get(site);
+      }
+      int index;
+      if (intObj == null) {
+        if (VM.VerifyAssertions) {
+          if (numSites == MAX_SITES) { VM.sysFail("Octet site array is full"); }
+        }
+        index = numSites++;
+        if (siteMap != null) {
+          siteMap.put(site, index);
+        }
+        sites[index] = site;
+        Octet.getClientAnalysis().handleNewSite(site);
+      } else {
+        index = intObj.intValue();
+      }
+      return index;
+    }
+  }
+  
+  private Site(Atom className, Atom methodName, Atom methodDesc, int bci, int line, Site caller) {
+    this.className = className;
+    this.methodName = methodName;
+    this.methodDesc = methodDesc;
+    this.bci = bci;
+    this.line = line;
+    this.caller = caller;
+  }
+  
+  public static final Site lookupSite(int siteID) {
+    if (VM.VerifyAssertions) { VM._assert(Octet.getClientAnalysis().needsSites()); }
+    return sites[siteID];
+  }
+  
+  public Site getCaller() {
+    return caller;
+  }
+  
+  public int getLine() {
+    return line;
+  }
+
+  /** Check whether a method and bci site match this site -- not include a possible caller. */
+  public boolean matchesExcludingCaller(RVMMethod method, int bci) {
+    return this.className == method.getDeclaringClass().getDescriptor() &&
+           this.methodName == method.getName() &&
+           this.methodDesc == method.getDescriptor() &&
+           this.bci == bci;
+  }
+
+  // equals and hashCode are really important -- their absence created a subtle bug!
+  // Note that we are not using line in equals, since it is not part of the unique definition of a site.
+  @Interruptible
+  @Override
+  public boolean equals(Object o) {
+    Site otherSite = (Site)o;
+    return this.className == otherSite.className &&
+           this.methodName == otherSite.methodName &&
+           this.methodDesc == otherSite.methodDesc &&
+           this.bci == otherSite.bci &&
+           (this.caller == otherSite.caller ||
+            (this.caller != null && otherSite.caller != null && this.caller.equals(otherSite.caller)));
+  }
+  
+  @Interruptible
+  @Override
+  public int hashCode() {
+    return className.hashCode() + methodName.hashCode() + methodDesc.hashCode() + bci +
+           (caller == null ? 0 : caller.hashCode());
+  }
+  
+  @Interruptible
+  @Override
+  public String toString() {
+    String s = className + "." + methodName + " " + methodDesc + ":" + line + "(" + bci + ")";
+    if (caller != null) {
+        s += " called by " + caller;
+    }
+    return s;
+  }
+
+  /** Assumes siteMap != null, i.e., unique sites */
+  @Interruptible
+  public static void printAllSitesMultipleLines(PrintStream ps) {
+    synchronized (sites) {
+      for (Site site : sites) {
+        if (site == null) {
+          break;
+        }
+        ps.println(site.className);
+        ps.println(site.methodName);
+        ps.println(site.methodDesc);
+        ps.println(site.bci);
+        ps.println(site.line);
+        if (VM.VerifyAssertions) { VM._assert(siteMap != null); }
+        int callerID = -1;
+        if (site.caller != null) {
+          callerID = siteMap.get(site.caller);
+        }
+        ps.println(callerID); // print the caller site ID (-1 if none)
+      }
+    }
+  }
+  
+  /** Print unique site information, one item per line.  Doesn't enforce atomicity of printing since it uses
+      separate sysWrite() calls. */
+  /*
+  public void sysWriteMultipleLines() {
+    VM.sysWriteln(className);
+    VM.sysWriteln(methodName);
+    VM.sysWriteln(methodDesc);
+    VM.sysWriteln(bci);
+    VM.sysWriteln(line);
+    if (caller != null) {
+      ??
+    }
+  }
+  */
+
+  /** Pretty-print the site, including the line number.  Doesn't actually enforce atomicity of printing since it
+      uses separate sysWrite() calls. */
+  public void sysWrite() {
+    VM.sysWrite(className);
+    VM.sysWrite(".");
+    VM.sysWrite(methodName);
+    VM.sysWrite(" ");
+    VM.sysWrite(methodDesc);
+    VM.sysWrite(":");
+    VM.sysWrite(line);
+    VM.sysWrite("(");
+    VM.sysWrite(bci);
+    VM.sysWrite(")");
+    if (caller != null) {
+      VM.sysWrite(" called by ");
+      caller.sysWrite();
+    }
+  }
+  
+  public void sysWriteln() {
+    sysWrite();
+    VM.sysWriteln();
+  }
+  
+  @Interruptible
+  public static void clearSites() {
+    for (int i = 0; i < numSites; i++) {
+      sites[i] = null;
+    }
+    if (siteMap != null) {
+      siteMap.removeAll();
+    }
+    //siteMap = new HashMapRVM<Site, Integer>(MAX_SITES);
+    numSites = 0;
+    checkSites(false);
+    if (VM.VerifyAssertions) { VM._assert(siteMap == null || siteMap.size() == 0); }
+  }
+  
+  @Interruptible
+  public static void checkSites(boolean print) {
+    if (print || VM.VerifyAssertions) {
+      for (int siteID = 0; siteID < numSites; siteID++) {
+        Site site = lookupSite(siteID);
+        if (print) {
+          VM.sysWrite("Site ", siteID, ": ");
+          site.sysWrite();
+          VM.sysWriteln();
+        }
+        if (VM.VerifyAssertions) { VM._assert(siteMap == null || siteMap.get(site) == siteID); }
+      }
+      if (VM.VerifyAssertions) { VM._assert(siteMap == null || siteMap.size() == numSites); }
+    }
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/StateTransfers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/StateTransfers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/StateTransfers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/StateTransfers.java	2014-04-03 17:43:46.974683538 -0400
@@ -0,0 +1,370 @@
+package org.jikesrvm.octet;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.objectmodel.ObjectModel;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.runtime.Time;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+
+/** Octet: fast and slow paths */
+@Uninterruptible
+public class StateTransfers extends OctetState {
+
+  @Inline
+  @Entrypoint
+  public static boolean read(Address baseAddr, Offset octetOffset, int fieldOrIndexInfo, int siteID) {
+    Stats.fastPathsEntered.inc(siteID);
+
+    // A nice guarantee.
+    if (VM.VerifyAssertions) { VM._assert(RVMThread.getCurrentThread().isOctetThread()); }
+
+    Word metadata = baseAddr.prepareWord(octetOffset);
+    
+    // Octet: LATER: metadata check can slow down the opt compiler
+    check(metadata);
+
+    // Fast path: state must be WrEx or RdEx for current thread, or RdSh
+    // First check to see if the state supports this thread's read
+    // Octet: LATER: It might not be worth it to do this slightly more complex check for "read or write excl" rather than just checking for "write excl"
+    // (since the latter shouldn't require allocating a register).
+    if (!isExclForCurrentThread(metadata)) {
+      // commenting out stats because even though they're dead code with assertions turned off, they'll bloat the IR when they get inlined
+      // now check for RdSh
+      if (!isReadSharedAndFenced(metadata)) {
+        // neither quick test succeeded
+        readSlowPath(baseAddr, octetOffset, metadata, fieldOrIndexInfo, siteID);
+        return false;
+      } else {
+        Stats.RdSh_RdSh_NoFence.inc();
+      }
+    } else if (Octet.getConfig().stats()) {
+      if (isWriteExclForCurrentThread(metadata)) {
+        Stats.WrEx_WrEx_Same.inc();
+      } else {
+        Stats.RdEx_RdEx.inc();
+      }
+    }
+    return true;
+  }
+
+  @Inline
+  @Entrypoint
+  public static boolean write(Address baseAddr, Offset octetOffset, int fieldOrIndexInfo, int siteID) {
+    Stats.fastPathsEntered.inc(siteID);
+
+    // A nice guarantee.
+    if (VM.VerifyAssertions) { VM._assert(RVMThread.getCurrentThread().isOctetThread()); }
+
+    Word metadata = baseAddr.prepareWord(octetOffset);
+    
+    // Octet: LATER: metadata check can slow down the opt compiler
+    check(metadata);
+    
+    // fast path: state must be WrEx with current thread
+    if (!isWriteExclForCurrentThread(metadata)) {
+      // commenting out stats because even though they're dead code with assertions turned off, they'll bloat the IR when they get inlined
+      writeSlowPath(baseAddr, octetOffset, metadata, fieldOrIndexInfo, siteID);
+      return false;
+    } else {
+      Stats.WrEx_WrEx_Same.inc();
+    }
+    return true;
+  }
+
+  @NoInline
+  static final void readSlowPath(Address baseAddr, Offset octetOffset, Word oldMetadata, int fieldOrIndexInfo, int siteID) {
+    boolean switchSlowPath = Octet.getClientAnalysis().alternateReadSlowPath(baseAddr, octetOffset, oldMetadata, fieldOrIndexInfo, siteID);
+    if (!switchSlowPath) {
+      slowPath(true, baseAddr, octetOffset, oldMetadata, fieldOrIndexInfo, siteID);
+    }
+  }
+
+  @NoInline
+  static final void writeSlowPath(Address baseAddr, Offset octetOffset, Word oldMetadata, int fieldOrIndexInfo, int siteID) {
+    boolean switchSlowPath = Octet.getClientAnalysis().alternateWriteSlowPath(baseAddr, octetOffset, oldMetadata, fieldOrIndexInfo, siteID);
+    if (!switchSlowPath) {
+      slowPath(false, baseAddr, octetOffset, oldMetadata, fieldOrIndexInfo, siteID);
+    }
+  }
+
+  @Inline
+  public static final void slowPath(boolean isRead, Address baseAddr, Offset octetOffset, Word oldMetadata, int fieldOrIndexInfo, int siteID) {
+    if (Octet.getConfig().noSlowPath()) {
+      return;
+    }
+    Stats.slowPathsEntered.inc(siteID);
+    long startTime = (Octet.getConfig().stats() || VM.VerifyAssertions) ? Time.nanoTime() : 0;
+
+    // Allow slow path to change the state even for non-Octet threads
+    // Octet: TODO: trying out this change
+    boolean exitSlowPath = false; //!RVMThread.getCurrentThread().isOctetThread();
+    if (!exitSlowPath) {
+      exitSlowPath = Octet.getClientAnalysis().alternateSlowPath(isRead, baseAddr, octetOffset, oldMetadata, fieldOrIndexInfo, siteID);
+    }
+    if (exitSlowPath) {
+      Stats.slowPathsExitedEarly.inc(siteID);
+      return;
+    }
+
+    // Figure out if big objects are causing a lot of state transitions
+    if (Octet.getConfig().stats()) {
+      // Determine whether we're dealing with an object or a static by comparing with the JTOC pointer
+      if (baseAddr.NE(Magic.getTocPointer())) {
+        int bytesUsed = ObjectModel.bytesUsed(baseAddr.toObjectReference().toObject());
+        Stats.logSlowPathObjectSize.incBin(bytesUsed);
+      }
+    }
+    
+    // we're here, so we've got to do a CAS or an invalidation
+    // (unless some other thread happens to change the state to RdSh in the meantime)
+    int iter;
+    for (iter = 0; ; iter++) {
+      
+      if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(false)) {
+        boolean exitLoop = Octet.getClientAnalysis().handleEventsInSlowPathLoop(isRead, baseAddr, octetOffset, oldMetadata, fieldOrIndexInfo, siteID);
+        if (exitLoop) {
+          break;
+        }
+      }
+      // check for the uninitialized state
+      if (oldMetadata.EQ(MIN_READ_SHARED)) {
+        Word newMetadata = getInitial();
+        boolean result = baseAddr.attempt(oldMetadata, newMetadata, octetOffset);
+        if (result) {
+          Stats.Uninit_Init.inc();
+          break;
+        }
+        // otherwise, we'll need to re-load the metadata (below)
+
+      // for reads: check for a read-shared that this thread isn't up-to-date on
+      } else if (isRead && isReadSharedPossiblyUnfenced(oldMetadata)) {
+        // It should be unfenced because the fast path failed
+        if (VM.VerifyAssertions) { VM._assert(isReadSharedUnfenced(oldMetadata)); }
+        RVMThread.getCurrentThread().octetReadSharedCounter = oldMetadata;
+        // A load fence here is needed to ensure happens-before between this point
+        // and the last RdEx->RdSh transition on this object.
+        Magic.readCeiling();
+        Stats.RdSh_RdSh_Fence.inc();
+        if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+          // Let the client analysis handle the RdSh fence transition
+          Octet.getClientAnalysis().handleRdShFenceTransition(oldMetadata, siteID);
+        }
+        break;
+
+      // for reads: try upgrading from RdEx->RdSh
+      } else if (isRead && getState(oldMetadata).EQ(READ_EXCL)) {
+        if (VM.VerifyAssertions) { VM._assert(!isReadSharedPossiblyUnfenced(oldMetadata)); }
+
+        // Octet: LATER: We can actually transition RdEx->RdEx if the thread has died.
+        // For now, let's just count how often that happens.
+        // It might not be worth doing because it might complicate client analyses.
+        RVMThread oldThread = getThreadFromExclusive(oldMetadata); // Points to the last thread that read the object in exclusive state
+        if (oldThread.getExecStatus() == RVMThread.TERMINATED) {
+          //newMetadata = getExclusive(READ_EXCL);
+          //boolean result = addr.attempt(oldMetadata, newMetadata, offset);
+          //if (result) {
+            Stats.rdExToRdShButOldThreadDied.inc();
+            //break;
+          //}
+        }
+        
+        // RdEx->RdSh
+        // First, put the global RdSh counter into a special locked state
+        boolean result = false;
+        Word oldValue = lockReadSharedCounter();
+        // This thread currently has exclusive access to the lock
+        Word newMetadata = oldValue.minus(READ_SHARED_DEC);
+        check(newMetadata);
+        
+        // This CAS may fail
+        result = baseAddr.attempt(oldMetadata, newMetadata, octetOffset);
+        if (result) {
+          // We can update this thread's read shared counter, i.e., a fence transition is not necessary
+          // for this object on this thread
+          RVMThread.getCurrentThread().octetReadSharedCounter = newMetadata;
+          if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+            Octet.getClientAnalysis().handleBeforeUpdatingGlobalRdShCounter();
+          }
+          // Octet: TODO: This assertion should not fail -- but apparently it's been failing at some point?
+          if(VM.VerifyAssertions) {
+            VM._assert(globalReadSharedCounter == READ_SHARED_COUNTER_LOCKED);
+          }
+          Magic.writeFloor(); // All pending stores should complete before executing this fence
+          // Reset the lock variable, no need to use a CAS 
+          // Word newMetadata = decReadSharedCounter();
+          globalReadSharedCounter = newMetadata;
+          // Now that we're out of the critical section, let the client analysis handle the transition
+          Stats.RdEx_RdSh.inc();
+          if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+            Octet.getClientAnalysis().handleRdExToRdShUpgradingTransition(oldThread, newMetadata, siteID);
+          }
+          break;
+        } else {
+          // Reset the lock since the CAS failed
+          globalReadSharedCounter = oldValue;
+        }
+        
+      // Writes: Try for an upgrading transition from RdEx to WrEx for the same thread.
+      } else if (!isRead && isExclForCurrentThread(oldMetadata)) {
+        if (VM.VerifyAssertions) { VM._assert(getState(oldMetadata).EQ(READ_EXCL)); }
+        Word newMetadata = getExclusive(WRITE_EXCL);
+        check(newMetadata);
+        
+        boolean result = baseAddr.attempt(oldMetadata, newMetadata, octetOffset);
+        if (result) {
+          if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+            Octet.getClientAnalysis().handleRdExToWrExUpgradingTransition(newMetadata, siteID);
+          }
+          Stats.RdEx_WrEx_Same.inc();
+          break;
+        }
+
+      // Conflicting transition
+      } else {
+        boolean result = handleIntermediateState(baseAddr, octetOffset, oldMetadata, isRead ? READ_EXCL : WRITE_EXCL, fieldOrIndexInfo, siteID);
+        if (result) {
+          if (isRead) {
+            Stats.WrEx_RdEx.inc();
+          } else if (isReadSharedPossiblyUnfenced(oldMetadata)) {
+            Stats.RdSh_WrEx.inc();
+          } else if (getState(oldMetadata).EQ(WRITE_EXCL)) {
+            Stats.WrEx_WrEx_Diff.inc();
+          } else {
+            if (VM.VerifyAssertions) { VM._assert(getState(oldMetadata).EQ(READ_EXCL)); }
+            Stats.RdEx_WrEx_Diff.inc();
+          }
+          break;
+        }
+      }
+      // If any of the above failed, we need to go back into the loop because the object state could change back to some read state
+
+      if (VM.VerifyAssertions) {
+        startTime = checkIfStuck(startTime, oldMetadata);
+      }
+
+      // Supports performance-testing configurations
+      if (Octet.getConfig().noWaitForCommunication() || Octet.getConfig().noWaitOnIntermediateState()) {
+        break;
+      }
+      
+      // Octet: LATER: consider this policy of when and whether to yield
+      if (iter > 3) {
+        if (Octet.getConfig().doCommunication()) {
+          Communication.blockCommunicationRequests(true);
+        }
+        RVMThread.yieldNoHandshake();
+        if (Octet.getConfig().doCommunication()) {
+          Communication.unblockCommunicationRequests();
+        }
+        // Octet: LATER: implement waiting instead of just yielding?
+      } else {
+        // decrease performance hit from spin-wait loops
+        Magic.pause();
+        
+        // check for communication requests in case we're in this loop for a while (might actually be necessary to not get stuck)
+        if (Octet.getConfig().doCommunication()) {
+          Communication.checkForCommunicationRequests(false);
+        }
+      }
+      
+      // re-load the metadata in case it changed
+      oldMetadata = baseAddr.prepareWord(octetOffset);
+      check(oldMetadata);
+      // And check for read shared (only an already-fenced one here) in case we don't actually need to change the state.
+      if (isRead && isReadSharedAndFenced(oldMetadata)) {
+        // It's actually possible to read a fenced RdSh here.
+        // It seems pretty unlikely because it means that a lot has to happen on this thread (multiple barriers) between
+        // when another thread updates the gRdShCtr and changes the object from RdEx to RdSh.
+        // But a client analysis (like RR) that does a lot of work when incrementing the gRdShCtr, makes this case more likely.
+        Stats.RdSh_RdSh_NoFence.inc();
+        break;
+      }
+    } // end of loop
+    Stats.logSlowPathIter.incBin(iter);
+    Stats.logTimeSlowPath.incTime(startTime);
+  }
+  
+  /** Handle an object that we'd like to put in the intermediate state; it might already be in the intermediate state.
+      Return true iff we successfully put the object in the newState state and are thus ready to access the object. */
+  @Inline
+  static final boolean handleIntermediateState(Address baseAddr, Offset offset, Word oldMetadata, Word newState, int fieldOffset, int siteID) {
+    
+    // is it already in the intermediate state
+    if (getState(oldMetadata).EQ(INTERMEDIATE)) {
+      /* Octet: LATER: implement?
+      // it's already in the intermediate state, so let's try to wait for it
+      if (VM.VerifyAssertions) { verify inter-with-waiter is superset of intermediate; }
+      Word metadata = oldMetadata.or(INTERMEDIATE_WITH_WAITER);
+      */
+    } else {
+      // well, it's in the right state, so we'll try to steal by putting it in the intermediate state
+      Word intermediateMetadata = getIntermediate();
+      check(intermediateMetadata);
+      boolean result = baseAddr.attempt(oldMetadata, intermediateMetadata, offset);
+      if (result) {
+        // Don't actually perform communication for a non-Octet thread.  Just allow the state to be changed.
+        // Octet: TODO: trying out this change
+        if (Octet.getConfig().doCommunication() &&
+            RVMThread.getCurrentThread().isOctetThread()) {
+          Stats.blockCommReceiveResponses.inc();
+          if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+            Octet.getClientAnalysis().handleEventBeforeCommunication(baseAddr, offset, oldMetadata, newState, fieldOffset, siteID);
+          }
+          Communication.blockCommunicationRequests(false);
+          Communication.communicate(baseAddr, offset, oldMetadata, newState, fieldOffset, siteID);
+          Communication.unblockCommunicationRequests();
+          if (Octet.getClientAnalysis().shouldExecuteSlowPathHooks(true)) {
+            Octet.getClientAnalysis().handleEventAfterCommunication(baseAddr, offset, oldMetadata);
+          }
+        }
+        // Octet: LATER: CAS is probably overkill
+        Word newMetadata = getExclusive(newState);
+        check(newMetadata);
+        result = baseAddr.attempt(intermediateMetadata, newMetadata, offset);
+        // Octet: LATER: why is/was this CAS failing sometimes?
+        if (VM.VerifyAssertions) { VM._assert(result); }
+        Stats.conflictingTransitions.inc(siteID);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** For debugging purposes */
+  @NoInline
+  static final long checkIfStuck(long startTime, Word oldMetadata) {
+    if (Stats.nsElapsed(startTime) >= 5000L*1000*1000) {
+      RVMThread.debugLock.lockNoHandshake();
+      VM.sysWriteln("Got stuck trying to change to intermediate state");
+      RVMThread.dumpStack();
+      if (VM.VerifyAssertions) { VM._assert(getState(oldMetadata).EQ(INTERMEDIATE)); }
+      RVMThread remoteThread = getThreadFromIntermediate(oldMetadata);
+      VM.sysWriteln("Remote thread slot = ", remoteThread.threadSlot);
+      Stats.tryToPrintStack(remoteThread.framePointer);
+      
+      //RVMThread.dumpVirtualMachine();
+      for (RVMThread otherThread : RVMThread.threadBySlot) {
+        if (Communication.isValidOtherThread(otherThread, RVMThread.getCurrentThread())) {
+          VM.sysWriteln("Trying to print thread ", otherThread.threadSlot);
+          Stats.tryToPrintStack(otherThread.framePointer);
+        }
+      }
+      VM.sysWriteln();
+      VM.sysWriteln();
+      VM.sysWriteln();
+      RVMThread.debugLock.unlock();
+
+      VM.sysFail("Got stuck");
+      //return Time.nanoTime();
+    }
+    return startTime;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Stats.java workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Stats.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/octet/Stats.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/octet/Stats.java	2014-04-03 17:43:46.970683523 -0400
@@ -0,0 +1,548 @@
+package org.jikesrvm.octet;
+
+import java.text.DecimalFormat;
+import java.util.Arrays;
+import java.util.Comparator;
+
+import org.jikesrvm.Callbacks;
+import org.jikesrvm.Callbacks.ExitMonitor;
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.runtime.Time;
+import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.util.LinkedListRVM;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
+import org.vmmagic.unboxed.Address;
+
+/**
+ * Octet: statistics and debugging.
+ * 
+ * In this file stats and counters are used interchangeably to refer to the same
+ * idea. E.g., static stats means stats that are collected with a static counter.
+ * 
+ * @author Mike Bond
+ * @author Meisam
+ * 
+ */
+@Uninterruptible
+public class Stats implements Constants {
+
+  private static final LinkedListRVM<Stat> all = new LinkedListRVM<Stat>();
+
+  // measuring the communication algorithm:
+  static final UnsyncHistogram logTimeCommunicateRequests = new UnsyncHistogram("logTimeCommunicateRequests", true, 1L<<32);
+  static final UnsyncHistogram logTimeSlowPath = new UnsyncHistogram("logTimeSlowPath", true, 1L<<32);
+  static final UnsyncHistogram threadsWaitedFor = new UnsyncHistogram("threadsWaitedFor", false, 128);
+  static final UnsyncHistogram logWaitIter = new UnsyncHistogram("waitIter", true, 1L<<16);
+  static final UnsyncHistogram logSlowPathIter = new UnsyncHistogram("slowPathIter", true, 1L<<32);
+  static final UnsyncHistogram logSlowPathObjectSize = new UnsyncHistogram("logSlowPathObjectSize", true, 1L<<32);
+
+  static final ThreadSafeCounter readSharedCounterAvoidsSendRequestCall = new ThreadSafeCounter("readSharedCounterAvoidsSendRequestCall", true);
+  static final ThreadSafeCounter readSharedCounterAvoidsActualSendRequest = new ThreadSafeCounter("readSharedCounterAvoidsActualSendRequest", true);
+  static final ThreadSafeCounter rdExToRdShButOldThreadDied = new ThreadSafeCounter("rdExToRdShButOldThreadDied", true);
+
+  static final PerSiteCounter slowPathsEntered       = new PerSiteCounter("slowPathsEntered");
+  static final PerSiteCounter slowPathsExitedEarly   = new PerSiteCounter("slowPathsExitedEarly");
+  static final PerSiteCounter fastPathsEntered       = new PerSiteCounter("fastPathsEntered");
+  static final PerSiteCounter conflictingTransitions = new PerSiteCounter("conflictingTransitions");
+
+  public static final ThreadSafeCounter Alloc      = new ThreadSafeCounter("Alloc", false);
+  static final ThreadSafeCounter Uninit_Init       = new ThreadSafeCounter("Uninit_Init", false);
+  static final ThreadSafeCounter WrEx_WrEx_Same    = new ThreadSafeCounter("WrEx_WrEx_Same", false);
+  static final ThreadSafeCounter WrEx_WrEx_Diff    = new ThreadSafeCounter("WrEx_WrEx_Diff", false);
+  static final ThreadSafeCounter WrEx_RdEx         = new ThreadSafeCounter("WrEx_RdEx", false);
+  static final ThreadSafeCounter RdEx_WrEx_Same    = new ThreadSafeCounter("RdEx_WrEx_Same", false);
+  static final ThreadSafeCounter RdEx_WrEx_Diff    = new ThreadSafeCounter("RdEx_WrEx_Diff", false);
+  static final ThreadSafeCounter RdEx_RdEx         = new ThreadSafeCounter("RdEx_RdEx", false);
+  static final ThreadSafeCounter RdEx_RdSh         = new ThreadSafeCounter("RdEx_RdSh", false);
+  static final ThreadSafeCounter RdSh_WrEx         = new ThreadSafeCounter("RdSh_WrEx", false);
+  static final ThreadSafeCounter RdSh_RdSh_NoFence = new ThreadSafeCounter("RdSh_RdSh_NoFence", false);
+  static final ThreadSafeCounter RdSh_RdSh_Fence   = new ThreadSafeCounter("RdSh_RdSh_Fence", false);
+
+  static final ThreadSafeSumCounter sameState      = new ThreadSafeSumCounter("sameState", Alloc, Uninit_Init, WrEx_WrEx_Same, RdEx_RdEx, RdSh_RdSh_NoFence);
+  static final ThreadSafeSumCounter upgrading      = new ThreadSafeSumCounter("upgrading", RdEx_WrEx_Same, RdEx_RdSh, RdSh_RdSh_Fence);
+  static final ThreadSafeSumCounter conflicting    = new ThreadSafeSumCounter("conflicting", WrEx_WrEx_Diff, WrEx_RdEx, RdEx_WrEx_Diff, RdSh_WrEx);
+  static final ThreadSafeSumCounter total          = new ThreadSafeSumCounter("total", Alloc, Uninit_Init, WrEx_WrEx_Same, RdEx_RdEx, RdSh_RdSh_NoFence, RdEx_WrEx_Same, RdEx_RdSh, RdSh_RdSh_Fence, WrEx_WrEx_Diff, WrEx_RdEx, RdEx_WrEx_Diff, RdSh_WrEx);
+
+  // ratio counters
+  static final ThreadSafeRatioCounter Alloc_Ratio             = new ThreadSafeRatioCounter("Alloc_Ratio", Alloc, total);
+  static final ThreadSafeRatioCounter Uninit_Init_Ratio       = new ThreadSafeRatioCounter("Uninit_Init_Ratio", Uninit_Init, total);
+  static final ThreadSafeRatioCounter WrEx_WrEx_Same_Ratio    = new ThreadSafeRatioCounter("WrEx_WrEx_Same_Ratio", WrEx_WrEx_Same, total);
+  static final ThreadSafeRatioCounter WrEx_WrEx_Diff_Ratio    = new ThreadSafeRatioCounter("WrEx_WrEx_Diff_Ratio", WrEx_WrEx_Diff, total);
+  static final ThreadSafeRatioCounter WrEx_RdEx_Ratio         = new ThreadSafeRatioCounter("WrEx_RdEx_Ratio", WrEx_RdEx, total);
+  static final ThreadSafeRatioCounter RdEx_WrEx_Same_Ratio    = new ThreadSafeRatioCounter("RdEx_WrEx_Same_Ratio", RdEx_WrEx_Same, total);
+  static final ThreadSafeRatioCounter RdEx_WrEx_Diff_Ratio    = new ThreadSafeRatioCounter("RdEx_WrEx_Diff_Ratio", RdEx_WrEx_Diff, total);
+  static final ThreadSafeRatioCounter RdEx_RdEx_Ratio         = new ThreadSafeRatioCounter("RdEx_RdEx_Ratio", RdEx_RdEx, total);
+  static final ThreadSafeRatioCounter RdEx_RdSh_Ratio         = new ThreadSafeRatioCounter("RdEx_RdSh_Ratio", RdEx_RdSh, total);
+  static final ThreadSafeRatioCounter RdSh_WrEx_Ratio         = new ThreadSafeRatioCounter("RdSh_WrEx_Ratio", RdSh_WrEx, total);
+  static final ThreadSafeRatioCounter RdSh_RdSh_NoFence_Ratio = new ThreadSafeRatioCounter("RdSh_RdSh_NoFence_Ratio", RdSh_RdSh_NoFence, total);
+  static final ThreadSafeRatioCounter RdSh_RdSh_Fence_Ratio   = new ThreadSafeRatioCounter("RdSh_RdSh_Fence_Ratio", RdSh_RdSh_Fence, total);
+
+  static final ThreadSafeRatioCounter sameState_Ratio      = new ThreadSafeRatioCounter("sameState_Ratio", sameState, total);
+  static final ThreadSafeRatioCounter upgrading_Ratio      = new ThreadSafeRatioCounter("upgrading_Ratio", upgrading, total);
+  static final ThreadSafeRatioCounter conflicting_Ratio    = new ThreadSafeRatioCounter("conflicting_Ratio", conflicting, total);
+  static final ThreadSafeRatioCounter total_Ratio          = new ThreadSafeRatioCounter("total_Ratio", total, total); // should report 1.00
+
+  // Counting threads
+  public static final SpecialUnsyncCounter threadsLive = new SpecialUnsyncCounter("threadsLive");
+  
+  // stats for RBA
+  public static final ThreadSafeCounter sharedAccesses = new ThreadSafeCounter("Shared_Accesses", true); 
+  public static final ThreadSafeCounter redundantBarriers = new ThreadSafeCounter("Redundant_Barriers", true);
+  public static final UnsyncHistogram optimisticRbaStaticLoopSize = new UnsyncHistogram("optimisticRbaStaticLoopSize", true, 1L<<32);
+
+  static {
+    if (Octet.getConfig().stats()) {
+      Callbacks.addExitMonitor(new ExitMonitor() {
+        //@Override
+        public void notifyExit(int value) {
+
+          System.out.println("BEGIN .gv");
+          System.out.println("  Null -> WrEx [ style=dotted label = \"" + pct(Alloc.total() + Uninit_Init.total(), total.total()) + "%\" ]");
+          System.out.println("  WrEx -> WrEx [ style=dotted label = \"" + pct(WrEx_WrEx_Same.total(), total.total()) + "%\" ]");
+          System.out.println("  WrEx -> WrEx [ style=solid  label = \"" + pct(WrEx_WrEx_Diff.total(), total.total()) + "%\" headport=sw ]");
+          System.out.println("  WrEx -> RdEx [ style=solid  label = \"" + pct(WrEx_RdEx.total(), total.total()) + "%\" ]");
+          System.out.println("  RdEx -> WrEx [ style=dashed label = \"" + pct(RdEx_WrEx_Same.total(), total.total()) + "%\" ]");
+          System.out.println("  RdEx -> WrEx [ style=solid  label = \"" + pct(RdEx_WrEx_Diff.total(), total.total()) + "%\" ]");
+          System.out.println("  RdEx -> RdEx [ style=dotted label = \"" + pct(RdEx_RdEx.total(), total.total()) + "%\" ]");
+          System.out.println("  RdEx -> RdSh [ style=dashed label = \"" + pct(RdEx_RdSh.total(), total.total()) + "%\" ]");
+          System.out.println("  RdSh -> WrEx [ style=solid  label = \"" + pct(RdSh_WrEx.total(), total.total()) + "%\" ]");
+          System.out.println("  RdSh -> RdSh [ style=dotted label = \"" + pct(RdSh_RdSh_NoFence.total(), total.total()) + "%\" ]");
+          System.out.println("  RdSh -> RdSh [ style=dashed label = \"" + pct(RdSh_RdSh_Fence.total(), total.total()) + "%\" ]");
+          System.out.println();
+          System.out.println("Null1 -> Null2 [style=dotted label=\"Same state: "  + commas(sameState.total()) + "\" ]");
+          System.out.println("Null3 -> Null4 [style=dashed label=\"Upgrading: "   + commas(upgrading.total()) + "\" ]");
+          System.out.println("Null5 -> Null6 [style=solid  label=\"Conflicting: " + commas(conflicting.total()) + "\" ]");
+          System.out.println("END .gv");
+
+          System.out.println();
+          
+          System.out.println("BEGIN tabular");
+          System.out.println(commas(sameState.total()) + " & " + commas(upgrading.total()) + " & " + commas(conflicting.total()));
+          
+          System.out.print(pct(Alloc.total() + Uninit_Init.total(), total.total()));
+          for (ThreadSafeCounter counter : new ThreadSafeCounter[] { WrEx_WrEx_Same, RdEx_RdEx, RdSh_RdSh_NoFence,
+                                                                     RdEx_WrEx_Same, RdEx_RdSh, RdSh_RdSh_Fence,
+                                                                     WrEx_WrEx_Diff, WrEx_RdEx, RdEx_WrEx_Diff, RdSh_WrEx } ) {
+            System.out.print(" & " + pct(counter.total(), total.total()));
+          }
+          System.out.println(" \\");
+          System.out.println("END tabular");
+
+        }
+      });
+    }
+  }
+  
+  @Interruptible
+  static String pct(long x, long total) {
+    double fraction = (double)x / total;
+    double pct = fraction * 100;
+    return new DecimalFormat("0.0000000000000").format(pct); 
+  }
+  
+  @Interruptible
+  public static String commas(long n) {
+    if (n < 0) {
+      return "-" + commas(-n);
+    } else if (n < 1000) {
+      return String.valueOf(n);
+    } else {
+      return commas(n / 1000) + "," + String.valueOf((n % 1000) + 1000).substring(1);
+    }
+  }
+  
+  @Interruptible
+  public static String commas(ThreadSafeCounter counter) {
+    return commas(counter.total());
+  }
+  
+  // measuring how often and where communication gets blocked:
+  // Octet: LATER: consider other ways we might avoid blocking sometimes, in favor of checking (e.g., if code could be in a loop for a while but won't actually block)
+  public static final ThreadSafeCounter blockCommEntrypoint = new ThreadSafeCounter("blockCommEntrypoint", false);
+  public static final ThreadSafeCounter blockCommReceiveResponses = new ThreadSafeCounter("blockCommReceiveResponses", false);
+  public static final ThreadSafeCounter blockCommBeginPairHandshake = new ThreadSafeCounter("blockCommBeginPairHandshake", false);
+  public static final ThreadSafeCounter blockCommThreadBlock = new ThreadSafeCounter("blockCommThreadBlock", false);
+  public static final ThreadSafeCounter blockCommEnterJNIFromCallIntoNative = new ThreadSafeCounter("blockCommEnterJNIFromCallIntoNative", false);
+  public static final ThreadSafeCounter blockCommEnterJNIFromJNIFunctionCall = new ThreadSafeCounter("blockCommEnterJNIFromJNIFunctionCall", false);
+  public static final ThreadSafeCounter blockCommEnterNative = new ThreadSafeCounter("blockCommEnterNative", false);
+  public static final ThreadSafeCounter blockCommTerminate = new ThreadSafeCounter("blockCommTerminate", false);
+  public static final ThreadSafeCounter blockCommYieldpoint = new ThreadSafeCounter("blockCommYieldpoint", false);
+  public static final ThreadSafeCounter blockCommHoldsLock = new ThreadSafeCounter("blockCommHoldsLock", false);
+  public static final ThreadSafeCounter blockCommLock = new ThreadSafeCounter("blockCommLock", false);
+  
+  static {
+    Callbacks.addExitMonitor(new ExitMonitor() {
+      //@Override
+      public void notifyExit(int value) {
+        for (Stat stat : all) {
+          stat.report();
+        }
+      }
+    });
+  }
+  
+  @Uninterruptible
+  static abstract class Stat {
+    public static final String SEPARATOR = ": ";
+    public static final String LINE_PREFIX = "STATS" + SEPARATOR;
+    final String name;
+    /**
+     * Determines if stats that we want to collect with this object is compile
+     * time stats or runtime stats.
+     */
+    protected final boolean staticStat;
+
+    Stat(String name, boolean runtimeStats) {
+      // if counter names contain spaces in their names, EXP cannot parse the results.
+      if (VM.VerifyAssertions) {
+        VM._assert(name == null || !name.contains(" "), "Counter name contains space character in it.");
+      }
+      this.name = name;
+      this.staticStat = runtimeStats;
+      if (Octet.getConfig().stats()) {
+        if (name != null) {
+          synchronized (all) {
+            all.add(this);
+          }
+        }
+      }
+    }
+    @Interruptible
+    abstract void report();
+    
+    @Interruptible
+    protected String outputLinePrefix() {
+      return LINE_PREFIX + this.getClass().getName() + SEPARATOR;
+    }
+  }
+  
+  public static final class PerSiteCounter extends Stat {
+    final UnsyncCounter[] counters;
+    public PerSiteCounter(String name) {
+      super(name, true);
+      if (Octet.getConfig().stats()) {
+        counters = new UnsyncCounter[Site.MAX_SITES];
+        for (int i= 0; i < Site.MAX_SITES; i++) {
+          counters[i] = new UnsyncCounter(null);
+        }
+      } else {
+        counters = null;
+      }
+    }
+    @Uninterruptible
+    @Inline
+    public void inc(int siteID) {
+      if (Octet.getConfig().stats()) {
+        counters[siteID].inc();
+      }
+    }
+    @Interruptible
+    @Override
+    public void report() {
+      Integer[] siteIDs = new Integer[Site.MAX_SITES];
+      for (int i = 0; i < Site.MAX_SITES; i++) {
+        siteIDs[i] = i;
+      }
+      Arrays.sort(siteIDs, new Comparator<Integer>() {
+        public int compare(Integer siteID1, Integer siteID2) {
+          long total1 = counters[siteID1].getValue();
+          long total2 = counters[siteID2].getValue();
+          if (total1 > total2) {
+            return -1;
+          } else if (total1 < total2) {
+            return 1;
+          } else {
+            return 0;
+          }
+        }
+      });
+      long grandTotal = 0;
+      for (UnsyncCounter counter : counters) {
+        grandTotal += counter.getValue();
+      }
+      System.out.print(outputLinePrefix());
+      System.out.println(name + " = " + grandTotal);
+      for (int i = 0; i < 25; i++) {
+        int siteID = siteIDs[i];
+        System.out.print(outputLinePrefix());
+        System.out.println("  " + Site.lookupSite(siteID) + " = " + counters[siteID].getValue());
+      }
+    }
+  }
+  
+  @Uninterruptible
+  public static class UnsyncCounter extends Stat {
+    protected long value;
+    UnsyncCounter(String name) {
+      super(name, true);
+    }
+    @Inline
+    public void inc() {
+      if (Octet.getConfig().stats()) {
+        value++;
+      }
+    }
+    @Interruptible
+    @Override
+    void report() {
+      System.out.print(outputLinePrefix());
+      System.out.println(name + " = " + value);
+    }
+    final long getValue() {
+      return value;
+    }
+  }
+  
+  @Uninterruptible
+  public static class SpecialUnsyncCounter extends UnsyncCounter {
+    private long max;
+    private long numIncs;
+    private long numDecs;
+    SpecialUnsyncCounter(String name) {
+      super(name);
+    }
+    @Override
+    @Inline
+    public void inc() {
+      if (Octet.getConfig().stats()) {
+        super.inc();
+        numIncs++;
+        max = value > max ? value : max;
+      }
+    }
+    @Inline
+    public void dec() {
+      if (Octet.getConfig().stats()) {
+        value--;
+        numDecs++;
+      }
+    }
+    @Interruptible
+    @Override
+    final void report() {
+      System.out.print(outputLinePrefix());
+      System.out.println(name + " = " + value + " (max " + max + ", numIncs " + numIncs + ", numDecs " + numDecs + ")");
+    }
+  }
+  
+  @Uninterruptible
+  public static class ThreadSafeCounter extends Stat {
+    private final long[] values;
+    protected long total = -1;
+
+    ThreadSafeCounter(String name, boolean staticStats) {
+      super(name, staticStats);
+      values = Octet.getConfig().stats() ? new long[RVMThread.MAX_THREADS] : null;
+    }
+
+    @Inline
+    public void inc() {
+      if (Octet.getConfig().stats()) {
+        if (VM.runningVM) {
+          // do not increment dynamic stats if we are not in Harness
+          if (staticStat || (!staticStat && MemoryManager.inHarness())) {
+            values[RVMThread.getCurrentThreadSlot()]++;
+          }
+        } else if (staticStat){
+          incDuringBootImageBuild();
+        }
+      }
+    }
+    @NoInline
+    @UninterruptibleNoWarn // Needed because of synchronization, but it's okay because we know the VM won't be running when it calls this method.
+    private void incDuringBootImageBuild() {
+      if (VM.VerifyAssertions) { VM._assert(!VM.runningVM); }
+      // Synchronize in case multiple compiler threads are building the boot image (I think that happens).
+      synchronized (this) {
+        // Note that thread slot 0 isn't actually used by any thread,
+        // so we can just use this slot to represent all increments during the boot image build.
+        values[0]++;
+      }
+    }
+    @Interruptible
+    @Override
+    final void report() {
+      System.out.print(outputLinePrefix());
+      System.out.println(name + " = " + total());
+    }
+    
+    @Uninterruptible
+    final long total() {
+      // if not computed yet, compute it
+      if (total == -1) {
+        updateTotal();
+      }
+      return total ;
+    }
+
+    @Uninterruptible
+    protected void updateTotal() {
+      total = 0;
+      for (long value : values) {
+        total += value;
+      }
+    }
+  }
+
+  /**
+   * 
+   * This counter can be used for collecting stats that can be computed by
+   * adding several other stats For example number of total accesses can be
+   * computed by adding total number of reads with total number of writes.
+   * If we already have a counter for reads and another counter for writes,
+   * then we can use them to construct a new counter using this class.
+   * 
+   * @author Meisam
+   * 
+   */
+  @Uninterruptible
+  public static final class ThreadSafeSumCounter extends ThreadSafeCounter {
+
+    private ThreadSafeCounter[] threadSafeCounters;
+
+    public ThreadSafeSumCounter(String name, ThreadSafeCounter ... threadSafeCounters) {
+      super(name, false); // A sum counter is not really a runtime counter
+      this.threadSafeCounters = threadSafeCounters;
+    }
+
+    @Uninterruptible
+    protected void updateTotal() {
+      total = 0;
+      for (int i = 0; i < threadSafeCounters.length; i++) {
+        total += threadSafeCounters[i].total();
+      }
+    }
+    
+  }
+
+  /**
+   * 
+   * This counter can be used for collecting ratio of two stats, 
+   * for example the ratio of reads to writes.
+   * number of total accesses can be
+   * computed by adding total number of reads with total number of writes. If we
+   * already have a counter for reads and another counter for writes, then we
+   * can use them to construct a new counter using this class.
+   * 
+   * @author Meisam
+   * 
+   */
+  @Uninterruptible
+  public static final class ThreadSafeRatioCounter extends Stat {
+
+    private ThreadSafeCounter numeratorCounter;
+    private ThreadSafeCounter denumeratorCounter;
+
+    public ThreadSafeRatioCounter(String name, ThreadSafeCounter numerator, ThreadSafeCounter denumerator) {
+      super(name, true);
+      this.numeratorCounter = numerator;
+      this.denumeratorCounter = denumerator;
+    }
+
+    @Override
+    @Interruptible
+    void report() {
+      System.out.print(outputLinePrefix());
+      System.out.println(name + " = " + ratio());
+    }
+
+    @Uninterruptible
+    private double ratio() {
+      return (100.0 * numeratorCounter.total()) / denumeratorCounter.total();
+    }
+
+  }
+
+  @Uninterruptible
+  public static final class UnsyncHistogram extends Stat {
+    final boolean log2;
+    private final int[] data;
+    UnsyncHistogram(String name, boolean log2, long maxX) {
+      super(name, true);
+      this.log2 = log2;
+      this.data = Octet.getConfig().stats() ? new int[log2 ? log2(maxX) : (int)maxX] : null;
+    }
+    @Inline
+    public final void incBin(long x) {
+      if (Octet.getConfig().stats()) {
+        if (log2) {
+          data[log2(x)]++;
+        } else {
+          data[(int)x]++;
+        }
+      }
+    }
+    @Inline
+    public final void incTime(long startTime) {
+      if (Octet.getConfig().stats()) {
+        incBin(nsElapsed(startTime));
+      }
+    }
+    @Inline
+    public final long total() {
+      int i;
+      long sum = 0;
+      for (i = 0; i < data.length; i++) {
+        sum += data[i];
+      }
+      return sum;
+    }
+    @Inline
+    public final double arithmeticMean() { //Weighted arithmetic mean. Overestimated.
+      int lastNonzeroIndex;
+      for (lastNonzeroIndex = data.length - 1; lastNonzeroIndex >= 0 && data[lastNonzeroIndex] == 0; lastNonzeroIndex--) { }
+      double sum = 0;
+      int weight = 0;
+      if (lastNonzeroIndex > 0) {
+        for (int x = 0; x <= lastNonzeroIndex; x++) {
+          sum += data[x] * ((1 << (x + 1)) -1);
+          weight += ((1 << (x + 1)) -1);
+        }
+        return sum / weight;
+      }
+      return 0;
+    }
+    @Interruptible
+    @Override
+    final void report() {
+      int lastNonzeroIndex; // don't print any tail of all 0s
+      for (lastNonzeroIndex = data.length - 1; lastNonzeroIndex >= 1 && data[lastNonzeroIndex] == 0; lastNonzeroIndex--) { }
+      
+      for (int x = 0; x <= lastNonzeroIndex; x++) {
+        System.out.print(outputLinePrefix());
+        System.out.print(name + "[" + x + "] = " + data[x]);
+        if (log2) {
+          //System.out.print(" (" + (data[x] << x) + ")");
+          //Man: I think data[x] is the actual value of the counter, even if it is log-based.
+          // data[x]<<x doesn't make sense.
+          System.out.printf(" (range: [%d, %d))", 1 << x, 1<<(x+1));
+        }
+        System.out.println();
+      }
+    }
+    static final int log2(long n) {
+      if (n <= 1) {
+        return 0;
+      } else {
+        return 1 + log2(n / 2);
+      }
+    }
+  }
+
+  static final long nsElapsed(long startTime) {
+    return (long)(Time.nanoTime() - startTime);
+  }
+
+  @UninterruptibleNoWarn
+  public static final void tryToPrintStack(Address framePointer) {
+    try {
+      RVMThread.dumpStack(framePointer);
+    } catch (Exception ex) { /* do nothing */ }
+  }
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/osr/ia32/OptExecutionStateExtractor.java workspace/velodrome-sound/rvm/src/org/jikesrvm/osr/ia32/OptExecutionStateExtractor.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/osr/ia32/OptExecutionStateExtractor.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/osr/ia32/OptExecutionStateExtractor.java	2014-04-03 17:43:45.413678407 -0400
@@ -253,9 +253,11 @@ public abstract class OptExecutionStateE
     OSRMapIterator iterator = osrmap.getOsrMapIteratorForMCOffset(ipOffset);
     if (VM.VerifyAssertions) VM._assert(iterator != null);
 
+    // Octet: Static cloning: Support multiple resolved methods for every method reference.
+
     ExecutionState state = new ExecutionState(thread, fpOffset, cmid, iterator.getBcIndex(), tsFPOffset);
     MethodReference mref = MemberReference.getMemberRef(iterator.getMethodId()).asMethodReference();
-    state.setMethod((NormalMethod) mref.peekResolvedMethod());
+    state.setMethod((NormalMethod) mref.peekResolvedMethod(CompiledMethods.getCompiledMethod(cmid).method.getStaticContext()));
     // this is not caller, but the callee, reverse it when outside
     // of this function.
     state.callerState = null;
@@ -269,7 +271,7 @@ public abstract class OptExecutionStateE
       if (iterator.getMethodId() != state.meth.getId()) {
         ExecutionState newstate = new ExecutionState(thread, fpOffset, cmid, iterator.getBcIndex(), tsFPOffset);
         mref = MemberReference.getMemberRef(iterator.getMethodId()).asMethodReference();
-        newstate.setMethod((NormalMethod) mref.peekResolvedMethod());
+        newstate.setMethod((NormalMethod) mref.peekResolvedMethod(CompiledMethods.getCompiledMethod(cmid).method.getStaticContext()));
         // this is not caller, but the callee, reverse it when outside
         // of this function.
         newstate.callerState = state;
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/Properties.java workspace/velodrome-sound/rvm/src/org/jikesrvm/Properties.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/Properties.java	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/Properties.java	2014-04-03 17:43:46.735682753 -0400
@@ -68,6 +68,9 @@ public class Properties extends Options 
    * progress during the execution of VM.boot
    */
   public static int verboseBoot = 0;
+  
+  // Velodrome: Adding a non-standard argument to identify benchmark category
+  public static int benchmarkCategory = 0;
 
   /**
    * The following is set on by -verbose:class command line argument.
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/BootRecord.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/BootRecord.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/BootRecord.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/BootRecord.java	2014-04-03 17:43:47.750686088 -0400
@@ -160,6 +160,9 @@ public class BootRecord {
    * set by -X:verboseBoot=
    */
   public int verboseBoot = 0;
+  
+  // Velodrome: Adding a non-standard argument to identify benchmark category
+  public int benchmarkCategory = 0;
 
   // RVM startoff
   //
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/DynamicLinker.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/DynamicLinker.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/DynamicLinker.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/DynamicLinker.java	2014-04-03 17:43:47.747686079 -0400
@@ -12,21 +12,29 @@
  */
 package org.jikesrvm.runtime;
 
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.ArchitectureSpecific.DynamicLinkerHelper;
-import org.jikesrvm.VM;
 import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.MethodReference;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMMethod;
-import org.jikesrvm.classloader.MethodReference;
 import org.jikesrvm.compilers.common.CompiledMethod;
 import org.jikesrvm.compilers.common.CompiledMethods;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.DynamicBridge;
 import org.vmmagic.pragma.Entrypoint;
 import org.vmmagic.pragma.NoInline;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
 
+// Octet: Static cloning: Various changes in this class to support multiple resolved methods for every method reference.
+
 /**
  * Implement lazy compilation.
  */
@@ -43,7 +51,70 @@ public class DynamicLinker implements Co
   @Entrypoint
   static void lazyMethodInvoker() {
     DynamicLink dl = DL_Helper.resolveDynamicInvocation();
-    RVMMethod targMethod = DL_Helper.resolveMethodRef(dl);
+    MethodReference methodRef = dl.methodRef();
+    
+    Address callingFrame = Magic.getCallerFramePointer(Magic.getFramePointer());
+    int callingCompiledMethodId = Magic.getCompiledMethodID(callingFrame);
+    CompiledMethod ccm = CompiledMethods.getCompiledMethod(callingCompiledMethodId);
+    
+    // Velodrome: Context: Walk stack to find caller, note if it is application
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    int resolvedContext = ccm.method.getStaticContext();
+    if (Context.isApplicationPrefix(methodRef.getType())) {
+      // I guess it is not necessary to do this for non-Octet threads, since they will probably not execute application 
+      // code
+      if (currentThread.isOctetThread()) {
+        Address fp = Magic.getFramePointer();
+        boolean atLeastOneAppMethod = false;
+        // Search for the topmost application frame/method
+        while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+          int compiledMethodId = Magic.getCompiledMethodID(fp);
+          if (compiledMethodId != INVISIBLE_METHOD_ID) {
+            CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+            RVMMethod method = compiledMethod.getMethod();
+            if (!method.isNative() && Octet.shouldInstrumentMethod(method)) {
+              resolvedContext = method.getStaticContext();
+              atLeastOneAppMethod = true;
+              break;
+            }
+          }
+          fp = Magic.getCallerFramePointer(fp);
+        }
+        if (!atLeastOneAppMethod) { // First application method called
+          resolvedContext = Context.NONTRANS_CONTEXT; 
+        }
+      }
+    }
+    
+    RVMMethod targMethod = DL_Helper.resolveMethodRef(dl, resolvedContext);
+    
+    // Velodrome: Context: This is bad, but "methodRef" can be a library type, while the targMethod is an application method
+    if (currentThread.isOctetThread()) {
+      if (Context.isApplicationPrefix(targMethod.getDeclaringClass().getTypeRef()) && 
+          !Context.isApplicationPrefix(methodRef.getType())) {
+        Address fp = Magic.getFramePointer();
+        boolean atLeastOneAppMethod = false;
+        // Search for the topmost application frame/method
+        while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+          int compiledMethodId = Magic.getCompiledMethodID(fp);
+          if (compiledMethodId != INVISIBLE_METHOD_ID) {
+            CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+            RVMMethod method = compiledMethod.getMethod();
+            if (!method.isNative() && Octet.shouldInstrumentMethod(method)) {
+              resolvedContext = method.getStaticContext();
+              atLeastOneAppMethod = true;
+              break;
+            }
+          }
+          fp = Magic.getCallerFramePointer(fp);
+        }
+        if (!atLeastOneAppMethod) { // First application method called
+          resolvedContext = Context.NONTRANS_CONTEXT; 
+        }
+      }
+      targMethod = DL_Helper.resolveMethodRef(dl, resolvedContext); // Recompute 
+    }
+
     DL_Helper.compileMethod(dl, targMethod);
     CodeArray code = targMethod.getCurrentEntryCodeArray();
     Magic.dynamicBridgeTo(code);                   // restore parameters and invoke
@@ -60,7 +131,7 @@ public class DynamicLinker implements Co
   @Entrypoint
   static void unimplementedNativeMethod() {
     DynamicLink dl = DL_Helper.resolveDynamicInvocation();
-    RVMMethod targMethod = DL_Helper.resolveMethodRef(dl);
+    RVMMethod targMethod = DL_Helper.resolveMethodRef(dl, Context.VM_CONTEXT);
     throw new UnsatisfiedLinkError(targMethod.toString());
   }
 
@@ -70,7 +141,7 @@ public class DynamicLinker implements Co
   @Entrypoint
   static void sysCallMethod() {
     DynamicLink dl = DL_Helper.resolveDynamicInvocation();
-    RVMMethod targMethod = DL_Helper.resolveMethodRef(dl);
+    RVMMethod targMethod = DL_Helper.resolveMethodRef(dl, Context.VM_CONTEXT);
     throw new UnsatisfiedLinkError(targMethod.toString() + " which is a SysCall");
   }
 
@@ -118,21 +189,21 @@ public class DynamicLinker implements Co
      * </pre>
      */
     @NoInline
-    static RVMMethod resolveMethodRef(DynamicLink dynamicLink) {
+    static RVMMethod resolveMethodRef(DynamicLink dynamicLink, int context) {
       // resolve symbolic method reference into actual method
       //
       MethodReference methodRef = dynamicLink.methodRef();
       if (dynamicLink.isInvokeSpecial()) {
-        return methodRef.resolveInvokeSpecial();
+        return methodRef.resolveInvokeSpecial(context);
       } else if (dynamicLink.isInvokeStatic()) {
-        return methodRef.resolve();
+        return methodRef.resolve(context);
       } else {
         // invokevirtual or invokeinterface
         VM.disableGC();
         Object targetObject = DynamicLinkerHelper.getReceiverObject();
         VM.enableGC();
         RVMClass targetClass = Magic.getObjectType(targetObject).asClass();
-        RVMMethod targetMethod = targetClass.findVirtualMethod(methodRef.getName(), methodRef.getDescriptor());
+        RVMMethod targetMethod = targetClass.findVirtualMethod(methodRef.getName(), methodRef.getDescriptor(), context);
         if (targetMethod == null) {
           throw new IncompatibleClassChangeError(targetClass.getDescriptor().classNameFromDescriptor());
         }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/EntrypointHelper.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/EntrypointHelper.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/EntrypointHelper.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/EntrypointHelper.java	2014-04-03 17:43:47.754686100 -0400
@@ -15,6 +15,7 @@ package org.jikesrvm.runtime;
 import org.jikesrvm.VM;
 import org.jikesrvm.classloader.Atom;
 import org.jikesrvm.classloader.BootstrapClassLoader;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMMember;
@@ -54,7 +55,8 @@ public class EntrypointHelper {
       if ((member = cls.findDeclaredField(memName, memDescriptor)) != null) {
         return member;
       }
-      if ((member = cls.findDeclaredMethod(memName, memDescriptor)) != null) {
+      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+      if ((member = cls.findDeclaredMethod(memName, memDescriptor, Context.VM_CONTEXT)) != null) {
         return member;
       }
     } catch (Exception e) {
@@ -107,7 +109,8 @@ public class EntrypointHelper {
 
         Atom descriptor = Atom.findOrCreateAsciiAtom(makeDescriptor(argTypes));
 
-        RVMMethod method = cls.findDeclaredMethod(member, descriptor);
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
+        RVMMethod method = cls.findDeclaredMethod(member, descriptor, Context.VM_CONTEXT);
         if (method != null) {
           return method;
         }
@@ -215,7 +218,9 @@ public class EntrypointHelper {
         Atom memName = Atom.findOrCreateAsciiAtom(member);
         Atom memDescriptor = Atom.findOrCreateAsciiAtom(descriptor);
 
-        NormalMethod m = (NormalMethod)cls.findDeclaredMethod(memName, memDescriptor);
+        // Octet: Support multiple resolved methods for every method reference.
+        // Velodrome: Context: Here we can possibly check for run() method, and pass NONTRANS_CONTEXT.
+        NormalMethod m = (NormalMethod)cls.findDeclaredMethod(memName, memDescriptor, Context.VM_CONTEXT);
         if (m != null) {
           m.setRuntimeServiceMethod(true);
           return m;
@@ -228,4 +233,17 @@ public class EntrypointHelper {
     throw new Error("Entrypoints.getMethod: can't resolve class=" +
         klass + " method=" + member + " desc=" + descriptor);
   }
+
+  // Octet: Additional methods to support multiple resolved methods for every method reference.
+
+  public static MethodReference getMethodReference(Class<?> klass, String member, String descriptor) {
+    return getMethodReference(TypeReference.findOrCreate(klass), member, descriptor);
+  }
+
+  public static MethodReference getMethodReference(TypeReference typeRef, String member, String descriptor) {
+    Atom memName = Atom.findOrCreateAsciiAtom(member);
+    Atom memDescriptor = Atom.findOrCreateAsciiAtom(descriptor);
+    return MethodReference.findOrCreate(typeRef, memName, memDescriptor);
+  }
+
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/Entrypoints.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/Entrypoints.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/Entrypoints.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/Entrypoints.java	2014-04-03 17:43:47.749686085 -0400
@@ -16,9 +16,12 @@ import static org.jikesrvm.runtime.Entry
 import static org.jikesrvm.runtime.EntrypointHelper.getMethod;
 
 import org.jikesrvm.VM;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.MethodReference;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.TypeReference;
 
 /**
  * Fields and methods of the virtual machine that are needed by
@@ -32,8 +35,12 @@ public class Entrypoints {
 
   public static final NormalMethod bootMethod = EntrypointHelper.getMethod(org.jikesrvm.VM.class, "boot", "()V");
 
-  public static final RVMMethod java_lang_reflect_Method_invokeMethod =
+  // Octet: Static cloning: Use a method reference instead of a resolved method to simplify checking for a match.
+  /*public static final RVMMethod java_lang_reflect_Method_invokeMethod =
       getMethod(java.lang.reflect.Method.class, "invoke",
+          "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;");*/
+  public static final MethodReference java_lang_reflect_Method_invokeMethodReference =
+      EntrypointHelper.getMethodReference(java.lang.reflect.Method.class, "invoke",
           "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;");
   public static final RVMMethod getClassFromStackFrame =
     getMethod(org.jikesrvm.classloader.RVMClass.class, "getClassFromStackFrame", "(I)Lorg/jikesrvm/classloader/RVMClass;");
@@ -95,13 +102,18 @@ public class Entrypoints {
       getMethod(org.jikesrvm.runtime.RuntimeEntrypoints.class, "deliverHardwareException", "(II)V");
   public static final NormalMethod unlockAndThrowMethod =
       getMethod(org.jikesrvm.runtime.RuntimeEntrypoints.class, "unlockAndThrow", "(Ljava/lang/Object;Ljava/lang/Throwable;)V");
+  
+  // Velodrome: Uninstrumented version 
+  public static final NormalMethod unlockAndThrowMethodWithoutInstrumentation =
+      getMethod(org.jikesrvm.runtime.RuntimeEntrypoints.class, "unlockAndThrowWithoutInstrumentation", "(Ljava/lang/Object;Ljava/lang/Throwable;)V");
 
   public static final RVMField gcLockField = getField("Ljava/lang/VMCommonLibrarySupport$GCLock;", "gcLock", int.class);
 
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
   public static final NormalMethod invokeInterfaceMethod =
       getMethod(org.jikesrvm.classloader.InterfaceInvocation.class,
                 "invokeInterface",
-                "(Ljava/lang/Object;I)Lorg/jikesrvm/ArchitectureSpecific$CodeArray;");
+                "(Ljava/lang/Object;II)Lorg/jikesrvm/ArchitectureSpecific$CodeArray;");
   public static final NormalMethod findItableMethod =
       getMethod(org.jikesrvm.classloader.InterfaceInvocation.class,
                 "findITable",
@@ -109,22 +121,126 @@ public class Entrypoints {
   public static final NormalMethod unresolvedInvokeinterfaceImplementsTestMethod =
       getMethod(org.jikesrvm.classloader.InterfaceInvocation.class,
                 "unresolvedInvokeinterfaceImplementsTest",
-                "(ILjava/lang/Object;)V");
+                "(ILjava/lang/Object;I)V");
 
-  public static final NormalMethod lockMethod =
+  // Velodrome: Lock methods with instrumentation
+  
+  public static final NormalMethod lockMethodWithInstrumentation =
       getMethod(org.jikesrvm.objectmodel.ObjectModel.class, "genericLock", "(Ljava/lang/Object;)V");
-  public static final NormalMethod unlockMethod =
+  public static final NormalMethod unlockMethodWithInstrumentation =
       getMethod(org.jikesrvm.objectmodel.ObjectModel.class, "genericUnlock", "(Ljava/lang/Object;)V");
 
-  public static final NormalMethod inlineLockMethod =
+  public static final NormalMethod inlineLockMethodWithInstrumentation =
       getMethod(org.jikesrvm.scheduler.ThinLock.class,
                 "inlineLock",
                 "(Ljava/lang/Object;Lorg/vmmagic/unboxed/Offset;)V");
-  public static final NormalMethod inlineUnlockMethod =
+  public static final NormalMethod inlineUnlockMethodWithInstrumentation =
       getMethod(org.jikesrvm.scheduler.ThinLock.class,
                 "inlineUnlock",
                 "(Ljava/lang/Object;Lorg/vmmagic/unboxed/Offset;)V");
+  
+  // Velodrome: Lock methods without instrumentation
+  
+  public static final NormalMethod lockMethodWithoutInstrumentation =
+      getMethod(org.jikesrvm.objectmodel.ObjectModel.class, "genericLockWithoutInstrumentation", "(Ljava/lang/Object;)V");
+  public static final NormalMethod unlockMethodWithoutInstrumentation =
+      getMethod(org.jikesrvm.objectmodel.ObjectModel.class, "genericUnlockWithoutInstrumentation", "(Ljava/lang/Object;)V");
 
+  public static final NormalMethod inlineLockMethodWithoutInstrumentation =
+      getMethod(org.jikesrvm.scheduler.ThinLock.class,
+                "inlineLockWithoutInstrumentation",
+                "(Ljava/lang/Object;Lorg/vmmagic/unboxed/Offset;)V");
+  public static final NormalMethod inlineUnlockMethodWithoutInstrumentation =
+      getMethod(org.jikesrvm.scheduler.ThinLock.class,
+                "inlineUnlockWithoutInstrumentation",
+                "(Ljava/lang/Object;Lorg/vmmagic/unboxed/Offset;)V");
+
+  // Octet: instrumentation methods and fields
+  
+  /** Call to resolve unresolved static */
+  public static final NormalMethod octetResolveMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "getResolved", "(I)Lorg/vmmagic/unboxed/Word;");
+  
+  public static final NormalMethod octetFieldReadBarrierResolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldReadBarrierResolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetFieldReadBarrierStaticResolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldReadBarrierStaticResolved", "(Lorg/vmmagic/unboxed/Offset;II)V");
+  public static final NormalMethod octetFieldWriteBarrierResolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldWriteBarrierResolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetFieldWriteBarrierStaticResolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldWriteBarrierStaticResolved", "(Lorg/vmmagic/unboxed/Offset;II)V");
+  public static final NormalMethod octetFieldReadBarrierUnresolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldReadBarrierUnresolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetFieldReadBarrierStaticUnresolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldReadBarrierStaticUnresolved", "(II)V");
+  public static final NormalMethod octetFieldWriteBarrierUnresolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldWriteBarrierUnresolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetFieldWriteBarrierStaticUnresolvedMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "fieldWriteBarrierStaticUnresolved", "(II)V");
+  public static final NormalMethod octetArrayReadBarrierMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "arrayReadBarrier", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetArrayWriteBarrierMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "arrayWriteBarrier", "(Ljava/lang/Object;II)V");
+  
+  public static final NormalMethod octetReadObjectMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "readObject", "(Ljava/lang/Object;II)Z");
+  public static final NormalMethod octetWriteObjectMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "writeObject", "(Ljava/lang/Object;II)Z");
+  public static final NormalMethod octetReadStaticMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "readStatic", "(Lorg/vmmagic/unboxed/Offset;II)Z");
+  public static final NormalMethod octetWriteStaticMethod = getMethod(org.jikesrvm.octet.OctetBarriers.class, "writeStatic", "(Lorg/vmmagic/unboxed/Offset;II)Z");
+
+  public static final NormalMethod octetReadSlowPathMethod = getMethod(org.jikesrvm.octet.StateTransfers.class, "readSlowPath", "(Lorg/vmmagic/unboxed/Address;Lorg/vmmagic/unboxed/Offset;Lorg/vmmagic/unboxed/Word;II)V");
+  public static final NormalMethod octetWriteSlowPathMethod = getMethod(org.jikesrvm.octet.StateTransfers.class, "writeSlowPath", "(Lorg/vmmagic/unboxed/Address;Lorg/vmmagic/unboxed/Offset;Lorg/vmmagic/unboxed/Word;II)V");
+  
+  public static final NormalMethod octetPessimisticFieldReadBarrierResolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldReadBarrierResolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetPessimisticFieldReadBarrierStaticResolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldReadBarrierStaticResolved", "(Lorg/vmmagic/unboxed/Offset;II)V");
+  public static final NormalMethod octetPessimisticFieldWriteBarrierResolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldWriteBarrierResolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetPessimisticFieldWriteBarrierStaticResolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldWriteBarrierStaticResolved", "(Lorg/vmmagic/unboxed/Offset;II)V");
+  public static final NormalMethod octetPessimisticFieldReadBarrierUnresolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldReadBarrierUnresolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetPessimisticFieldReadBarrierStaticUnresolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldReadBarrierStaticUnresolved", "(II)V");
+  public static final NormalMethod octetPessimisticFieldWriteBarrierUnresolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldWriteBarrierUnresolved", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetPessimisticFieldWriteBarrierStaticUnresolvedMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "fieldWriteBarrierStaticUnresolved", "(II)V");
+  public static final NormalMethod octetPessimisticArrayReadBarrierMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "arrayReadBarrier", "(Ljava/lang/Object;II)V");
+  public static final NormalMethod octetPessimisticArrayWriteBarrierMethod = getMethod(org.jikesrvm.octet.PessimisticBarriers.class, "arrayWriteBarrier", "(Ljava/lang/Object;II)V");
+
+  public static final NormalMethod octetBlockCommunicationRequestsMethod = getMethod(org.jikesrvm.octet.Communication.class, "blockCommunicationRequests", "()V");
+  public static final NormalMethod octetUnblockCommunicationRequestsMethod = getMethod(org.jikesrvm.octet.Communication.class, "unblockCommunicationRequests", "()V");
+
+  public static final RVMField octetRequestsField = getField(org.jikesrvm.scheduler.RVMThread.class, "octetRequests", org.vmmagic.unboxed.Word.class);
+
+  public static final RVMField octetGlobalReadSharedCounterField = getField(org.jikesrvm.octet.OctetState.class, "globalReadSharedCounter", org.vmmagic.unboxed.Word.class);
+  public static final RVMField octetThreadReadSharedCounterField = getField(org.jikesrvm.scheduler.RVMThread.class, "octetReadSharedCounter", org.vmmagic.unboxed.Word.class);
+
+  // Octet: Static cloning: Runtime instrumentation method that checks that static contexts are correct dynamically.
+  public static final NormalMethod checkLibraryContextMethod = getMethod(org.jikesrvm.classloader.Context.class, "checkLibraryContext", "()V");
+
+  // Octet: Static cloning: Support for using different versions of standard streams between application and VM contexts.
+  public static final FieldReference systemOut   = getField(java.lang.System.class,   "out", java.io.PrintStream.class).getMemberRef().asFieldReference();
+  public static final FieldReference systemErr   = getField(java.lang.System.class,   "err", java.io.PrintStream.class).getMemberRef().asFieldReference();
+  public static final FieldReference systemIn    = getField(java.lang.System.class,   "in",  java.io.InputStream.class).getMemberRef().asFieldReference();
+  public static final FieldReference vmSystemOut = getField(java.lang.VMSystem.class, "out", java.io.PrintStream.class).getMemberRef().asFieldReference();
+  public static final FieldReference vmSystemErr = getField(java.lang.VMSystem.class, "err", java.io.PrintStream.class).getMemberRef().asFieldReference();
+  public static final FieldReference vmSystemIn  = getField(java.lang.VMSystem.class, "in",  java.io.InputStream.class).getMemberRef().asFieldReference();
+
+  // Velodrome: Added entry points to track start/end of transactions and for instrumentation
+  public static final NormalMethod velodromeStartTransactionMethod = getMethod(org.jikesrvm.velodrome.TransactionalHBGraph.class, "startTransaction", "(II)V");
+  public static final NormalMethod velodromeEndTransactionMethod = getMethod(org.jikesrvm.velodrome.TransactionalHBGraph.class, "endTransaction", "(II)V");
+  public static final NormalMethod velodromeCheckMethodContextAtPrologMethod = getMethod(org.jikesrvm.velodrome.TransactionalHBGraph.class, "checkMethodContextAtProlog", "()V");
+
+  // Velodrome: Read/write barriers
+
+  public static final NormalMethod velodromeFieldReadBarrierResolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldReadBarrierResolved", "(Ljava/lang/Object;IIII)V");
+  public static final NormalMethod velodromeFieldWriteBarrierResolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldWriteBarrierResolved", "(Ljava/lang/Object;IIII)V");
+  
+  public static final NormalMethod velodromeFieldReadBarrierStaticResolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldReadBarrierStaticResolved", "(IIII)V");
+  public static final NormalMethod velodromeFieldWriteBarrierStaticResolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldWriteBarrierStaticResolved", "(IIII)V");
+
+  public static final NormalMethod velodromeFieldReadBarrierUnresolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldReadBarrierUnresolved", "(Ljava/lang/Object;IIII)V");
+  public static final NormalMethod velodromeFieldWriteBarrierUnresolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldWriteBarrierUnresolved", "(Ljava/lang/Object;IIII)V");
+  
+  public static final NormalMethod velodromeFieldReadBarrierStaticUnresolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldReadBarrierStaticUnresolved", "(IIII)V");
+  public static final NormalMethod velodromeFieldWriteBarrierStaticUnresolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "fieldWriteBarrierStaticUnresolved", "(IIII)V");
+  
+  public static final NormalMethod velodromeArrayReadBarrierMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "arrayReadBarrier", "(Ljava/lang/Object;IIIII)V");
+  public static final NormalMethod velodromeArrayWriteBarrierMethod = getMethod(org.jikesrvm.velodrome.VelodromeBarriers.class, "arrayWriteBarrier", "(Ljava/lang/Object;IIIII)V");
+
+  // Velodrome: Post read/write barriers to unlock object metadata
+  public static final NormalMethod velodromeUnlockMetadataForResolvedFieldMethod = getMethod(org.jikesrvm.velodrome.VelodromeMetadataHelper.class, "unlockResolvedFieldMetadata", "(Ljava/lang/Object;III)V");
+  public static final NormalMethod velodromeUnlockMetadataForUnresolvedFieldMethod = getMethod(org.jikesrvm.velodrome.VelodromeMetadataHelper.class, "unlockUnresolvedFieldMetadata", "(Ljava/lang/Object;III)V");
+  public static final NormalMethod velodromeUnlockMetadataForStaticResolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeMetadataHelper.class, "unlockMetadataForStaticResolved", "(Lorg/vmmagic/unboxed/Offset;III)V");
+  public static final NormalMethod velodromeUnlockMetadataForStaticUnresolvedMethod = getMethod(org.jikesrvm.velodrome.VelodromeMetadataHelper.class, "unlockMetadataForStaticUnresolved", "(III)V");
+  public static final NormalMethod velodromeArrayPostBarrierMethod = getMethod(org.jikesrvm.velodrome.VelodromeMetadataHelper.class, "arrayPostBarrier", "(Ljava/lang/Object;III)V");
+  
+  // Velodrome: Field for outgoing edges
+  public static final RVMField velodromeOutgoingEdgesField = getField(org.jikesrvm.velodrome.Transaction.class, "outgoingEdges", org.jikesrvm.velodrome.TransactionsList.class);  
+  
   public static final NormalMethod lazyMethodInvokerMethod =
       getMethod(org.jikesrvm.runtime.DynamicLinker.class, "lazyMethodInvoker", "()V");
   public static final NormalMethod unimplementedNativeMethodMethod =
@@ -132,10 +248,16 @@ public class Entrypoints {
   public static final NormalMethod sysCallMethod =
       getMethod(org.jikesrvm.runtime.DynamicLinker.class, "sysCallMethod", "()V");
 
+  // Octet: Static cloning: Support multiple resolved methods for every method reference.
   public static final NormalMethod resolveMemberMethod =
-      getMethod(org.jikesrvm.classloader.TableBasedDynamicLinker.class, "resolveMember", "(I)I");
-  public static final RVMField memberOffsetsField =
-      getField(org.jikesrvm.classloader.TableBasedDynamicLinker.class, "memberOffsets", int[].class);
+      getMethod(org.jikesrvm.classloader.TableBasedDynamicLinker.class, "resolveMember", "(II)I");
+  // Velodrome: Context: We now have 3 resolved contexts
+  public static final RVMField[] memberOffsetsFields =
+    new RVMField[] {
+      getField(org.jikesrvm.classloader.TableBasedDynamicLinker.class, "memberOffsetsVM", int[].class),
+      getField(org.jikesrvm.classloader.TableBasedDynamicLinker.class, "memberOffsetsTrans", int[].class),
+      getField(org.jikesrvm.classloader.TableBasedDynamicLinker.class, "memberOffsetsNonTrans", int[].class),
+    };
 
   /** 1L */
   public static final RVMField longOneField = getField(org.jikesrvm.runtime.MathConstants.class, "longOne", long.class);
@@ -340,6 +462,13 @@ public class Entrypoints {
     getMethod(org.jikesrvm.mm.mminterface.Barriers.class, "objectFieldWrite", "(Ljava/lang/Object;Ljava/lang/Object;Lorg/vmmagic/unboxed/Offset;I)V");
   public static final NormalMethod objectArrayWriteBarrierMethod =
     getMethod(org.jikesrvm.mm.mminterface.Barriers.class, "objectArrayWrite", "([Ljava/lang/Object;ILjava/lang/Object;)V");
+
+  // Octet: support "pre-barriers" that don't actually perform the write
+  public static final NormalMethod objectFieldWritePreBarrierMethod =
+    getMethod(org.jikesrvm.mm.mminterface.Barriers.class, "objectFieldWritePreBarrier", "(Ljava/lang/Object;Ljava/lang/Object;Lorg/vmmagic/unboxed/Offset;I)V");
+  public static final NormalMethod objectArrayWritePreBarrierMethod =
+    getMethod(org.jikesrvm.mm.mminterface.Barriers.class, "objectArrayWritePreBarrier", "([Ljava/lang/Object;ILjava/lang/Object;)V");
+
   public static final NormalMethod objectFieldReadBarrierMethod =
     getMethod(org.jikesrvm.mm.mminterface.Barriers.class, "objectFieldRead", "(Ljava/lang/Object;Lorg/vmmagic/unboxed/Offset;I)Ljava/lang/Object;");
   public static final NormalMethod objectArrayReadBarrierMethod =
@@ -464,7 +593,9 @@ public class Entrypoints {
   public static final NormalMethod optResolveMethod;
   public static final NormalMethod optNewArrayArrayMethod;
   public static final NormalMethod optNew2DArrayMethod;
-  public static final NormalMethod sysArrayCopy;
+  // Octet: Static cloning: Match on method reference to simplify things.
+  public static final MethodReference sysArrayCopy;
+  //public static final NormalMethod sysArrayCopy;
 
   static {
     if (VM.BuildForOptCompiler) {
@@ -490,8 +621,10 @@ public class Entrypoints {
           getMethod(org.jikesrvm.compilers.opt.runtimesupport.OptLinker.class, "newArrayArray", "(I[II)Ljava/lang/Object;");
       optNew2DArrayMethod =
           getMethod(org.jikesrvm.compilers.opt.runtimesupport.OptLinker.class, "new2DArray", "(IIII)Ljava/lang/Object;");
-      sysArrayCopy = getMethod("Ljava/lang/VMCommonLibrarySupport;", "arraycopy", "(Ljava/lang/Object;ILjava/lang/Object;II)V");
-      sysArrayCopy.setRuntimeServiceMethod(false);
+      // Octet: Static cloning: To support multiple contexts, it's easier here to just make a method reference
+      sysArrayCopy = EntrypointHelper.getMethodReference(TypeReference.findOrCreate("Ljava/lang/VMCommonLibrarySupport;"), "arraycopy", "(Ljava/lang/Object;ILjava/lang/Object;II)V");
+      // Unmodified Jikes would set "runtime service method" to false to make up for getMethod() setting it to true. Instead it'll now just remain false.
+      //sysArrayCopy.setRuntimeServiceMethod(false);
     } else {
       specializedMethodsField = null;
       optThreadSwitchFromOsrOptMethod = null;
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/FileSystem.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/FileSystem.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/FileSystem.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/FileSystem.java	2014-04-03 17:43:47.756686106 -0400
@@ -17,6 +17,7 @@ import java.io.BufferedOutputStream;
 import java.io.FileDescriptor;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.InputStream;
 import java.io.PrintStream;
 import org.jikesrvm.VM;
 import org.jikesrvm.Callbacks;
@@ -205,15 +206,33 @@ public class FileSystem {
     FileInputStream fdIn = new FileInputStream(FileDescriptor.in);
     FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);
     FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);
-    System.setIn(new BufferedInputStream(fdIn));
-    System.setOut(new PrintStream(new BufferedOutputStream(fdOut, 128), true));
-    System.setErr(new PrintStream(new BufferedOutputStream(fdErr, 128), true));
+
+    // Octet: Store references to the streams in two places, one for the VM context and one for the application context
+
+    InputStream in = new BufferedInputStream(fdIn);
+    PrintStream out = new PrintStream(new BufferedOutputStream(fdOut, 128), true);
+    PrintStream err = new PrintStream(new BufferedOutputStream(fdErr, 128), true);
+
+    VMSystem.in = in;
+    VMSystem.out = out;
+    VMSystem.err = err;
+
+    System.setIn(in);
+    System.setOut(out);
+    System.setErr(err);
+
     Callbacks.addExitMonitor(new Callbacks.ExitMonitor() {
       @Override
       public void notifyExit(int value) {
         try {
           System.err.flush();
           System.out.flush();
+          if (System.err != VMSystem.err) {
+            VMSystem.err.flush();
+          }
+          if (System.out != VMSystem.out) {
+            VMSystem.out.flush();
+          }
         } catch (Throwable e) {
           VM.sysWriteln("vm: error flushing stdout, stderr");
         }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/Reflection.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/Reflection.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/Reflection.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/Reflection.java	2014-04-03 17:43:47.747686079 -0400
@@ -12,10 +12,12 @@
  */
 package org.jikesrvm.runtime;
 
+import static org.jikesrvm.Configuration.BuildForSSE2Full;
+
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.ArchitectureSpecific.MachineReflection;
-import org.jikesrvm.VM;
 import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.TypeReference;
@@ -26,8 +28,6 @@ import org.vmmagic.pragma.NoInline;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.WordArray;
 
-import static org.jikesrvm.Configuration.BuildForSSE2Full;
-
 /**
  * Arch-independent portion of reflective method invoker.
  */
@@ -156,7 +156,8 @@ public class Reflection implements Const
         RVMClass I = method.getDeclaringClass();
         if (!RuntimeEntrypoints.isAssignableWith(I, C))
           throw new IncompatibleClassChangeError();
-        targetMethod = C.findVirtualMethod(method.getName(), method.getDescriptor());
+        // Octet: Static cloning: Support multiple resolved methods for every method reference.
+        targetMethod = C.findVirtualMethod(method.getName(), method.getDescriptor(), method.getResolvedContext());
         if (targetMethod == null)
           throw new IncompatibleClassChangeError();
       }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java	2014-04-03 17:43:47.750686088 -0400
@@ -14,14 +14,14 @@ package org.jikesrvm.runtime;
 
 import org.jikesrvm.ArchitectureSpecific;
 import org.jikesrvm.ArchitectureSpecific.Registers;
-import org.jikesrvm.VM;
 import org.jikesrvm.Constants;
 import org.jikesrvm.Services;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.DynamicTypeCheck;
+import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMArray;
 import org.jikesrvm.classloader.RVMClass;
-import org.jikesrvm.classloader.DynamicTypeCheck;
 import org.jikesrvm.classloader.RVMField;
-import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.classloader.TypeReference;
@@ -31,12 +31,14 @@ import org.jikesrvm.mm.mminterface.Barri
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.objectmodel.ObjectModel;
 import org.jikesrvm.objectmodel.TIB;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Entrypoint;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.NoInline;
 import org.vmmagic.pragma.Pure;
 import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
 import org.vmmagic.pragma.Unpreemptible;
 import org.vmmagic.pragma.UnpreemptibleNoWarn;
 import org.vmmagic.unboxed.Address;
@@ -170,8 +172,19 @@ public class RuntimeEntrypoints implemen
    * Perform aastore bytecode
    */
   @Entrypoint
+  // Octet: need this annotation to avoid stopping for GC at this method's yieldpoints
+  // Octet: TODO: look at this issue again, especially w.r.t. new way of handling generational write barriers
+  @UninterruptibleNoWarn
   static void aastore(Object[] arrayRef, int index, Object value) throws ArrayStoreException, ArrayIndexOutOfBoundsException {
-    checkstore(arrayRef, value);
+    // Octet: It causes problems with Octet to have interruptible code before an object access, so let's disable GC here.
+    MemoryManager.startAllocatingInUninterruptibleCode();
+    // Octet: TODO: Is it really okay to call an interruptible method here?  It could cause a safe point to execute.
+    try {
+      checkstore(arrayRef, value);
+    } finally {
+      // Octet: TODO: trying this here, to see if it helps recent failures related to GC apparently not being able to run
+      MemoryManager.stopAllocatingInUninterruptibleCode();
+    }
     int nelts = ObjectModel.getArrayLength(arrayRef);
     if (index >=0 && index < nelts) {
       Services.setArrayUninterruptible(arrayRef, index, value);
@@ -426,6 +439,7 @@ public class RuntimeEntrypoints implemen
    * @param obj the object to clone
    * @return the cloned object
    */
+  // Octet: Static cloning: TODO: need to handle the possibility of Octet barriers being needed here 
   public static Object clone(Object obj) throws OutOfMemoryError, CloneNotSupportedException {
     RVMType type = Magic.getObjectType(obj);
     if (type.isArrayType()) {
@@ -632,6 +646,8 @@ public class RuntimeEntrypoints implemen
   @Entrypoint
   static void unexpectedAbstractMethodCall() {
     VM.sysWrite("RuntimeEntrypoints.unexpectedAbstractMethodCall\n");
+    // Velodrome: Context: Added this to aid in debugging
+    RVMThread.dumpStack();
     throw new AbstractMethodError();
   }
 
@@ -696,6 +712,11 @@ public class RuntimeEntrypoints implemen
     Registers exceptionRegisters = myThread.getExceptionRegisters();
     if (false) VM.sysWriteln("we have exception registers = ",Magic.objectAsAddress(exceptionRegisters));
 
+    // Velodrome: Stack overflow: Fail assertion for stack overflow. How can we do this better?
+    if (VM.VerifyAssertions && (trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_STACK_OVERFLOW_FATAL)) {
+      VM.sysFail("Stack overflow error");
+    }
+
     if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) &&
         myThread.getStack().length < (STACK_SIZE_MAX >> LOG_BYTES_IN_ADDRESS) &&
         !myThread.hasNativeStackFrame()) {
@@ -722,7 +743,8 @@ public class RuntimeEntrypoints implemen
 
     // Sanity checking.
     // Hardware traps in uninterruptible code should be considered hard failures.
-    if (!VM.sysFailInProgress()) {
+    // Octet: support tolerating exceptions in uninterruptible code
+    if (!Octet.tolerateExceptionsInUninterruptibleCode() && !VM.sysFailInProgress()) {
       Address fp = exceptionRegisters.getInnermostFramePointer();
       int compiledMethodId = Magic.getCompiledMethodID(fp);
       if (compiledMethodId != INVISIBLE_METHOD_ID) {
@@ -762,6 +784,11 @@ public class RuntimeEntrypoints implemen
       }
     }
 
+    // Octet: support tolerating exceptions in uninterruptible code
+    if (Octet.tolerateExceptionsInUninterruptibleCode()) {
+      MemoryManager.startAllocatingInUninterruptibleCode();
+    }
+
     Throwable exceptionObject;
     switch (trapCode) {
       case TRAP_NULL_POINTER:
@@ -792,6 +819,11 @@ public class RuntimeEntrypoints implemen
         break;
     }
 
+    // Octet: support tolerating exceptions in uninterruptible code
+    if (Octet.tolerateExceptionsInUninterruptibleCode()) {
+      MemoryManager.stopAllocatingInUninterruptibleCode();
+    }
+
     VM.disableGC();  // VM.enableGC() is called when the exception is delivered.
     deliverException(exceptionObject, exceptionRegisters);
   }
@@ -812,6 +844,14 @@ public class RuntimeEntrypoints implemen
     ObjectModel.genericUnlock(objToUnlock);
     athrow(objToThrow);
   }
+  
+  // Velodrome: Uninstrumented version
+  @NoInline
+  @Entrypoint
+  static void unlockAndThrowWithoutInstrumentation(Object objToUnlock, Throwable objToThrow) {
+    ObjectModel.genericUnlockWithoutInstrumentation(objToUnlock);
+    athrow(objToThrow);
+  }
 
   /**
    * Create and throw a java.lang.ArrayIndexOutOfBoundsException.
@@ -912,6 +952,8 @@ public class RuntimeEntrypoints implemen
     BootRecord.the_boot_record.debugRequestedOffset = Entrypoints.debugRequestedField.getOffset();
   }
 
+  // Octet: Static cloning: Simplify method resolution below by simply ignoring it, since the method isn't used.
+
   /**
    * Build a multi-dimensional array.
    * @param methodId  TODO document me
@@ -920,8 +962,8 @@ public class RuntimeEntrypoints implemen
    * @return array object
    */
   public static Object buildMultiDimensionalArray(int methodId, int[] numElements, RVMArray arrayType) {
-    RVMMethod method = MemberReference.getMemberRef(methodId).asMethodReference().peekResolvedMethod();
-    if (VM.VerifyAssertions) VM._assert(method != null);
+    RVMMethod method = null;//MemberReference.getMemberRef(methodId).asMethodReference().peekResolvedMethod(null);
+    //if (VM.VerifyAssertions) VM._assert(method != null);
     return buildMDAHelper(method, numElements, 0, arrayType);
   }
 
@@ -934,8 +976,8 @@ public class RuntimeEntrypoints implemen
    * @return array object
    */
   public static Object buildTwoDimensionalArray(int methodId, int dim0, int dim1, RVMArray arrayType) {
-    RVMMethod method = MemberReference.getMemberRef(methodId).asMethodReference().peekResolvedMethod();
-    if (VM.VerifyAssertions) VM._assert(method != null);
+    RVMMethod method = null;//MemberReference.getMemberRef(methodId).asMethodReference().peekResolvedMethod(null);
+    //if (VM.VerifyAssertions) VM._assert(method != null);
 
     if (!arrayType.isInstantiated()) {
       arrayType.resolve();
@@ -1010,6 +1052,7 @@ public class RuntimeEntrypoints implemen
     if (VM.TraceExceptionDelivery) {
       VM.sysWriteln("RuntimeEntrypoints.deliverException() entered; just got an exception object.");
     }
+    
     //VM.sysWriteln("throwing exception!");
     //RVMThread.dumpStack();
 
@@ -1027,6 +1070,7 @@ public class RuntimeEntrypoints implemen
       if (!hijackedCalleeFp.isZero() && hijackedCalleeFp.LE(fp)) {
         leapfroggedReturnBarrier = true;
       }
+
       int compiledMethodId = Magic.getCompiledMethodID(fp);
       if (compiledMethodId != INVISIBLE_METHOD_ID) {
         CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
@@ -1034,18 +1078,20 @@ public class RuntimeEntrypoints implemen
         Address ip = exceptionRegisters.getInnermostInstructionAddress();
         Offset ipOffset = compiledMethod.getInstructionOffset(ip);
         int catchBlockOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, exceptionType);
-
+        
         if (catchBlockOffset >= 0) {
           // found an appropriate catch block
           if (VM.TraceExceptionDelivery) {
             VM.sysWriteln("found one; delivering.");
           }
+
           if (leapfroggedReturnBarrier) {
             RVMThread t = RVMThread.getCurrentThread();
             if (RVMThread.DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("leapfrogged...");
             t.deInstallStackTrampoline();
           }
           Address catchBlockStart = compiledMethod.getInstructionAddress(Offset.fromIntSignExtend(catchBlockOffset));
+          
           exceptionDeliverer.deliverException(compiledMethod, catchBlockStart, exceptionObject, exceptionRegisters);
           if (VM.VerifyAssertions) VM._assert(NOT_REACHED);
         }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/StackTrace.java workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/StackTrace.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/runtime/StackTrace.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/runtime/StackTrace.java	2014-04-03 17:43:47.755686103 -0400
@@ -286,7 +286,8 @@ public class StackTrace {
             int bci = map.getBytecodeIndexForMCOffset(instructionOffset);
             for (; iei >= 0; iei = OptEncodedCallSiteTree.getParent(iei, inlineEncoding)) {
               int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
-              RVMMethod method = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember();
+              // Octet: Static cloning: Support multiple resolved methods for every method reference.
+              RVMMethod method = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember(compiledMethod.getMethod().getStaticContext());
               int lineNumber = ((NormalMethod)method).getLineNumberForBCIndex(bci);
               elements[element] = new Element(method, lineNumber);
               element++;
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/MainThread.java workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/MainThread.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/MainThread.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/MainThread.java	2014-04-03 17:43:47.277684533 -0400
@@ -22,11 +22,13 @@ import org.jikesrvm.Callbacks;
 import org.jikesrvm.CommandLineArgs;
 import org.jikesrvm.VM;
 import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.classloader.Context;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMClassLoader;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.TypeReference;
 import org.jikesrvm.runtime.Reflection;
+import org.jikesrvm.velodrome.Velodrome;
 import org.vmmagic.pragma.Entrypoint;
 
 /**
@@ -178,6 +180,10 @@ public final class MainThread extends Th
       VM.sysWrite(cls + " doesn't have a \"public static void main(String[])\" method to execute\n");
       return;
     }
+    
+    // Velodrome: Context: main() method is always supposed to be non-atomic
+    if (VM.VerifyAssertions && Velodrome.isVelodromeEnabled()) { VM._assert(mainMethod.getMemberRef().asMethodReference().isNonAtomic); }
+    if (VM.VerifyAssertions && Velodrome.isVelodromeEnabled()) { VM._assert(mainMethod.getStaticContext() == Context.NONTRANS_CONTEXT); }
 
     if (dbg) VM.sysWrite("[MainThread.run() making arg list... ");
     // create "main" argument list
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/RVMThread.java workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/RVMThread.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/RVMThread.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/RVMThread.java	2014-04-03 17:43:47.275684527 -0400
@@ -12,50 +12,69 @@
  */
 package org.jikesrvm.scheduler;
 
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_METHOD_ID_OFFSET;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACK_SIZE_GUARD;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACK_SIZE_NORMAL;
+import static org.jikesrvm.runtime.SysCall.sysCall;
+
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import org.jikesrvm.ArchitectureSpecific;
+import org.jikesrvm.ArchitectureSpecific.BaselineConstants;
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.ArchitectureSpecific.Registers;
-import org.jikesrvm.ArchitectureSpecificOpt.PostThreadSwitch;
-import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACK_SIZE_NORMAL;
-import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
-import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
-import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACK_SIZE_GUARD;
-import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_METHOD_ID_OFFSET;
-import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET;
-import org.jikesrvm.ArchitectureSpecific.BaselineConstants;
-import org.jikesrvm.ArchitectureSpecific.ThreadLocalState;
 import org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants;
-import org.jikesrvm.ArchitectureSpecific;
-import org.jikesrvm.Constants;
-import org.jikesrvm.VM;
+import org.jikesrvm.ArchitectureSpecific.ThreadLocalState;
+import org.jikesrvm.ArchitectureSpecificOpt.PostThreadSwitch;
 import org.jikesrvm.Configuration;
+import org.jikesrvm.Constants;
 import org.jikesrvm.Services;
 import org.jikesrvm.UnimplementedError;
+import org.jikesrvm.VM;
+import org.jikesrvm.adaptive.OSRListener;
 import org.jikesrvm.adaptive.OnStackReplacementEvent;
 import org.jikesrvm.adaptive.measurements.RuntimeMeasurements;
+import org.jikesrvm.classloader.MemberReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.compilers.baseline.BaselineCompiledMethod;
 import org.jikesrvm.compilers.common.CompiledMethod;
 import org.jikesrvm.compilers.common.CompiledMethods;
-import org.jikesrvm.osr.ObjectHolder;
-import org.jikesrvm.adaptive.OSRListener;
+import org.jikesrvm.compilers.opt.runtimesupport.OptCompiledMethod;
+import org.jikesrvm.compilers.opt.runtimesupport.OptEncodedCallSiteTree;
+import org.jikesrvm.compilers.opt.runtimesupport.OptMachineCodeMap;
 import org.jikesrvm.jni.JNIEnvironment;
 import org.jikesrvm.mm.mminterface.CollectorThread;
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.mm.mminterface.ThreadContext;
 import org.jikesrvm.objectmodel.ObjectModel;
 import org.jikesrvm.objectmodel.ThinLockConstants;
+import org.jikesrvm.octet.Communication;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.OctetState;
+import org.jikesrvm.octet.Stats;
+import org.jikesrvm.osr.ObjectHolder;
+import org.jikesrvm.runtime.BootRecord;
 import org.jikesrvm.runtime.Entrypoints;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.Memory;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
 import org.jikesrvm.runtime.Time;
-import org.jikesrvm.runtime.BootRecord;
-import org.vmmagic.pragma.Inline;
+import org.jikesrvm.tuningfork.Feedlet;
+import org.jikesrvm.tuningfork.TraceEngine;
+import org.jikesrvm.velodrome.Transaction;
+import org.jikesrvm.velodrome.Velodrome;
+import org.jikesrvm.velodrome.VelodromeMetadataHelper;
 import org.vmmagic.pragma.BaselineNoRegisters;
 import org.vmmagic.pragma.BaselineSaveLSRegisters;
 import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.NoCheckStore;
 import org.vmmagic.pragma.NoInline;
 import org.vmmagic.pragma.NoOptCompile;
 import org.vmmagic.pragma.NonMoving;
@@ -64,20 +83,10 @@ import org.vmmagic.pragma.Uninterruptibl
 import org.vmmagic.pragma.Unpreemptible;
 import org.vmmagic.pragma.UnpreemptibleNoWarn;
 import org.vmmagic.pragma.Untraced;
-import org.vmmagic.pragma.NoCheckStore;
 import org.vmmagic.unboxed.Address;
-import org.vmmagic.unboxed.Word;
+import org.vmmagic.unboxed.ObjectReference;
 import org.vmmagic.unboxed.Offset;
-
-import static org.jikesrvm.runtime.SysCall.sysCall;
-import org.jikesrvm.classloader.RVMMethod;
-import org.jikesrvm.compilers.opt.runtimesupport.OptCompiledMethod;
-import org.jikesrvm.compilers.opt.runtimesupport.OptMachineCodeMap;
-import org.jikesrvm.compilers.opt.runtimesupport.OptEncodedCallSiteTree;
-import org.jikesrvm.classloader.MemberReference;
-import org.jikesrvm.classloader.NormalMethod;
-import org.jikesrvm.tuningfork.TraceEngine;
-import org.jikesrvm.tuningfork.Feedlet;
+import org.vmmagic.unboxed.Word;
 
 /**
  * A generic java thread's execution context.
@@ -151,6 +160,7 @@ import org.jikesrvm.tuningfork.Feedlet;
  * @see org.jikesrvm.adaptive.measurements.organizers.Organizer
  */
 @Uninterruptible
+// Octet: RVMThreads will actually be allocated into immortal space (see MemoryManager.pickAllocator* methods); see RVMThread.octetThreads
 @NonMoving
 public final class RVMThread extends ThreadContext implements Constants {
   /*
@@ -498,7 +508,8 @@ public final class RVMThread extends Thr
   /**
    * FP for current frame, saved in the prologue of every method
    */
-  Address framePointer;
+  // Octet: made public for debugging purposes
+  public Address framePointer;
 
   /**
    * "hidden parameter" for interface invocation thru the IMT
@@ -902,6 +913,14 @@ public final class RVMThread extends Thr
    */
   boolean hasInterrupt;
 
+  // Octet: Helps ensure takeYieldpoint and octetRequests are on the same cache line.
+  // There's an assertion below that checks that they are indeed on same cache line (actually the same aligned 8 bytes).
+  public int padding;
+  
+  // Velodrome: The assertion that takeYieldpoint and octetRequests are on the same cache line fails
+  private int dummy;
+
+  
   /**
    * Should the next executed yieldpoint be taken? Can be true for a variety of
    * reasons. See RVMThread.yieldpoint
@@ -927,6 +946,58 @@ public final class RVMThread extends Thr
   @Entrypoint
   public int takeYieldpoint;
 
+  // Octet: per-thread variables
+
+  /** Other threads communicate by modifying this variable.  */
+  @Entrypoint
+  public Word octetRequests;
+
+  /** The number of communication requests responded to. */
+  // Octet: TODO: should this be on a separate cache line?
+  public int octetResponses;
+  
+  /** Thread-local storage for the responding threads that were sent requests. */
+  public final RVMThread[] octetRespondingThreads;
+
+  /** Thread-local storage for the values of remote threads' request counters. */
+  public final int[] octetRespondingThreadCounters;
+  
+  /** The next element in a request queue.  The index used is the thread ID for the thread that owns the request queue. */
+  public final int[] nextRequestQueueThread = Octet.getConfig().doCommunication() && Octet.getClientAnalysis().needsCommunicationQueue() ? new int[MAX_THREADS] : null;
+
+  /** How many calls have blocked communication requests (allows re-entrant blocking)? */
+  public int octetBlockedCommunicationRequestDepth;
+  
+  /** Latest value of the global read-shared counter that's been received by this thread when reading a read-shared object */
+  public Word octetReadSharedCounter = OctetState.MAX_READ_SHARED;
+  
+  /** a pthread monitor to use for waiting */
+  public final Word octetMonitor = VM.runningVM ? sysCall.sysMonitorCreate() : Word.zero();
+  
+  // provide a unique thread ID for Octet threads only
+  public final int octetThreadID;
+  
+  /** next CPU ID to be bound to an Octet thread */
+  private static int nextCPUID = 0;
+
+  // Velodrome: Thread-local variable declarations 
+  /** Keeps track of the level of nesting of synchronized blocks/transactions */
+  private boolean isInTransaction;
+  /** Tracks the number of nodes (transactions) created for a thread, also doubles up the as unique 
+   * (per-thread) id generator for transactions */
+  // Should not matter if this starts from zero
+  public int numberOfNodes; 
+  /** Keep track of the last node in the graph, which also doubles up as the current transaction */
+  public Transaction currentTransaction;  
+  /** Monitor to serialize cycle detection */
+  public static Monitor velodromeCycleLock;
+  /** Monitor to atomically increment edge counter */ 
+  public static Monitor velodromeEdgeCounterLock;
+  /** Monitor to atomically print information */
+  public static Monitor velodromeOutputLock;
+  public boolean betweenPreAndPost;
+  public Word lockedMetadata;
+
   /**
    * How many times has the "timeslice" expired? This is only used for profiling
    * and OSR (in particular base-to-opt OSR).
@@ -1065,6 +1136,9 @@ public final class RVMThread extends Thr
   /** Lock used for dumping stack and such. */
   public static Monitor dumpLock;
 
+  /** Octet: special lock for Octet debugging output */
+  public static Monitor octetDumpLock; 
+  
   /** In dump stack and dying */
   protected static boolean exitInProgress = false;
 
@@ -1084,6 +1158,13 @@ public final class RVMThread extends Thr
 
   public static final int MAX_THREADS = 1 << LOG_MAX_THREADS;
 
+  /** Octet: array of all Octet threads, including those that have died.  Note that in Octet, RVMThread objects will die (become unreachable)
+      but the RVMThread object itself will still be kept in the heap.  Thus, you can use fields of, but don't expect reference fields
+      to point to anything.  This weird hack allows us to deal with the fact that WrEx/RdEx states might point to threads that have died. */
+  //@Untraced // because RVMThreads will never move and they'll never be collected, but we want *objects pointed to* by an RVMThread to be able to die
+  //public static final RVMThread[] octetThreads = new RVMThread[MAX_THREADS]; // might overflow because IDs are not reused
+  private static int nextOctetThreadID;
+  
   /**
    * thread array - all threads are stored in this array according to their
    * threadSlot.
@@ -1312,6 +1393,20 @@ public final class RVMThread extends Thr
         VM.sysWriteln("binding thread to CPU: ",VM.forceOneCPU);
       }
       bind(VM.forceOneCPU);
+    // Octet: Support binding Octet threads to cores
+    } else if (VM.octetForceHardAffinity && RVMThread.getCurrentThread().isOctetThread()) {
+      int cpuID;
+      acctLock.lockNoHandshake();
+      cpuID = nextCPUID;
+      nextCPUID++;
+      if (nextCPUID == RVMThread.availableProcessors) {
+        nextCPUID = 0;
+      }
+      acctLock.unlock();
+      if (traceBind) {
+        VM.sysWriteln("binding thread to CPU: ", cpuID);
+      }
+      bind(cpuID);
     }
   }
 
@@ -1323,6 +1418,14 @@ public final class RVMThread extends Thr
   public static void boot() {
     outOfMemoryError = new OutOfMemoryError();
     dumpLock = new Monitor();
+    // Octet: initialize output lock
+    octetDumpLock = new Monitor();
+
+    // Velodrome: Initialize the cycle lock
+    velodromeCycleLock = new Monitor();
+    velodromeEdgeCounterLock = new Monitor();
+    velodromeOutputLock = new Monitor();
+
     acctLock = new NoYieldpointsMonitor();
     debugLock = new NoYieldpointsMonitor();
     outputLock = new NoYieldpointsMonitor();
@@ -1596,7 +1699,50 @@ public final class RVMThread extends Thr
         // create wrapper Thread if doesn't exist
         this.thread = java.lang.JikesRVMSupport.createThread(this, name);
       }
+      
+      // Octet: make sure that takeYieldpoint and octetRequest are on the same cache line.
+      // For now, we'll just make sure they're in the same aligned 8 bytes
+      if (VM.VerifyAssertions) {
+        Word baseAddr = ObjectReference.fromObject(this).toAddress().toWord();
+        Word addr1 = baseAddr.plus(Entrypoints.takeYieldpointField.getOffset());
+        Word addr2 = baseAddr.plus(Entrypoints.octetRequestsField.getOffset());
+        VM._assert((addr1.toInt() & ~0x07) == (addr2.toInt() & ~0x7)); // make sure high 29 bits match
+      }
+    }
+
+    // Octet: assign a thread ID that's only for Octet threads and that's also unique.
+    // Octet threads are non-system threads plus the finalizer thread.
+    if (systemThread == null || systemThread instanceof FinalizerThread) {
+      acctLock.lockNoHandshake();
+      octetThreadID = nextOctetThreadID++;
+      //octetThreads[octetThreadID] = this;
+      acctLock.unlock();
+      octetRespondingThreads = new RVMThread[MAX_THREADS];
+      octetRespondingThreadCounters = new int[MAX_THREADS];
+      if (Octet.verbosity >= 2) {
+        octetDumpLock.lockNoHandshake();
+        VM.sysWriteln("T", octetThreadID, " (threadSlot=", threadSlot, ") started by T", RVMThread.getCurrentThread().octetThreadID);
+        octetDumpLock.unlock();
+      }
+    } else {
+      octetThreadID = -1;
+      octetRespondingThreads = null;
+      octetRespondingThreadCounters = null;
     }
+
+    // Velodrome: Initialize variables
+    isInTransaction = false;
+    numberOfNodes = Velodrome.START_TRANSACTION_ID; // Should not matter if this starts from zero
+    if (isOctetThread()) {
+      MemoryManager.startAllocatingInUninterruptibleCode();
+      currentTransaction = new Transaction(this, false, /*incomingEdge = */ -1);
+      MemoryManager.stopAllocatingInUninterruptibleCode();
+    } else {
+      currentTransaction = null;
+    }
+    betweenPreAndPost = false;
+    lockedMetadata = Word.zero();
+    
   }
 
   /**
@@ -2039,6 +2185,13 @@ public final class RVMThread extends Thr
     if (traceBlock)
       VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
           " is requesting that thread #", threadSlot, " blocks.");
+    
+    // Octet: block communication requests
+    if (Octet.getConfig().doCommunication()) {
+      Stats.blockCommThreadBlock.inc();
+      Communication.blockCommunicationRequests(true);
+    }
+
     monitor().lockNoHandshake();
     int token = ba.requestBlock(this);
     if (getCurrentThread() == this) {
@@ -2118,6 +2271,12 @@ public final class RVMThread extends Thr
       }
     }
     monitor().unlock();
+    
+    // Octet: unblock communication requests
+    if (Octet.getConfig().doCommunication()) {
+      Communication.unblockCommunicationRequests();
+    }
+
     if (traceReallyBlock)
       VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
           " is done telling thread #", threadSlot, " to block.");
@@ -2156,7 +2315,25 @@ public final class RVMThread extends Thr
     other.communicationLock().unlock();
     if (traceBlock) VM.sysWriteln("unpairing ",threadSlot," from ",other.threadSlot);
   }
-
+  
+  /** Velodrome: Check whether we are already in a transaction. */
+  @Inline
+  public boolean inTransaction() {
+    return isInTransaction;
+  }  
+  
+  @Inline
+  public void setInTransaction() {
+    if (VM.VerifyAssertions) { VM._assert(!inTransaction()); }
+    isInTransaction = true;
+  }
+  
+  @Inline
+  public void resetInTransaction() {
+    if (VM.VerifyAssertions) { VM._assert(inTransaction()); }
+    isInTransaction = false;
+  }
+  
   @Unpreemptible
   public void beginPairWithCurrent() {
     beginPairWith(getCurrentThread());
@@ -2192,6 +2369,11 @@ public final class RVMThread extends Thr
 
   @Unpreemptible
   public void beginPairHandshake() {
+    // Octet: entering blocked state (seems redundant but might help because beginPairWithCurrent can block) 
+    if (Octet.getConfig().doCommunication()) {
+      Stats.blockCommBeginPairHandshake.inc();
+      Communication.blockCommunicationRequests(true);
+    }
     beginPairWithCurrent();
     block(handshakeBlockAdapter);
   }
@@ -2200,6 +2382,11 @@ public final class RVMThread extends Thr
   public void endPairHandshake() {
     unblock(handshakeBlockAdapter);
     endPairWithCurrent();
+    
+    // Octet: leaving blocked state
+    if (Octet.getConfig().doCommunication()) {
+      Communication.unblockCommunicationRequests();
+    }
   }
 
   /**
@@ -2241,6 +2428,13 @@ public final class RVMThread extends Thr
         } else {
           t.assertAcceptableStates(IN_JAVA_TO_BLOCK);
           t.enterNativeBlocked();
+          
+          // Octet: enter blocked state
+          if (Octet.getConfig().doCommunication()) {
+            Stats.blockCommEnterNative.inc();
+            Communication.blockCommunicationRequests(true);
+          }
+
           return;
         }
       } while (!(t.attemptFastExecStatusTransition(oldState, newState)));
@@ -2250,6 +2444,11 @@ public final class RVMThread extends Thr
     // set it to whatever they want.
     //if (VM.VerifyAssertions)
     //  VM._assert(t.execStatus == IN_NATIVE);
+    
+    // Octet: enter blocked state
+    if (Octet.getConfig().doCommunication()) {
+      Communication.blockCommunicationRequests(true);
+    }
   }
 
   /**
@@ -2272,6 +2471,12 @@ public final class RVMThread extends Thr
         return false;
       }
     } while (!(t.attemptFastExecStatusTransition(oldState, newState)));
+    
+    // Octet: unblock communication requests (only if we're succeeding)
+    if (Octet.getConfig().doCommunication()) {
+      Communication.unblockCommunicationRequests();
+    }
+
     return true;
   }
 
@@ -2289,6 +2494,11 @@ public final class RVMThread extends Thr
             " is leaving native blocked");
       }
       getCurrentThread().leaveNativeBlocked();
+
+      // Octet: unblock communication requests (only needed if attemptLeaveNativeNoBlock() returns false)
+      if (Octet.getConfig().doCommunication()) {
+        Communication.unblockCommunicationRequests();
+      }
     }
   }
 
@@ -2299,6 +2509,12 @@ public final class RVMThread extends Thr
         RVMThread.IN_JNI)) {
       RVMThread.enterJNIBlockedFromCallIntoNative();
     }
+    
+    // Octet: enter blocked state
+    if (Octet.getConfig().doCommunication()) {
+      Stats.blockCommEnterJNIFromCallIntoNative.inc();
+      Communication.blockCommunicationRequests(true);
+    }
   }
 
   @Unpreemptible
@@ -2309,6 +2525,11 @@ public final class RVMThread extends Thr
         RVMThread.IN_JAVA)) {
       RVMThread.leaveJNIBlockedFromCallIntoNative();
     }
+    
+    // Octet: leave blocked state
+    if (Octet.getConfig().doCommunication()) {
+      Communication.unblockCommunicationRequests();
+    }
   }
 
   public static void enterJNIFromJNIFunctionCall() {
@@ -2319,6 +2540,12 @@ public final class RVMThread extends Thr
         RVMThread.IN_JNI)) {
       RVMThread.enterJNIBlockedFromJNIFunctionCall();
     }
+    
+    // Octet: enter blocked state
+    if (Octet.getConfig().doCommunication()) {
+      Stats.blockCommEnterJNIFromJNIFunctionCall.inc();
+      Communication.blockCommunicationRequests(true);
+    }
   }
 
   @Unpreemptible
@@ -2330,6 +2557,11 @@ public final class RVMThread extends Thr
         RVMThread.IN_JAVA)) {
       RVMThread.leaveJNIBlockedFromJNIFunctionCall();
     }
+    
+    // Octet: leave blocked state
+    if (Octet.getConfig().doCommunication()) {
+      Communication.unblockCommunicationRequests();
+    }
   }
 
   public void unblock(BlockAdapter ba) {
@@ -2356,6 +2588,15 @@ public final class RVMThread extends Thr
         asyncDebugRequestedForThisThread = true;
         takeYieldpoint = 1;
         VM.sysWriteln("(stack trace will follow if thread is not lost...)");
+
+        // Velodrome: Debugging why Jikes gets stuck
+        RVMThread.dumpStack(this.framePointer);
+        
+        // Octet: Force printing of stack trace.
+        // Octet: TODO: It would be better to wait and print only the stacks
+        // for threads that can't reach a yield point on their own.
+        Stats.tryToPrintStack(this.framePointer);
+        
       } else {
         if (contextRegisters != null) {
           dumpStack(contextRegisters.getInnermostFramePointer());
@@ -2456,6 +2697,12 @@ public final class RVMThread extends Thr
   public static int getCurrentThreadSlot() {
     return getCurrentThread().threadSlot;
   }
+  
+  // Velodrome: Adding a helper method
+  /** Get the thread slot for a given thread */
+  public int getGivenThreadSlot() {
+    return this.threadSlot;
+  }
 
   /**
    * @return the slot of this thread
@@ -2601,6 +2848,15 @@ public final class RVMThread extends Thr
       VM.sysWriteln("Thread.startoff(): about to call ", currentThread.toString(), ".run()");
     }
 
+    // Octet: Update count of live threads.  This stat is unsynchronized, so it needs to execute while acctLock is held
+    if (currentThread.isOctetThread()) {
+      if (Octet.getConfig().stats()) {
+        acctLock.lockNoHandshake();
+        Stats.threadsLive.inc();
+        acctLock.unlock();
+      }
+    }
+
     try {
       if (currentThread.systemThread != null) {
         currentThread.systemThread.run();
@@ -2657,6 +2913,12 @@ public final class RVMThread extends Thr
       VM.enableGC();
     }
 
+    // Octet: handle Octet and client-specfic thread termination
+    if (VM.VerifyAssertions) { VM._assert(this == RVMThread.getCurrentThread()); }
+    if (isOctetThread()) {
+      Octet.getClientAnalysis().handleThreadTerminationEarly();
+    }
+    
     // allow java.lang.Thread.exit() to remove this thread from ThreadGroup
     java.lang.JikesRVMSupport.threadDied(thread);
 
@@ -2673,6 +2935,11 @@ public final class RVMThread extends Thr
       VM.sysWriteln("doing accounting...");
     acctLock.lockNoHandshake();
 
+    // Octet: Thread accounting.  This stat is unsynchronized, so it needs to execute while acctLock is held.
+    if (isOctetThread()) {
+      Stats.threadsLive.dec();
+    }
+
     // if the thread terminated because of an exception, remove
     // the mark from the exception register object, or else the
     // garbage collector will attempt to relocate its ip field.
@@ -2782,6 +3049,13 @@ public final class RVMThread extends Thr
    */
   @Unpreemptible
   private void terminateUnpreemptible() {
+    
+    // Octet: handle Octet and client-specfic thread termination
+    if (VM.VerifyAssertions) { VM._assert(this == RVMThread.getCurrentThread()); }
+    if (isOctetThread()) {
+      Octet.getClientAnalysis().handleThreadTerminationLate();
+    }
+
     // return cached free lock
     if (traceAcct)
       VM.sysWriteln("returning cached lock...");
@@ -3191,6 +3465,15 @@ public final class RVMThread extends Thr
         // is this where the problem is coming from?
         toAwaken.monitor().lockedBroadcastNoHandshake();
       }
+      
+      // Velodrome: Tracking Thread::wait()
+      if (Velodrome.trackThreadSynchronizationPrimitives()) { 
+        if (VM.VerifyAssertions) { VM._assert(Velodrome.addMiscHeader()); }
+        if (RVMThread.getCurrentThread().isOctetThread()) {
+          VelodromeMetadataHelper.trackLockAcquire(o);
+        }
+      }
+
       // block
       monitor().lockNoHandshake();
       while (l.waiting.isQueued(this) && !hasInterrupt && asyncThrowable == null &&
@@ -3309,6 +3592,15 @@ public final class RVMThread extends Thr
     if (owner != me) {
       raiseIllegalMonitorStateException("notifying (expected lock to be held by "+me+"("+getCurrentThread().getLockingId()+") but was held by "+owner+"("+l.getOwnerId()+")) ", o);
     }
+    
+    // Velodrome: Tracking Thread::notify()
+    if (Velodrome.trackThreadSynchronizationPrimitives()) { 
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.addMiscHeader()); }
+      if (RVMThread.getCurrentThread().isOctetThread()) {
+        VelodromeMetadataHelper.trackLockRelease(o);
+      }
+    }
+
     l.mutex.lock();
     RVMThread toAwaken = l.waiting.dequeue();
     l.mutex.unlock();
@@ -3336,6 +3628,15 @@ public final class RVMThread extends Thr
     if (owner != getCurrentThread().getLockingId()) {
       raiseIllegalMonitorStateException("notifying all (expected lock to be held by "+getCurrentThread().getLockingId()+" but was held by "+l.getOwnerId()+") ", o);
     }
+    
+    // Velodrome: Tracking Thread::notifyAll()
+    if (Velodrome.trackThreadSynchronizationPrimitives()) { 
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.addMiscHeader()); }
+      if (RVMThread.getCurrentThread().isOctetThread()) {
+        VelodromeMetadataHelper.trackLockRelease(o);
+      }
+    }
+
     for (;;) {
       l.mutex.lock();
       RVMThread toAwaken = l.waiting.dequeue();
@@ -3923,10 +4224,22 @@ public final class RVMThread extends Thr
     int takeYieldpointVal = t.takeYieldpoint;
     if (takeYieldpointVal != 0) {
       t.takeYieldpoint = 0;
+      
+      // Octet: check for communication requests and also block them until after checkBlock below
+      if (Octet.getConfig().doCommunication()) {
+        Stats.blockCommYieldpoint.inc();
+        Communication.blockCommunicationRequests(true);
+      }
+
       // do two things: check if we should be blocking, and act upon
       // handshake requests. This also has the effect of reasserting that
       // we are in fact IN_JAVA (as opposed to IN_JAVA_TO_BLOCK).
       t.checkBlock();
+      
+      // Octet: unblock communication requests
+      if (Octet.getConfig().doCommunication()) {
+        Communication.unblockCommunicationRequests();
+      }
 
       // Process timer interrupt event
       if (t.timeSliceExpired != 0) {
@@ -4351,6 +4664,11 @@ public final class RVMThread extends Thr
     return systemThread != null;
   }
 
+  // Octet: is this a thread that Octet cares about?
+  public final boolean isOctetThread() {
+    return octetThreadID >= 0;
+  }
+
   /** Get the collector thread this RVMTHread is running */
   public CollectorThread getCollectorThread() {
     if (VM.VerifyAssertions) VM._assert(isCollectorThread());
@@ -4524,6 +4842,9 @@ public final class RVMThread extends Thr
       VM._assert(myThread != this);
     if (traceBlock)
       VM.sysWriteln("Joining on Thread #", threadSlot);
+    
+    // Velodrome: We do not track join() since it calls wait()
+    
     // this uses synchronized because we cannot have one thread acquire
     // another thread's lock using the WithHandshake scheme, as that would result
     // in a thread holding two threads' monitor()s.  using synchronized
@@ -4765,6 +5086,8 @@ public final class RVMThread extends Thr
   public void extDump() {
     dump();
     VM.sysWriteln();
+    // Velodrome: Printing thread name
+    VM.sysWriteln("Thread Name: ", RVMThread.getCurrentThread().name);
     VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
     VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
     VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
@@ -4864,6 +5187,11 @@ public final class RVMThread extends Thr
     if (isCollectorThread()) {
       offset = Services.sprintf(dest, offset, "-collector"); // gc thread?
     }
+    // Velodrome: Debug information
+    if (isOctetThread()) {
+      offset = Services.sprintf(dest, offset, "-octet#"); // Octet (application + finalizer) thread
+      offset = Services.sprintf(dest, offset, this.octetThreadID); // Octet (application + finalizer) thread
+    }
     offset = Services.sprintf(dest, offset, "-");
     offset = Services.sprintf(dest, offset, getExecStatus());
     offset = Services.sprintf(dest, offset, "-");
@@ -5030,23 +5358,30 @@ public final class RVMThread extends Thr
     }
   }
 
+  // Velodrome: Debugging changes
   static void tracebackWithoutLock() {
     if (VM.runningVM) {
-      VM.sysWriteln("Thread #", getCurrentThreadSlot());
+      VM.sysWrite("Thread #", getCurrentThreadSlot());
+      VM.sysWriteln(" Octet Thread ID:", getCurrentThread().octetThreadID);
       dumpStack(Magic.getCallerFramePointer(Magic.getFramePointer()));
     } else {
       dumpStack();
     }
   }
 
+  // Velodrome: Debugging changes
   /**
    * Dump stack of calling thread, starting at callers frame
    */
   @UninterruptibleNoWarn("Never blocks")
   public static void dumpStack() {
     if (VM.runningVM) {
-      VM.sysWriteln("Dumping stack for Thread #", getCurrentThreadSlot());
+      VM.sysWrite("Dumping stack for Thread #", getCurrentThreadSlot());
+      // Velodrome: Printing additional debugging information
+      VM.sysWrite(", Octet Thread ID:", getCurrentThread().octetThreadID);
+      VM.sysWriteln(", Current thread transaction depth:", getCurrentThread().inTransaction());
       dumpStack(Magic.getFramePointer());
+      VM.sysWriteln(); // Velodrome: Added this to format the output better
     } else {
       StackTraceElement[] elements = (new Throwable(
           "--traceback from Jikes RVM's RVMThread class--")).getStackTrace();
@@ -5071,6 +5406,8 @@ public final class RVMThread extends Thr
     dumpStack(ip, fp);
   }
 
+  // Octet: Added printing of bytecode indices below.
+
   /**
    * Dump state of a (stopped) thread's stack.
    *
@@ -5139,9 +5476,10 @@ public final class RVMThread extends Thr
                     int bci = map.getBytecodeIndexForMCOffset(instructionOffset);
                     for (; iei >= 0; iei = OptEncodedCallSiteTree.getParent(iei, inlineEncoding)) {
                       int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
-                      method = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember();
+                      // Octet: Static cloning: Support multiple resolved methods for every method reference.
+                      method = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember(compiledMethod.getMethod().getStaticContext());
                       lineNumber = ((NormalMethod) method).getLineNumberForBCIndex(bci);
-                      showMethod(method, lineNumber, fp);
+                      showMethod(method, lineNumber, bci, fp);
                       if (iei > 0) {
                         bci = OptEncodedCallSiteTree.getByteCodeOffset(iei, inlineEncoding);
                       }
@@ -5150,7 +5488,11 @@ public final class RVMThread extends Thr
                   }
                 }
                 if (!frameShown) {
-                  showMethod(method, lineNumber, fp);
+                  int bci = -1;
+                  if (compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+                    bci = ((BaselineCompiledMethod)compiledMethod).findBytecodeIndexForInstruction(instructionOffset);
+                  }
+                  showMethod(method, lineNumber, bci, fp);
                 }
               }
             }
@@ -5240,7 +5582,7 @@ public final class RVMThread extends Thr
    * Helper function for {@link #dumpStack(Address,Address)}. Print a stack
    * frame showing the method.
    */
-  private static void showMethod(RVMMethod method, int lineNumber, Address fp) {
+  private static void showMethod(RVMMethod method, int lineNumber, int bci, Address fp) {
     showPrologue(fp);
     if (method == null) {
       VM.sysWrite("<unknown method>");
@@ -5254,7 +5596,8 @@ public final class RVMThread extends Thr
       VM.sysWrite(" at line ");
       VM.sysWriteInt(lineNumber);
     }
-    VM.sysWrite("\n");
+    VM.sysWrite(" (at bci ", bci);
+    VM.sysWrite(")\n");
   }
 
   /**
@@ -5345,6 +5688,8 @@ public final class RVMThread extends Thr
         if (thr.contextRegisters != null && !thr.ignoreHandshakesAndGC())
           dumpStack(thr.contextRegisters.getInnermostFramePointer());
       }
+      // Velodrome: Adding new line for better formatting
+      VM.sysWriteln();
     }
     getCurrentThread().enableYieldpoints();
     Monitor.unlock(b, dumpLock);
@@ -5409,4 +5754,22 @@ public final class RVMThread extends Thr
     sloppyExecStatusHistogram[oldState]++;
     sloppyExecStatusHistogram[newState]++;
   }
+  
+  // Velodrome: Adding debug method to dump only Octet threads
+  public static void dumpOctetThreads() {
+    octetDumpLock.lockNoHandshake();
+    // Scan RVMThread.threads (scan down so we don't miss anything), see comment for threads[]
+    for (int i = RVMThread.numThreads-1; i >= 0; i--) {
+      Magic.sync();
+      RVMThread t = RVMThread.threads[i];
+      if (t.isOctetThread()) {
+        t.dump();
+        if (t.contextRegisters != null && !t.ignoreHandshakesAndGC())
+          dumpStack(t.contextRegisters.getInnermostFramePointer());
+        VM.sysWriteln();
+      }
+    }
+    octetDumpLock.unlock();
+  }
+  
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/Synchronization.java workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/Synchronization.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/Synchronization.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/Synchronization.java	2014-04-03 17:43:47.275684527 -0400
@@ -39,6 +39,7 @@ public class Synchronization {
    */
   @Inline
   public static boolean tryCompareAndSwap(Object base, Offset offset, int testValue, int newValue) {
+    // Octet: TODO: need to instrument this access
     if (Barriers.NEEDS_INT_PUTFIELD_BARRIER || Barriers.NEEDS_INT_GETFIELD_BARRIER) {
       return Barriers.intTryCompareAndSwap(base, offset, testValue, newValue);
     } else {
@@ -65,6 +66,7 @@ public class Synchronization {
    */
   @Inline
   public static boolean tryCompareAndSwap(Object base, Offset offset, long testValue, long newValue) {
+    // Octet: TODO: may need to instrument this access
     if (Barriers.NEEDS_LONG_PUTFIELD_BARRIER || Barriers.NEEDS_LONG_GETFIELD_BARRIER) {
       return Barriers.longTryCompareAndSwap(base, offset, testValue, newValue);
     } else {
@@ -144,6 +146,7 @@ public class Synchronization {
    */
   @Inline
   public static boolean tryCompareAndSwap(Object base, Offset offset, Object testValue, Object newValue) {
+    // Octet: TODO: need to instrument this access
     if (Barriers.NEEDS_OBJECT_PUTFIELD_BARRIER || Barriers.NEEDS_OBJECT_GETFIELD_BARRIER) {
       return Barriers.objectTryCompareAndSwap(base, offset, testValue, newValue);
     } else {
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/ThinLock.java workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/ThinLock.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/scheduler/ThinLock.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/scheduler/ThinLock.java	2014-04-03 17:43:47.277684533 -0400
@@ -12,10 +12,15 @@
  */
 package org.jikesrvm.scheduler;
 
-import org.jikesrvm.VM;
 import org.jikesrvm.Services;
+import org.jikesrvm.VM;
 import org.jikesrvm.objectmodel.ThinLockConstants;
+import org.jikesrvm.octet.Communication;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.Stats;
 import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.velodrome.Velodrome;
+import org.jikesrvm.velodrome.VelodromeMetadataHelper;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.NoInline;
 import org.vmmagic.pragma.NoNullCheck;
@@ -32,10 +37,32 @@ public final class ThinLock implements T
 
   private static final boolean ENABLE_BIASED_LOCKING = true;
 
+  // Velodrome: Lock acquire() with instrumentation
   @Inline
   @NoNullCheck
   @Unpreemptible
   public static void inlineLock(Object o, Offset lockOffset) {
+    inlineLockHelper(o, lockOffset);
+    if (Velodrome.trackSynchronizationPrimitives()) {
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.addMiscHeader()); }
+      if (RVMThread.getCurrentThread().isOctetThread()) {
+        VelodromeMetadataHelper.trackLockAcquire(o);
+      }
+    }
+  }
+  
+  // Velodrome: Lock acquire() without instrumentation
+  @Inline
+  @NoNullCheck
+  @Unpreemptible
+  public static void inlineLockWithoutInstrumentation(Object o, Offset lockOffset) {
+    inlineLockHelper(o, lockOffset);
+  }
+  
+  @Inline
+  @NoNullCheck
+  @Unpreemptible
+  public static void inlineLockHelper(Object o, Offset lockOffset) {
     Word old = Magic.prepareWord(o, lockOffset); // FIXME: bad for PPC?
     Word id = old.and(TL_THREAD_ID_MASK.or(TL_STAT_MASK));
     Word tid = Word.fromIntSignExtend(RVMThread.getCurrentThread().getLockingId());
@@ -55,10 +82,32 @@ public final class ThinLock implements T
     lock(o, lockOffset);
   }
 
+  // Velodrome: Lock release() with instrumentation
   @Inline
   @NoNullCheck
   @Unpreemptible
   public static void inlineUnlock(Object o, Offset lockOffset) {
+    if (Velodrome.trackSynchronizationPrimitives()) {
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.addMiscHeader()); }
+      if (RVMThread.getCurrentThread().isOctetThread()) {
+          VelodromeMetadataHelper.trackLockRelease(o);
+        }
+    }
+    inlineUnlockHelper(o, lockOffset);
+  }
+  
+  // Velodrome: Lock release() without instrumentation
+  @Inline
+  @NoNullCheck
+  @Unpreemptible
+  public static void inlineUnlockWithoutInstrumentation(Object o, Offset lockOffset) {
+    inlineUnlockHelper(o, lockOffset);
+  }  
+
+  @Inline
+  @NoNullCheck
+  @Unpreemptible
+  public static void inlineUnlockHelper(Object o, Offset lockOffset) {
     Word old = Magic.prepareWord(o, lockOffset); // FIXME: bad for PPC?
     Word id = old.and(TL_THREAD_ID_MASK.or(TL_STAT_MASK));
     Word tid = Word.fromIntSignExtend(RVMThread.getCurrentThread().getLockingId());
@@ -165,7 +214,20 @@ public final class ThinLock implements T
           return;
         }
       } else {
+
+        // Octet: before and after yielding, enter and leave the blocked state
+
+        if (Octet.getConfig().doCommunication()) {
+          Stats.blockCommLock.inc();
+          Communication.blockCommunicationRequests(true);
+        }
+
         RVMThread.yieldNoHandshake();
+
+        if (Octet.getConfig().doCommunication()) {
+          Communication.unblockCommunicationRequests();
+        }
+
       }
     }
   }
@@ -243,7 +305,19 @@ public final class ThinLock implements T
           return result;
         }
       }
+
+      // Octet: before and after yielding, enter and leave the blocked state
+
+      if (Octet.getConfig().doCommunication()) {
+        Stats.blockCommHoldsLock.inc();
+        Communication.blockCommunicationRequests(true);
+      }
+
       RVMThread.yieldNoHandshake();
+
+      if (Octet.getConfig().doCommunication()) {
+        Communication.unblockCommunicationRequests();
+      }
     }
   }
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/util/AbstractHashMapRVM.java workspace/velodrome-sound/rvm/src/org/jikesrvm/util/AbstractHashMapRVM.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/util/AbstractHashMapRVM.java	2013-02-12 13:28:50.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/util/AbstractHashMapRVM.java	2014-04-03 17:43:46.739682765 -0400
@@ -155,6 +155,14 @@ abstract class AbstractHashMapRVM<K, V> 
     }
   }
 
+  /** Octet: added removeAll operation */
+  public final void removeAll() {
+    for (int i = 0; i < buckets.length; i++) {
+      buckets[i] = null;
+    }
+    numElems = 0;
+  }
+  
   public final Iterator<V> valueIterator() {
     return new ValueIterator();
   }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/BenchmarkInfo.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/BenchmarkInfo.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/BenchmarkInfo.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/BenchmarkInfo.java	2014-04-03 17:43:49.595692148 -0400
@@ -0,0 +1,128 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Atom;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+
+/** This class is to abstract manipulating benchmark information 
+ *  DaCapo 2006-MR2         -         1
+ *  DaCapo 9.12-bach        -         2
+ *  Java Grande             -         3
+ *  ETHZ                    -         4
+ *  PseudoJbb               -         5
+ *  Miscellaneous           -         6
+ *  Microbenchmarks         -         9
+ *  
+ *  Please note that this class can perform no meaningful validity checks on the inputs.
+ * */
+@Uninterruptible
+public final class BenchmarkInfo {
+
+  /*****************************************************************************************/
+  // DaCapo 2006
+  static final int ECLIPSE6 = 11;
+  static final int HSQLDB6 = 12;
+  static final int XALAN6 = 13;
+  static final int LUSEARCH6 = 14;
+  
+  // DaCapo 2009
+  static final int AVRORA9 = 21;
+  static final int LUINDEX9 = 22;
+  static final int LUSEARCH9_FIXED = 23;
+  static final int PMD9 = 24;
+  static final int SUNFLOW9 = 25;
+  static final int XALAN9 = 26;
+  static final int JYTHON9 = 27;
+  
+  // Java Grande
+  static final int MOLDYN = 31;
+  static final int MONTECARLO = 32;
+  static final int RAYTRACER = 33;
+
+  // ETH Zurich
+  static final int ELEVATOR = 41;
+  static final int PHILO = 42;
+  static final int SOR = 43;
+  static final int HEDC = 44;
+  static final int TSP = 45;
+  
+  // Pseudojbb
+  static final int PSEUDOJBB2000 = 51;
+  static final int PSEUDOJBB2005 = 52;
+  
+  // Misc
+  static final int RAJA = 61;
+  
+  // Micro
+  static final int MICRO = 101;
+  
+  static final int INVALID = -1;
+  /*****************************************************************************************/
+  
+  private Atom name;
+  private int id;
+  
+  public BenchmarkInfo() {
+    name = Atom.findOrCreateAsciiAtom(VM.benchmarkName);
+    if (VM.VerifyAssertions) { VM._assert(name != null && name.length() > 0); }
+    
+    // DaCapo 2006
+    if (VM.benchmarkName.equalsIgnoreCase("ECLIPSE6")) { id = ECLIPSE6; }
+    else if (VM.benchmarkName.equalsIgnoreCase("HSQLDB6")) { id = HSQLDB6; }
+    else if (VM.benchmarkName.equalsIgnoreCase("LUSEARCH6")) { id = LUSEARCH6; }
+    else if (VM.benchmarkName.equalsIgnoreCase("XALAN6")) { id = XALAN6; }
+    
+    // DaCapo 2009
+    else if (VM.benchmarkName.equalsIgnoreCase("AVRORA9")) { id = AVRORA9; }
+    else if (VM.benchmarkName.equalsIgnoreCase("JYTHON9")) { id = JYTHON9; }
+    else if (VM.benchmarkName.equalsIgnoreCase("LUINDEX9")) { id = LUINDEX9; }
+    else if (VM.benchmarkName.equalsIgnoreCase("LUSEARCH9-FIXED")) { id = LUSEARCH9_FIXED; }
+    else if (VM.benchmarkName.equalsIgnoreCase("PMD9")) { id = PMD9; }
+    else if (VM.benchmarkName.equalsIgnoreCase("SUNFLOW9")) { id = SUNFLOW9; }
+    else if (VM.benchmarkName.equalsIgnoreCase("XALAN9")) { id = XALAN9; }
+    
+    // Java Grande
+    else if (VM.benchmarkName.equalsIgnoreCase("MOLDYN")) { id = MOLDYN; }
+    else if (VM.benchmarkName.equalsIgnoreCase("MONTECARLO")) { id = MONTECARLO; }
+    else if (VM.benchmarkName.equalsIgnoreCase("RAYTRACER")) { id = RAYTRACER; }
+    
+    // ETH Zurich
+    else if (VM.benchmarkName.equalsIgnoreCase("ELEVATOR")) { id = ELEVATOR; }
+    else if (VM.benchmarkName.equalsIgnoreCase("PHILO")) { id = PHILO; }
+    else if (VM.benchmarkName.equalsIgnoreCase("HEDC")) { id = HEDC; }
+    else if (VM.benchmarkName.equalsIgnoreCase("SOR")) { id = SOR; }
+    else if (VM.benchmarkName.equalsIgnoreCase("TSP")) { id = TSP; }
+    
+    // Pseudojbb
+    else if (VM.benchmarkName.equalsIgnoreCase("PSEUDOJBB2000")) { id = PSEUDOJBB2000; }
+    else if (VM.benchmarkName.equalsIgnoreCase("PSEUDOJBB2005")) { id = PSEUDOJBB2005; }
+    
+    // Misc
+    else if (VM.benchmarkName.equalsIgnoreCase("RAJA")) { id = RAJA; }
+    
+    // Micro
+    else { id = MICRO; }
+  }
+  
+  @Inline
+  Atom getName() {
+    return name;
+  }
+  
+  @Inline
+  public int getId() {
+    return id;
+  }
+
+  @Inline
+  boolean isDaCapoBenchmark() {
+    return (id >= 11 && id < 30);
+  }
+  
+  @Inline
+  boolean isMicroBenchmark() {
+    return (id >= 101);
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/ReadHashMapElement.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/ReadHashMapElement.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/ReadHashMapElement.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/ReadHashMapElement.java	2014-04-03 17:43:49.595692148 -0400
@@ -0,0 +1,41 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.VM;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+
+/** This class tracks the last read access information for a field/static per thread */
+@Uninterruptible
+public class ReadHashMapElement {
+
+  Transaction transaction;
+  int lastReadSiteID;
+  ReadHashMapElement next;
+  
+  public ReadHashMapElement(Transaction n, int siteID) {
+    transaction = n;
+    lastReadSiteID = siteID;
+    next = null;
+  }
+  
+  public ReadHashMapElement(Transaction n, int siteID, ReadHashMapElement nx) {
+    transaction = n;
+    lastReadSiteID =  siteID;
+    next = nx;
+  }
+  
+  public void setNext(ReadHashMapElement next) {
+    this.next = next;
+  }
+  
+  @Inline
+  public Transaction getTransaction() {
+    return transaction;
+  }
+
+  public void setTransaction(Object object) {
+    if (VM.VerifyAssertions) { VM._assert(object != null); }
+    transaction = (Transaction) object;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/ReadHashMap.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/ReadHashMap.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/ReadHashMap.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/ReadHashMap.java	2014-04-03 17:43:49.593692144 -0400
@@ -0,0 +1,204 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoCheckStore;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
+import org.vmmagic.unboxed.ObjectReference;
+
+/** Map from ReadHashMapElement to transactions. Note that each bucket is a set, that is it will contain
+ *  one and only one element with a given key. The key is the thread id. */
+@Uninterruptible
+public final class ReadHashMap {
+  
+  /** Array of buckets */
+  ReadHashMapElement[] data; 
+
+  /** Stores the length of the array, this helps avoid calling {@code length() }. */
+  int length; 
+  
+  public static int INITIAL_NUMBER_THREADS = 4;
+  
+  private ReadHashMap(int length) {
+    this.data = newArray(length);
+    this.length = length;
+  }
+
+  @UninterruptibleNoWarn
+  static ReadHashMap newReadHashMap() {
+    ReadHashMap map;
+    MemoryManager.startAllocatingInUninterruptibleCode();
+    map = new ReadHashMap(INITIAL_NUMBER_THREADS);
+    MemoryManager.stopAllocatingInUninterruptibleCode();
+    return map;
+  }
+  
+  @UninterruptibleNoWarn
+  ReadHashMapElement[] newArray(int length) {
+    ReadHashMapElement[] array;
+    MemoryManager.startAllocatingInUninterruptibleCode();
+    array = new ReadHashMapElement[length];
+    MemoryManager.stopAllocatingInUninterruptibleCode();
+    return array;
+  }
+  
+  @UninterruptibleNoWarn
+  static ReadHashMapElement newReadHashMapElement(Transaction tx, int siteID) {
+    ReadHashMapElement elem;
+    MemoryManager.startAllocatingInUninterruptibleCode();
+    elem = new ReadHashMapElement(tx, siteID);
+    MemoryManager.stopAllocatingInUninterruptibleCode();
+    return elem;
+  }
+  
+  public int getKey(ReadHashMapElement value) {
+    if (VM.VerifyAssertions) { 
+      if (value.transaction == null) {
+        VM.sysWriteln("Transaction address:", ObjectReference.fromObject(value.transaction).toAddress());
+        VM.sysWriteln("Read hash map address:", ObjectReference.fromObject(this).toAddress());
+      }
+      VM._assert(value.transaction != null); 
+    }
+    return value.transaction.octetThread.octetThreadID;
+  }
+  
+  /** This method returns the bucket head. 
+   *  @param key It is not the index
+   *  @return the start pointer to the contents of the bucket indexed by {@code key}. Note that the returned value 
+   *  could be {@code null} */
+  @NoCheckStore // Velodrome: TODO: This is a load
+  public ReadHashMapElement getBucketHead(int key) {
+    if (VM.VerifyAssertions) { VM._assert(length == data.length); }
+    int index = key % length;
+    ReadHashMapElement tmp = data[index];
+    return tmp;
+  }
+  
+  @Inline
+  ReadHashMapElement get(int key) {
+    ReadHashMapElement tmp = getBucketHead(key);
+    while (tmp != null && getKey(tmp) != key) {
+      tmp = getNext(tmp);
+    }
+    return tmp;
+  }
+  
+  /** Check if the read map contains an element with key {@code threadID} with a matching
+   *  transaction id {@code txID}. We avoid constructing a hash map object. */
+  @NoCheckStore
+  // Velodrome: This method will contain a checkcast if the type of 'data' if different from a ReadHashMapElement,    
+  // because of the array load. The checkcast allows a yieldpoint. This means that GC can happen while executing 
+  // this method. That will cause problems since the write metadata at this point is a garbage reference.
+  // To avoid the checkcast, we have now used an array of the same type as ReadHashMapElement.
+  boolean contains(int threadID, int txID) {
+    boolean present = false;
+    if (VM.VerifyAssertions) { VM._assert(length == data.length); }
+    int key = threadID;
+    int index = key % length;
+    ReadHashMapElement tmp = data[index];
+    if (tmp == null) {
+      return false;
+    }
+    if (getKey(tmp) == key) { // Same thread
+      if (VM.VerifyAssertions) { VM._assert(tmp.transaction.transactionID <= txID); }
+      if (tmp.transaction.transactionID == txID) { // Tx already present in map
+        present = true;
+      }
+    } else {
+      while (getKey(tmp) != key) {
+        tmp = getNext(tmp);
+        if (tmp == null) {
+          return false;
+        }
+      }
+      if (VM.VerifyAssertions) { VM._assert(tmp.transaction.transactionID <= txID); }
+      if (tmp.transaction.transactionID == txID) {
+        present = true;
+      }
+    }
+    return present;
+  }
+  
+  /** There should be only one value for each {@code RVMThread} in each bucket */
+  @Inline
+  public void put(ReadHashMapElement value) {
+    putInternal(value);
+    if (VM.VerifyAssertions) { VM._assert(checkSetPropertyOfBuckets(value)); }
+  }
+  
+  @NoCheckStore
+  @Inline
+  private void putInternal(ReadHashMapElement value) {
+    if (VM.VerifyAssertions) { VM._assert(length == data.length); }
+    int key = getKey(value);
+    int index = key % length;
+    removeIfPresent(key);
+    setNext(value, data[index]);
+    data[index] = value;
+  }
+  
+  @NoCheckStore
+  @NoInline 
+  boolean checkSetPropertyOfBuckets(ReadHashMapElement value) {
+    int key = getKey(value);
+    ReadHashMapElement tmp = getBucketHead(key);
+    ReadHashMapElement tmp1 = getNext(tmp);
+    while (tmp1 != null) {
+      // We should not have another entry in the bucket with the same RVMThread 
+      if (tmp1.transaction.octetThread == tmp.transaction.octetThread) {
+        return false;
+      }
+      tmp1 = getNext(tmp1);
+    }
+    return true;
+  }
+  
+  public ReadHashMapElement getNext(ReadHashMapElement value) {
+    return value.next;
+  }
+
+  void setNext(ReadHashMapElement value, ReadHashMapElement next) {
+    value.next = next;
+  }
+  
+  @Inline
+  public void removeIfPresent(int key) {
+    removeInternal(key);
+  }
+  
+  @Inline
+  public void remove(int key, boolean mustExist) {
+    boolean result = removeInternal(key);
+    if (VM.VerifyAssertions) {
+      if (!result) { VM._assert(!mustExist); }
+    }
+  }
+  
+  @NoCheckStore
+  @Inline
+  private boolean removeInternal(int key) {
+    int index = key % length;
+    ReadHashMapElement tmp = data[index];
+    if (tmp == null) {
+      return false;
+    }
+    if (getKey(tmp) == key) {
+      data[index] = getNext(tmp);
+    } else {
+      ReadHashMapElement prev = tmp;
+      while (getKey(tmp) != key) {
+        prev = tmp;
+        tmp = getNext(tmp);
+        if (tmp == null) {
+          return false;
+        }
+      }
+      setNext(prev, getNext(tmp));
+    }
+    return true;
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/TransactionalHBGraph.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/TransactionalHBGraph.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/TransactionalHBGraph.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/TransactionalHBGraph.java	2014-04-03 17:43:49.593692144 -0400
@@ -0,0 +1,466 @@
+package org.jikesrvm.velodrome;
+
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.compilers.common.CompiledMethod;
+import org.jikesrvm.compilers.common.CompiledMethods;
+import org.jikesrvm.mm.mminterface.Barriers;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.octet.Site;
+import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+
+@Uninterruptible
+public class TransactionalHBGraph {
+
+  /** Special address value used to ensure mutually exclusive access */
+  private static final Address LOCK_OUTGOINGEDGE = Address.fromIntZeroExtend(1);
+  
+  /** Access to this variable should be protected by {@code velodromeEdgeCounterLock} */
+  private static int edgeNumber = 0;
+  
+  private final static int cycleVerbosity = 0; // >= 1 will print cycle information
+  
+  private static int dfsCounter = 0;
+  
+  private static TransactionsList stack = TransactionsList.dummyTransaction;
+
+  @Entrypoint 
+  @Inline // This probably has no effect
+  public static void startTransaction(int site, int methodID) { 
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.methodsAsTransactions() || Velodrome.syncBlocksAsTransactions()); }
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    if (!currentThread.isOctetThread()) { // We do not want to process non-Octet threads
+      return;
+    }
+    
+    // Sanity checks
+    if (VM.VerifyAssertions) { VM._assert(!currentThread.inTransaction()); }
+    Transaction current = currentThread.currentTransaction;
+    if (VM.VerifyAssertions) { VM._assert(current.isUnary); } // Current transaction/node should always be a unary transaction
+    
+    currentThread.setInTransaction();
+    
+    // Create and add a new regular transaction
+    Transaction tx = createTransaction(currentThread, site, methodID, /*isRegularTransaction =*/ true);
+    current.next = tx;
+    currentThread.currentTransaction = tx;
+    
+    if (Velodrome.checkStartTransactionInstrumentation()) { VM._assert(checkStartTransactionInstrumentation()); }
+    
+  }
+  
+  @UninterruptibleNoWarn
+  private static Transaction createTransaction(RVMThread thread, int siteID, int methodID, boolean isRegularTransaction) {
+    Transaction tx;
+    MemoryManager.startAllocatingInUninterruptibleCode();
+    RVMThread.velodromeEdgeCounterLock.lockNoHandshake();
+    int count = ++edgeNumber; // For sequential edges
+    RVMThread.velodromeEdgeCounterLock.unlock();
+    tx = new Transaction(thread, ++thread.numberOfNodes, siteID, isRegularTransaction, methodID, count);
+    MemoryManager.stopAllocatingInUninterruptibleCode();
+    return tx;
+  }
+  
+  @NoInline
+  private static void printTransaction(int site, int methodID, boolean isStart) {
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    if (!currentThread.isOctetThread()) { // We are not bothered about non-Octet threads
+      return;
+    }
+    VM.sysWrite(isStart ? "startTransaction(): " : "endTransaction(): ");
+    VM.sysWrite("Thread id: ", currentThread.octetThreadID);
+    VM.sysWrite(" Trans id: ", currentThread.currentTransaction.transactionID);
+    VM.sysWrite(", In Trans: ", currentThread.inTransaction());
+    VM.sysWrite(", Method id:", methodID);
+    VM.sysWrite(", Site:", site);
+    if (Velodrome.needsSites()) {
+      if (VM.VerifyAssertions) { VM._assert(site >= 0); } // Site should be valid for method start/end
+      Site site1 = Site.lookupSite(site);
+      if (VM.VerifyAssertions) { VM._assert(site1 != null); }
+      site1.sysWriteln();
+    } else {
+      VM.sysWriteln();
+    }
+  }
+  
+  @Entrypoint 
+  @Inline // This probably has no effect
+  public static void endTransaction(int site, int methodID) {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.methodsAsTransactions() || Velodrome.syncBlocksAsTransactions()); }
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    if (!currentThread.isOctetThread()) { // We do not want to process non-Octet threads
+      return;
+    }
+    
+    // Perform sanity checks
+    if (VM.VerifyAssertions) {
+      VM._assert(Velodrome.methodsAsTransactions() || Velodrome.syncBlocksAsTransactions());
+      VM._assert(currentThread.inTransaction());
+    }
+    if (Velodrome.checkStartTransactionInstrumentation()) { VM._assert(checkStartTransactionInstrumentation()); }
+    
+    Transaction current = currentThread.currentTransaction;
+    if (VM.VerifyAssertions) { VM._assert(current.methodID == methodID); }
+    
+    currentThread.resetInTransaction();
+    
+    Transaction last = createTransaction(currentThread, site, methodID, /*isRegularTransaction =*/ false);
+    current.next = last;
+    currentThread.currentTransaction = last;
+  }
+  
+  // Create WAW output dependence edge
+  @Inline
+  public static boolean createWrWrEdge(Transaction source, int sourceSiteID, Transaction dest, int destSiteID) {
+    return createEdgeHelper(source, sourceSiteID, dest, destSiteID);
+  }
+
+  // Create WAR anti dependence edge
+  @Inline
+  public static boolean createRdWrEdge(Transaction lastRead, int sourceSiteID, Transaction currentWrite, int destSiteID) {
+    return createEdgeHelper(lastRead, sourceSiteID, currentWrite, destSiteID);
+  }
+  
+  // Create possibly many WAR anti dependence edges
+  public static void createRdWrEdges(ReadHashMap readMap, Transaction currentWrite, int siteID) {
+    if (VM.VerifyAssertions) { VM._assert(readMap != null); }
+    if (readMap != null) {
+      if (VM.VerifyAssertions) { VM._assert(readMap.length == ReadHashMap.INITIAL_NUMBER_THREADS); }
+      for (int i = 0; i < readMap.length; i++) {
+        ReadHashMapElement tmp = readMap.getBucketHead(i); // tmp is the start pointer to the bucket indexed by i
+        while (tmp != null) {
+          if (tmp.transaction.octetThread != currentWrite.octetThread) {
+            createEdgeHelper(tmp.transaction, tmp.lastReadSiteID, currentWrite, siteID);
+          }
+          tmp = readMap.getNext(tmp);
+        }
+      }
+    }
+  }
+
+  // Create RAW true dependence edge
+  @Inline
+  public static boolean createWrRdEdge(Transaction lastWrite, int sourceSiteID, Transaction currentRead, int destSiteID) {
+    return createEdgeHelper(lastWrite, sourceSiteID, currentRead, destSiteID);
+  }
+  
+  @Inline
+  public static boolean createLockReleaseAcquireEdge(Transaction release, Transaction acquire) {
+    return createEdgeHelper(release, -1, acquire, -1);
+  }
+  
+  /** Create a cross-thread edge between nodes {@code source --> dest} 
+   *  At the moment, we do not create any cross-thread edges involving the driver thread for DaCapo benchmarks.
+   * */
+  private static boolean createEdgeHelper(Transaction source, int sourceSiteID, Transaction dest, int destSiteID) {
+    if (VM.VerifyAssertions) { VM._assert(source != null && dest != null); }
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.addPerFieldVelodromeMetadata()); }
+    // This is especially problematic for avrora9
+    if (Velodrome.bench.isDaCapoBenchmark() && 
+        (source.octetThread.octetThreadID == Velodrome.OCTET_FINALIZER_THREAD_ID || dest.octetThread.octetThreadID == Velodrome.OCTET_FINALIZER_THREAD_ID)) {
+      return false;
+    }
+    if (Velodrome.bench.getId() == BenchmarkInfo.TSP && 
+        (source.octetThread.octetThreadID == Velodrome.TSP_DRIVER_THREAD_OCTET_ID || dest.octetThread.octetThreadID == Velodrome.TSP_DRIVER_THREAD_OCTET_ID)) {
+      return false;
+    }
+    // We avoid cycle detection from the driver thread in DaCapo, which is currently Thread 1. Sync changes with AVD.
+    if (Velodrome.bench.isDaCapoBenchmark() 
+        && (source.octetThread.octetThreadID == Velodrome.DACAPO_DRIVER_THREAD_OCTET_ID || dest.octetThread.octetThreadID == Velodrome.DACAPO_DRIVER_THREAD_OCTET_ID)) {
+      return false;
+    }
+    if (source.octetThread == dest.octetThread || isCrossThreadEdgeAlreadyPresent(source, dest)) {
+      return false; // No cross-thread dependence
+    }
+    return createEdge(source, sourceSiteID, dest, destSiteID);
+  }
+  
+  /** Create a cross-thread edge between nodes {@code source --> dest} */
+  private static boolean createEdge(Transaction source, int sourceSiteID, Transaction dest, int destSiteID) {
+    if (VM.VerifyAssertions) { VM._assert(dest.next == null); } // dest should be an ongoing transaction
+    Address oldHead;
+    do {
+      do {
+        oldHead = ObjectReference.fromObject(source).toAddress().prepareAddress(Entrypoints.velodromeOutgoingEdgesField.getOffset());
+      } while (oldHead.EQ(LOCK_OUTGOINGEDGE));      
+      if (ObjectReference.fromObject(source).toAddress().attempt(oldHead, LOCK_OUTGOINGEDGE, Entrypoints.velodromeOutgoingEdgesField.getOffset())) {
+        break;
+      }
+    } while(true);
+    // We how have exclusive access to the outgoing list
+    TransactionsList oldListHead = (TransactionsList) oldHead.toObjectReference().toObject();
+    if (VM.VerifyAssertions) { VM._assert(oldListHead != null); } 
+    RVMThread.velodromeEdgeCounterLock.lockNoHandshake();
+    int edgeCount = ++edgeNumber;
+    RVMThread.velodromeEdgeCounterLock.unlock();
+    TransactionsList newListHead = TransactionsList.createTransactionsListNode(dest, edgeCount); 
+    newListHead.next = oldListHead;
+    // An MFENCE is required over here
+    Magic.fence();
+    boolean result = false;
+    Address temp = ObjectReference.fromObject(source).toAddress().prepareAddress(Entrypoints.velodromeOutgoingEdgesField.getOffset());
+    if (VM.VerifyAssertions) { VM._assert(temp.EQ(LOCK_OUTGOINGEDGE)); }
+    Object fakeObject = LOCK_OUTGOINGEDGE.toObjectReference().toObject();
+    if (Barriers.NEEDS_OBJECT_PUTFIELD_BARRIER) {
+      result = Barriers.objectTryCompareAndSwap(source, Entrypoints.velodromeOutgoingEdgesField.getOffset(), 
+          fakeObject, newListHead);
+    } else {
+      result = ObjectReference.fromObject(source).toAddress().attempt(LOCK_OUTGOINGEDGE, 
+          ObjectReference.fromObject(newListHead).toAddress(), Entrypoints.velodromeOutgoingEdgesField.getOffset());
+    }
+    if (VM.VerifyAssertions) { VM._assert(result, "Accessing the list is expected to be mutually exclusive"); }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numCrossThreadEdges.inc(1L);
+    }
+    
+    if (Velodrome.invokeCycleDetection()) {
+      if (checkForCycle(source, sourceSiteID, dest, destSiteID, edgeCount)) {
+        if (VM.VerifyAssertions) { VM._assert(!dest.isUnary); }
+        if (cycleVerbosity > 0) {
+          VM.sysWriteln("*********************************************************************************");
+          VM.sysWrite("Cycle detected:");
+          if (cycleVerbosity > 2) {
+            Transaction.printTransaction(dest);
+            VM.sysWrite(" --->  ");
+            Transaction.printTransaction(source);
+            VM.sysWrite("Source site");
+            if (destSiteID >= 0) {
+              Site.lookupSite(destSiteID).sysWriteln();
+            } else {
+              VM.sysWriteln("Source site id is -1");
+            }
+            VM.sysWrite(" --->  ");
+            if (sourceSiteID >= 0) {
+              Site.lookupSite(sourceSiteID).sysWriteln();
+            } else {
+              VM.sysWriteln("Dest site id is -1");
+            }
+          }
+          VM.sysWrite("Culprit Transaction: ");;
+          Transaction.printTransaction(dest);
+          VM.sysWriteln("*********************************************************************************");
+        }
+      }
+    }
+    return result;
+  }
+  
+  /** Returns true if there is already a cross-thread edge of the form {@code source --> dest} */
+  static boolean isCrossThreadEdgeAlreadyPresent(Transaction source, Transaction dest) {
+    if (VM.VerifyAssertions) { VM._assert(MemoryManager.validRef(ObjectReference.fromObject(source))); }
+    Address oldHead;
+    do {
+      oldHead = ObjectReference.fromObject(source).toAddress().loadAddress(Entrypoints.velodromeOutgoingEdgesField.getOffset());
+    } while (oldHead.EQ(LOCK_OUTGOINGEDGE));
+    if (VM.VerifyAssertions) { VM._assert(MemoryManager.validRef(oldHead.toObjectReference())); }
+    TransactionsList start = (TransactionsList) oldHead.toObjectReference().toObject();
+    if (VM.VerifyAssertions) { VM._assert(start != null); }    
+    while (start.transaction !=  null) {
+      if (start.transaction == dest) {
+        if (VM.VerifyAssertions) { VM._assert(start.transaction.transactionID == dest.transactionID && start.transaction.octetThread == dest.octetThread); }
+        return true;
+      }
+      start = start.next;
+    }
+    return false;
+  }
+  
+  /** We want to check for possible cycles between {@code source} and {@code dest} after an 
+   *  edge from {@code source --> dest} has been added. To do that, we start exploring from {@code dest} and
+   *  see if we can reach {@code source}. If we can, then we say that there is a cycle from transaction {@code dest} */
+  private static boolean checkForCycle(Transaction source, int sourceSiteID, Transaction dest, int destSiteID, int currentEdgeCount) {
+    if (dest.transactionID == Velodrome.START_TRANSACTION_ID || dest.isUnary) { 
+      return false;
+    }
+    RVMThread.velodromeCycleLock.lockNoHandshake();
+    if (VM.VerifyAssertions) { VM._assert(dfsCounter % 3 == 0); } 
+    
+    boolean flag = dfs(source, dest, dest, dfsCounter, currentEdgeCount, true);
+
+    dfsCounter += 3;
+    RVMThread.velodromeCycleLock.unlock();
+    return flag;
+  }
+
+  /** (firstCall == true) ==> (current == dest) */
+  private static boolean dfs(Transaction source, Transaction dest, Transaction current, int dCounter, int eCounter, boolean firstCall) {
+    if (VM.VerifyAssertions) { VM._assert(dest.next == null); } // dest should be an ongoing transaction
+    
+    if (current == source && !firstCall) { // Cycle detected
+      if (VM.VerifyAssertions) { VM._assert(current.octetThread == source.octetThread); }
+      return true;
+    }
+    
+    int WHITE = dCounter; // value of white
+    int GRAY = dCounter + 1; // value of gray
+    int BLACK = dCounter + 2; // value of black
+    current.visitedValue = GRAY;
+    
+    // Consider cross-thread successors of current
+    Address listHead = ObjectReference.fromObject(current).toAddress().plus(Entrypoints.velodromeOutgoingEdgesField.getOffset());
+    do {
+      listHead = ObjectReference.fromObject(current).toAddress().prepareAddress(Entrypoints.velodromeOutgoingEdgesField.getOffset());
+    } while (listHead.EQ(LOCK_OUTGOINGEDGE));
+    if (VM.VerifyAssertions) { VM._assert(listHead != null); }
+    if (VM.VerifyAssertions) { VM._assert(MemoryManager.validRef(listHead.toObjectReference())); }
+    TransactionsList start = (TransactionsList) listHead.toObjectReference().toObject();
+    if (VM.VerifyAssertions) { VM._assert(start != null); }
+    // Iterate over outgoing edges
+    while (start.transaction != null) {
+      Transaction temp = start.transaction;
+      if (VM.VerifyAssertions) { VM._assert(temp.visitedValue <= BLACK); }
+      if (VM.VerifyAssertions) { VM._assert(start.edgeNumber != eCounter); }
+      if (firstCall) {
+        if (start.edgeNumber < eCounter) { // Traverse along an older edge
+          if (temp.visitedValue == GRAY) { // Cycle detected
+            return true;
+          } else if (temp.visitedValue <= WHITE) {
+            return dfs(source, dest, temp, dCounter, start.edgeNumber, false);
+          }
+        } else { // No need to traverse along a more recent edge
+        }
+      } else {
+        if (start.edgeNumber > eCounter) { // Traverse along an increasing cycle
+          if (temp.visitedValue == GRAY) { // Cycle detected
+            return true;
+          } else if (temp.visitedValue <= WHITE) {
+            return dfs(source, dest, temp, dCounter, start.edgeNumber, false);
+          }
+        } else { // No need to traverse along older edges
+        }
+      }
+      start = start.next;
+    }
+    
+    // Traverse along the sequential edge
+    if (current.next != null) { // If current == dest, then dest.next should be null 
+      Transaction temp = current.next;
+      if (VM.VerifyAssertions) { VM._assert(temp.visitedValue <= BLACK); }
+      if (temp.incomingEdgeCount > eCounter) { // Traverse along an increasing cycle
+        if (temp.visitedValue == GRAY) { // Cycle detected
+          return true;
+        } else if (temp.visitedValue <= WHITE) {
+          return dfs(source, dest, temp, dCounter, temp.incomingEdgeCount, false);
+        }
+      } else { // No need to traverse along older edges
+      }
+    }
+    
+    // Make current black
+    current.visitedValue = BLACK;
+    return false;
+  }
+  
+  /**
+   * Here we decrease transaction depth during stack unwinding. The caller method takes
+   * care of the fact to avoid processing exceptions ***on behalf of VM*** and for native methods
+   */
+  @Inline
+  public static void handleExceptionDuringStackUnwinding(RVMMethod method) {
+    // This is no longer required with encapsulating the method calls. This is required when we need to accurately maintain
+    // the transaction depth without encapsulating the method calls.
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    
+    // Velodrome: LATER: This is the config we are bothered with for uncaught exceptions for now.
+    // What do we do for exceptions from within sync blocks?
+    if (!Velodrome.methodsAsTransactions() || !currentThread.isOctetThread()) {
+      return;
+    }
+    
+    // Sanity check
+    if (VM.VerifyAssertions) { VM._assert(currentThread.inTransaction()); }
+    // We are assuming exceptions are from regular transactions
+    if (VM.VerifyAssertions) { VM._assert(!currentThread.currentTransaction.isUnary); }
+    
+    currentThread.resetInTransaction();
+
+    // Add a unary node/transaction immediately after an actual method ends
+    Transaction current = currentThread.currentTransaction;
+    Transaction last = createTransaction(currentThread, current.siteID, current.methodID, /*isRegularTransaction =*/ false);
+    current.next = last;
+    currentThread.currentTransaction = last;
+  }
+  
+  /*
+   *  Debugging methods
+   */
+  
+  @NoInline
+  @UninterruptibleNoWarn
+  public static final boolean checkStartTransactionInstrumentation() {
+    Address fp = Magic.getFramePointer();
+    fp = Magic.getCallerFramePointer(fp);
+    int depth = 0;
+    while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+      int compiledMethodId = Magic.getCompiledMethodID(fp);
+      if (compiledMethodId != INVISIBLE_METHOD_ID) {
+        CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+        RVMMethod method = compiledMethod.getMethod();
+        if (!method.isNative() && Octet.shouldInstrumentMethod(method)) {
+          if (Context.isTRANSContext(method.getStaticContext()) && Context.isNONTRANSContext(method.getResolvedContext())) {
+            depth++;
+          }
+        }
+      }
+      fp = Magic.getCallerFramePointer(fp);
+    }
+    if (depth != 1) {
+      RVMThread currentThread = RVMThread.getCurrentThread();
+      VM.sysWriteln("Current thread:", currentThread.octetThreadID, "Trans:", currentThread.currentTransaction.transactionID);
+      VM.sysWriteln("depth:", depth);
+      RVMThread.dumpStack();
+      VM.sysFail("Mismatch in transaction depth");
+    }
+    return true;
+  }
+  
+  @Entrypoint
+  public static final void checkMethodContextAtProlog() {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.checkMethodContextAtProlog()); }
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    if (VM.VerifyAssertions) { VM._assert(currentThread.isOctetThread()); }
+    Address fp = Magic.getFramePointer();
+    int compiledMethodId = Magic.getCompiledMethodID(Magic.getCallerFramePointer(fp));
+    if (compiledMethodId != INVISIBLE_METHOD_ID) {
+      CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      RVMMethod method = compiledMethod.getMethod();
+      if (VM.VerifyAssertions) { VM._assert(Context.isApplicationPrefix(method.getDeclaringClass().getTypeRef())); }
+      if (VM.VerifyAssertions) {
+        if (currentThread.inTransaction()) {
+          if (method.getStaticContext() != Context.TRANS_CONTEXT) {
+            VM.sysWriteln("Current Octet thread id:", currentThread.octetThreadID);
+            VM.sysWriteln("Method name:", method.getName());
+            VM.sysWriteln("Class name:", method.getDeclaringClass().getDescriptor());
+            VM.sysWriteln("Static context:", method.getStaticContext());
+            VM.sysWriteln("Resolved context:", method.getResolvedContext());
+            VM.sysFail("Static context of called method is not TRANS");
+          }
+        } else {
+          if (method.getStaticContext() != Context.NONTRANS_CONTEXT) {
+            VM.sysWriteln("Current Octet thread id:", currentThread.octetThreadID);
+            VM.sysWriteln("Method name:", method.getName());
+            VM.sysWriteln("Class name:", method.getDeclaringClass().getDescriptor());
+            VM.sysWriteln("Static context:", method.getStaticContext());
+            VM.sysWriteln("Resolved context:", method.getResolvedContext());
+            VM.sysFail("Static context of called method is not NONTRANS");
+          }
+        }
+      }
+    }
+  }
+
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/Transaction.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/Transaction.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/Transaction.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/Transaction.java	2014-04-03 17:43:49.594692145 -0400
@@ -0,0 +1,95 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.octet.Site;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class Transaction implements Constants {
+
+  /** A unique id for a transaction/node. Root node has id 0. */
+  public int transactionID;
+  /* Does this node correspond to an actual method? */
+  public boolean isUnary;
+  /** Stores the site id corresponding to the line in the source file. */
+  public int siteID;
+  
+  /** Thread reference */
+  public RVMThread octetThread;
+  
+  public int methodID; // Unary transactions and dummy start/end have method id = -1
+  
+  /** Pointer to the next node in the list. */
+  public Transaction next;
+  public int incomingEdgeCount;
+  
+  /** List of outgoing edges */
+  @Entrypoint
+  public TransactionsList outgoingEdges = TransactionsList.dummyTransaction;
+  public int sizeOfOutgoingEdges;
+  
+  public int visitedValue;
+  
+  public Transaction() {
+    this(null, false, /*incomingEdge = */ -1);
+  }
+  
+  /** 
+   * Called to create the root (dummy) node only. This has a trans id 1.
+   * Note that it is possible for <code>t</code> to be different from RVMThread.getCurrentThread(), if this 
+   * ctor is called from RVMThread ctor
+   */
+  public Transaction(RVMThread t, boolean isRegular, int incomingEdge) {
+    this(t, 1,
+        -1, isRegular, -1, incomingEdge);
+  }
+  
+  /** This ctor creates a node that represents a transaction. 
+   * Note that it is possible for t to be different from RVMThread.getCurrentThread(), if this
+   * ctor is called from RVMThread ctor
+   * */
+  public Transaction(RVMThread thread, int transID, int site, boolean isRegular, int method, int incomingEdge) {
+    octetThread = thread;
+    if (VM.VerifyAssertions && thread != null) { VM._assert(thread.isOctetThread()); }
+    siteID = site;
+    methodID = method;
+    transactionID = transID;   
+    this.isUnary = !isRegular;
+    next= null;
+    incomingEdgeCount = incomingEdge;
+    sizeOfOutgoingEdges = 0;
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numTransactions.inc(1L);
+      if (isRegular) {
+        VelodromeStats.numRegularTransactions.inc(1L);
+      } else {
+        VelodromeStats.numUnaryTransactions.inc(1L);
+      }
+    }
+  }
+  
+  @NoInline
+  public static void printTransaction(Transaction tx) {
+    VM.sysWrite("Thread:", tx.octetThread.octetThreadID);
+    VM.sysWrite(" Trans:", tx.transactionID);
+    if (tx.isUnary) {
+      VM.sysWrite(" Unary");
+    } else {
+      VM.sysWrite(" Regular");
+    }
+    VM.sysWrite(" Site id:", tx.siteID, " ");
+    if (Velodrome.needsSites() && tx.siteID >= 0) { // Root/dummy transaction could log accesses and has site id -1
+      Site site = Site.lookupSite(tx.siteID);
+      if (VM.VerifyAssertions) { VM._assert(site != null); }
+      site.sysWriteln();
+    } else {
+      if (VM.VerifyAssertions) { VM._assert(tx.transactionID == 1); }
+      VM.sysWriteln(" Site id is null");
+    }
+  }
+  
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/TransactionsList.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/TransactionsList.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/TransactionsList.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/TransactionsList.java	2014-04-03 17:43:49.594692145 -0400
@@ -0,0 +1,39 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
+
+@Uninterruptible
+public class TransactionsList {
+
+  public Transaction transaction;
+  public TransactionsList next;
+  public int edgeNumber;
+  
+  public static final TransactionsList dummyTransaction = new TransactionsList();
+  
+  /** Represents a dummy (sentinel) node. */
+  public TransactionsList() {
+    transaction = null;
+    next = null;
+    edgeNumber = -1;
+  }
+  
+  public TransactionsList(Transaction tx, int desc) {
+    transaction = tx;
+    next = null;
+    edgeNumber = desc;
+  }
+  
+  @UninterruptibleNoWarn
+  public static TransactionsList createTransactionsListNode(Transaction tx, int desc) {
+    if (VM.VerifyAssertions) { VM._assert(tx != null); }
+    MemoryManager.startAllocatingInUninterruptibleCode();
+    TransactionsList temp = new TransactionsList(tx, desc);
+    MemoryManager.stopAllocatingInUninterruptibleCode();
+    return temp;
+  }
+  
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeAnalysis.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeAnalysis.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeAnalysis.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeAnalysis.java	2014-04-03 17:43:49.594692145 -0400
@@ -0,0 +1,141 @@
+package org.jikesrvm.velodrome;
+
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Context;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.compilers.baseline.ia32.OctetBaselineInstr;
+import org.jikesrvm.compilers.baseline.ia32.VelodromeBaselineInstr;
+import org.jikesrvm.compilers.common.CompiledMethod;
+import org.jikesrvm.compilers.common.CompiledMethods;
+import org.jikesrvm.compilers.opt.OctetOptInstr;
+import org.jikesrvm.compilers.opt.OctetOptSelection;
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover;
+import org.jikesrvm.compilers.opt.RedundantBarrierRemover.AnalysisLevel;
+import org.jikesrvm.compilers.opt.VelodromeOptSelection;
+import org.jikesrvm.compilers.opt.ir.Instruction;
+import org.jikesrvm.compilers.opt.VelodromeOptInstr;
+import org.jikesrvm.octet.ClientAnalysis;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+
+@Uninterruptible
+public class VelodromeAnalysis extends ClientAnalysis {
+
+  @Interruptible
+  @Override
+  protected void boot() {
+    Velodrome.boot();
+  }
+  
+  @Interruptible
+  public void handleThreadTerminationEarly() {
+    // Velodrome: LATER: This assertion fails for few benchmarks: avrora9 
+    if (VM.VerifyAssertions) { VM._assert(!RVMThread.getCurrentThread().inTransaction()); }
+    super.handleThreadTerminationEarly();
+  }
+  
+  @Override
+  public void handleThreadTerminationLate() {
+    super.handleThreadTerminationLate();
+  }
+  
+  @Inline
+  @Override
+  protected boolean needsFieldInfo() {
+    return true;
+  }
+  
+  @Inline
+  @Override
+  protected boolean useFieldOffset() {
+    return true;
+  }
+
+  /** Support overriding/customizing barrier insertion in the baseline compiler */
+  @Interruptible
+  @Override
+  public OctetBaselineInstr newBaselineInstr() {
+    return new VelodromeBaselineInstr();
+  }
+  
+  /** Support overriding/customizing the choice of which instructions the opt compiler should instrument */
+  @Interruptible
+  @Override
+  public OctetOptSelection newOptSelect() {
+    return new VelodromeOptSelection();
+  }
+
+  /** Support overriding/customizing barrier insertion in the opt compiler */
+  @Interruptible
+  @Override
+  public OctetOptInstr newOptInstr(boolean lateInstr, RedundantBarrierRemover redundantBarrierRemover) {
+    return new VelodromeOptInstr(lateInstr, redundantBarrierRemover);
+  }
+  
+  @Interruptible
+  @Override
+  public RedundantBarrierRemover newRedundantBarriersAnalysis() {
+    return new RedundantBarrierRemover(AnalysisLevel.NONE);
+  }
+  
+  /** Let the client analysis specify the chooseBarrier. */
+  @Override
+  public NormalMethod chooseBarrier(NormalMethod method, boolean isRead, boolean isField, boolean isResolved, boolean isStatic, boolean hasRedundantBarrier, boolean isSpecialized) {
+    return VelodromeInstrDecisions.chooseVelodromeBarrier(isRead, isField, isResolved, isStatic);
+  }
+  
+  // Velodrome has disabled RBA. So, I guess the following has no effect.
+  @Override
+  public boolean instrInstructionHasRedundantBarrier(Instruction inst) { 
+    return false; 
+  }
+
+  @Override
+  public boolean supportsIrBasedBarriers() {
+    return false;
+  }
+
+  @Override
+  public boolean incRequestCounterForImplicitProtocol() {
+    return false;
+  }
+  
+  /** Compute the static context that needs to be used for a method */
+  // We could possibly invoke this method at places where the isNonAtomic value is checked, 
+  // since that is wrong. The actual context would depend on the call stack. 
+  public static int walkStackToFindContext() {
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    if (VM.VerifyAssertions) { VM._assert(currentThread.isOctetThread()); }
+    int resolvedContext = Context.INVALID_CONTEXT;
+    Address fp = Magic.getFramePointer();
+    boolean atLeastOneAppMethod = false;
+    // Search for the topmost application frame/method
+    while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+      int compiledMethodId = Magic.getCompiledMethodID(fp);
+      if (compiledMethodId != INVISIBLE_METHOD_ID) {
+        CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+        RVMMethod method = compiledMethod.getMethod();
+        if (!method.isNative() && Octet.shouldInstrumentMethod(method)) {
+          resolvedContext = method.getStaticContext();
+          atLeastOneAppMethod = true;
+          break;
+        }
+      }
+      fp = Magic.getCallerFramePointer(fp);
+    }
+    if (!atLeastOneAppMethod) { // First application method called
+      resolvedContext = Context.NONTRANS_CONTEXT; 
+    }
+    return resolvedContext;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeBarriers.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeBarriers.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeBarriers.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeBarriers.java	2014-04-03 17:43:49.595692148 -0400
@@ -0,0 +1,272 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.objectmodel.JavaHeader;
+import org.jikesrvm.objectmodel.MiscHeader;
+import org.jikesrvm.octet.OctetBarriers;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+
+// Currently, Velodrome is not instrumenting libraries. The "has velodrome offset" check can be required for 
+// inheritance cases where the base class is the library. The per-field metadata in such a scenario will not 
+// be laid out for the base class, but we would want it for derived application classes.
+// Another issue is that however, there could accesses to public fields of library classes in
+// application code which will also not have Velodrome offsets w/o library instrumentation. Example, 
+// Elevator accesses StreamTokenizer.nval and sval in Elevator::readNum()
+// Another example: org.eclipse.osgi.framework.internal.core.BundleURLConnection::connect()
+
+@Uninterruptible
+public class VelodromeBarriers implements Constants {
+  
+  @Entrypoint
+  public static final void fieldReadBarrierResolved(Object o, int fieldOffset, int siteID, int writeOffset, int readOffset) {
+    if (writeOffset != Velodrome.UNITIALIZED_OFFSET) {
+      if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset >= 0 && readOffset >= 0); }
+      readObject(o, fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPre.inc(1L);
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static final void fieldWriteBarrierResolved(Object o, int fieldOffset, int siteID, int writeOffset, int readOffset) {
+    if (writeOffset != Velodrome.UNITIALIZED_OFFSET) {
+      if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset >= 0 && readOffset >= 0); }
+      writeObject(o, fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPre.inc(1L);
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static final void fieldReadBarrierStaticResolved(int fieldOffset, int siteID, int writeOffset, int readOffset) {
+    // Metadata offsets are stored in negative offsets so that the GC does not trace them as roots while scanning the JTOC
+    if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset < 0 && readOffset < 0); }
+    readStatic(fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static final void fieldWriteBarrierStaticResolved(int fieldOffset, int siteID, int writeOffset, int readOffset) {
+    // Metadata offsets are stored in negative offsets so that the GC does not trace them as roots while scanning the JTOC
+    if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset < 0 && readOffset < 0); }
+    writeStatic(fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  // Octet: TODO: field might not actually be resolved here if inserted in the opt compiler during early instrumentation!
+  
+  // Octet: TODO: can we resolve a field?  is that interruptible?  how does that work in Jikes?
+  
+  // Velodrome: A call to a unresolved field in the barriers will have their velodrome offset
+  // initialized. However, it may not be initialized during compilation.
+  
+  @Entrypoint
+  public static final void fieldReadBarrierUnresolved(Object o, int fieldID, int siteID, int writeOffset, int readOffset) {
+    int fieldOffset = OctetBarriers.getFieldInfo(fieldID);
+    RVMField field = OctetBarriers.handleUnresolvedField(fieldID);
+    if (Velodrome.addPerFieldVelodromeMetadata() && field.hasVelodromeMetadataOffset()) {
+      writeOffset = field.getWriteMetadataOffset().toInt();
+      readOffset = field.getReadMetadataOffset().toInt();
+      if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset >= 0 && readOffset >= 0); }
+      readObject(o, fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPre.inc(1L);
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static final void fieldWriteBarrierUnresolved(Object o, int fieldID, int siteID, int writeOffset, int readOffset) {
+    int fieldOffset = OctetBarriers.getFieldInfo(fieldID);
+    RVMField field = OctetBarriers.handleUnresolvedField(fieldID);
+    if (Velodrome.addPerFieldVelodromeMetadata() && field.hasVelodromeMetadataOffset()) {
+      writeOffset = field.getWriteMetadataOffset().toInt();
+      readOffset = field.getReadMetadataOffset().toInt();
+      if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset >= 0 && readOffset >= 0); }
+      writeObject(o, fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPre.inc(1L);
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  // Octet: LATER: the hasMetadataOffset checks are necessary because some fields --
+  // in particular, *final* fields -- might get instrumentation added for them at
+  // "unresolved static" accesses, but their resolved fields won't have a metadata offset.
+  
+  @Entrypoint
+  public static final void fieldReadBarrierStaticUnresolved(int fieldID, int siteID, int writeOffset, int readOffset) {
+    RVMField field = OctetBarriers.handleUnresolvedField(fieldID);
+    // Velodrome: I guess the above Octet comment explains the need for the hasVelodromeMetadataOffset() check.
+    if (Velodrome.addPerFieldVelodromeMetadata() && field.hasVelodromeMetadataOffset()) {
+      int fieldOffset = OctetBarriers.getFieldInfo(field, fieldID);
+      writeOffset = field.getWriteMetadataOffset().toInt();
+      readOffset = field.getReadMetadataOffset().toInt();
+      if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset < 0 && readOffset < 0); }
+      readStatic(fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPre.inc(1L);
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static final void fieldWriteBarrierStaticUnresolved(int fieldID, int siteID, int writeOffset, int readOffset) {
+    RVMField field = OctetBarriers.handleUnresolvedField(fieldID);
+    if (Velodrome.addPerFieldVelodromeMetadata() && field.hasVelodromeMetadataOffset()) {
+      int fieldOffset = OctetBarriers.getFieldInfo(field, fieldID);
+      writeOffset = field.getWriteMetadataOffset().toInt();
+      readOffset = field.getReadMetadataOffset().toInt();
+      if (VM.VerifyAssertions && Velodrome.addPerFieldVelodromeMetadata()) { VM._assert(writeOffset < 0 && readOffset < 0); }
+      writeStatic(fieldOffset, siteID, Offset.fromIntSignExtend(writeOffset), Offset.fromIntSignExtend(readOffset));
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPre.inc(1L);
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static final void arrayReadBarrier(Object o, int arrayIndex, int siteID, int writeOffset, int readOffset, int arrayElementSize) {
+    int arraySlotOffset = Offset.fromIntSignExtend(arrayIndex * arrayElementSize).toInt();
+    if (VM.VerifyAssertions) { VM._assert(writeOffset == Integer.MIN_VALUE + 1); }
+    Offset wOffset = MiscHeader.VELODROME_WRITE_OFFSET;
+    if (VM.VerifyAssertions) { VM._assert(readOffset == Integer.MIN_VALUE + 1); }
+    Offset rOffset = MiscHeader.VELODROME_READ_OFFSET;
+    readObject(o, arraySlotOffset, siteID, wOffset, rOffset);
+  }
+  
+  @Entrypoint
+  public static final void arrayWriteBarrier(Object o, int arrayIndex, int siteID, int writeOffset, int readOffset, int arrayElementSize) {
+    int arraySlotOffset = Offset.fromIntSignExtend(arrayIndex * arrayElementSize).toInt();
+    if (VM.VerifyAssertions) { VM._assert(writeOffset == Integer.MIN_VALUE + 1); }
+    Offset wOffset = MiscHeader.VELODROME_WRITE_OFFSET;
+    if (VM.VerifyAssertions) { VM._assert(readOffset == Integer.MIN_VALUE + 1); }
+    Offset rOffset = MiscHeader.VELODROME_READ_OFFSET;    
+    writeObject(o, arraySlotOffset, siteID, wOffset, rOffset);
+  }
+  
+  // Velodrome: TODO: Decide whether to inline readObject()/readStatic() methods
+
+  static final boolean readObject(Object o, int fieldOffset, int siteID, Offset writeOffset, Offset readOffset) {
+    if (Velodrome.insertPostBarriers()) { // Lock the metadata iff postbarriers are enabled
+      Address objAddr = ObjectReference.fromObject(o).toAddress();
+      Transaction lastWrite = (Transaction) VelodromeMetadataHelper.lockFieldMetadata(objAddr, writeOffset, /* isStatic*/ false);
+      if (Velodrome.trackLastAccess()) {
+        ObjectReference readMetadataRef = objAddr.loadObjectReference(readOffset);
+        RVMThread currentThread = RVMThread.getCurrentThread();
+        if (!readMetadataRef.isNull()) {
+          Address tib = readMetadataRef.toAddress().loadAddress(JavaHeader.getTibOffset());
+          if (VM.VerifyAssertions) { VM._assert(!tib.isZero()); }
+          Transaction currentTx = currentThread.currentTransaction;
+          if (tib.EQ(Velodrome.tibForTransaction)) { // This is the second read, need to upgrade to a read map
+            Transaction lastRead = (Transaction) readMetadataRef.toObject();
+            if (lastRead != currentTx) {
+              VelodromeMetadataHelper.upgradeToReadHashMap(objAddr, writeOffset, readOffset, lastRead, lastWrite, siteID);
+            }
+          } else { // Should be a read map
+            if (VM.VerifyAssertions) { VM._assert(tib.EQ(Velodrome.tibForReadHashMap)); }
+            ReadHashMap map = (ReadHashMap) objAddr.loadObjectReference(readOffset).toObject();
+            if (!map.contains(currentThread.octetThreadID, currentTx.transactionID)) {
+              VelodromeMetadataHelper.appendCurrentRead(objAddr, writeOffset, readOffset, lastWrite, siteID);
+            }
+          }
+        } else { // First read
+          VelodromeMetadataHelper.setOnlyRead(objAddr, writeOffset, readOffset, lastWrite, siteID);
+        }
+      }
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTracked.inc(1L);
+    }
+    return true;
+  }
+  
+  static final boolean writeObject(Object o, int fieldOrIndexInfo, int siteID, Offset writeOffset, Offset readOffset) {
+    if (Velodrome.insertPostBarriers()) { // Lock the metadata iff postbarriers are enabled
+      Address objAddr = ObjectReference.fromObject(o).toAddress();
+      Transaction lastWrite = (Transaction) VelodromeMetadataHelper.lockFieldMetadata(objAddr, writeOffset, false);
+      if (Velodrome.trackLastAccess()) {
+        if (lastWrite != RVMThread.getCurrentThread().currentTransaction) {
+          VelodromeMetadataHelper.updateLastWrite(objAddr, writeOffset, readOffset, lastWrite, siteID);
+        }
+      }
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTracked.inc(1L);
+    }
+    return true;
+  }
+  
+  static final boolean readStatic(int fieldOffset, int siteID, Offset writeOffset, Offset readOffset) {
+    if (Velodrome.insertPostBarriers()) { // Lock the metadata iff postbarriers are enabled
+      Transaction lastWrite = (Transaction) VelodromeMetadataHelper.lockFieldMetadata(Magic.getTocPointer(), writeOffset, true);
+      if (Velodrome.trackLastAccess()) {
+        Address readMetadata = Magic.getTocPointer().loadAddress(readOffset);
+        RVMThread currentThread = RVMThread.getCurrentThread();
+        if (readMetadata.NE(Address.zero())) {
+          Address tib = ObjectReference.fromObject(readMetadata).toAddress().loadAddress(JavaHeader.getTibOffset());
+          Transaction currentTx = currentThread.currentTransaction;
+          if (tib.EQ(Velodrome.tibForTransaction)) { // This is the second read, need to upgrade to a read map
+            Transaction lastRead = (Transaction) readMetadata.toObjectReference().toObject();
+            if (lastRead != currentTx) {
+              VelodromeMetadataHelper.upgradeToReadHashMap(Magic.getTocPointer(), writeOffset, readOffset, lastRead, lastWrite, siteID);
+            }
+          } else { // Should be a read map
+            ReadHashMap map = (ReadHashMap) Magic.getTocPointer().loadObjectReference(readOffset).toObject();
+            if (!map.contains(currentThread.octetThreadID, currentTx.transactionID)) {
+              VelodromeMetadataHelper.appendCurrentRead(Magic.getTocPointer(), writeOffset, readOffset, lastWrite, siteID);
+            }
+          }
+        } else { // First read
+          VelodromeMetadataHelper.setOnlyRead(Magic.getTocPointer(), writeOffset, readOffset, lastWrite, siteID);
+        }
+      }
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTracked.inc(1L);
+    }
+    return true;
+  }
+
+  static final boolean writeStatic(int fieldOffset, int siteID, Offset writeOffset, Offset readOffset) {
+    if (Velodrome.insertPostBarriers()) { // Lock the metadata iff postbarriers are enabled
+      Transaction lastWrite = (Transaction) VelodromeMetadataHelper.lockFieldMetadata(Magic.getTocPointer(), writeOffset, true);
+      if (Velodrome.trackLastAccess()) {
+        if (lastWrite != RVMThread.getCurrentThread().currentTransaction) {
+          VelodromeMetadataHelper.updateLastWrite(Magic.getTocPointer(), writeOffset, readOffset, lastWrite, siteID);
+        }
+      }
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTracked.inc(1L);
+    }
+    return true;
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeInstrDecisions.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeInstrDecisions.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeInstrDecisions.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeInstrDecisions.java	2014-04-03 17:43:49.593692144 -0400
@@ -0,0 +1,85 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.runtime.Entrypoints;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeInstrDecisions implements Constants {
+
+  protected static NormalMethod chooseVelodromeBarrier(boolean isRead, boolean isField, boolean isResolved, boolean isStatic) {
+    if (isField) { // scalar fields and statics
+      if (isRead) {
+        if (isResolved) {
+          if (isStatic) {
+            return Entrypoints.velodromeFieldReadBarrierStaticResolvedMethod;
+          } else {
+            return Entrypoints.velodromeFieldReadBarrierResolvedMethod;
+          }
+        } else {
+          if (isStatic) {
+            return Entrypoints.velodromeFieldReadBarrierStaticUnresolvedMethod;
+          } else {
+            return Entrypoints.velodromeFieldReadBarrierUnresolvedMethod;
+          }          
+        }
+      } else {
+        if (isResolved) {
+          if (isStatic) {
+            return Entrypoints.velodromeFieldWriteBarrierStaticResolvedMethod;
+          } else {
+            return Entrypoints.velodromeFieldWriteBarrierResolvedMethod;
+          }
+        } else {
+          if (isStatic) {
+            return Entrypoints.velodromeFieldWriteBarrierStaticUnresolvedMethod;
+          } else {
+            return Entrypoints.velodromeFieldWriteBarrierUnresolvedMethod;
+          }
+        }
+      }
+    } else { // Arrays
+      if (VM.VerifyAssertions) { VM._assert(isResolved); } // Array accesses can't be unresolved 
+      if (isRead) {
+        return Entrypoints.velodromeArrayReadBarrierMethod;        
+      } else {
+        return Entrypoints.velodromeArrayWriteBarrierMethod;
+      }
+    }
+  }  
+  
+  public static final boolean staticFieldHasVelodromeMetadata(RVMField field) {
+    if (Velodrome.addPerFieldVelodromeMetadata()) {
+      boolean hasMetadata = field.hasVelodromeMetadataOffset();
+      // at least for now, we expect the metadata to provide the same result as for an unresolved field,
+      // except that the metadata should also be avoiding final fields
+      if (VM.VerifyAssertions) { VM._assert(hasMetadata == (staticFieldMightHaveVelodromeMetadata(field.getMemberRef().asFieldReference()) && !field.isFinal())); }
+      return hasMetadata;
+    } 
+    return false;
+  }
+
+  public static boolean staticFieldMightHaveVelodromeMetadata(FieldReference fieldRef) {
+    if (Velodrome.addPerFieldVelodromeMetadata()) {
+      return Velodrome.shouldAddVelodromeMetadataForStaticField(fieldRef);
+    } else {
+      return false;
+    }
+  }
+  
+  @Inline
+  public static boolean objectOrFieldHasVelodromeMetadata(RVMField field) {
+    return !field.isFinal() && objectOrFieldMightHaveVelodromeMetadata(field.getMemberRef().asFieldReference()); 
+  }
+
+	@Inline
+  public static boolean objectOrFieldMightHaveVelodromeMetadata(FieldReference asFieldReference) {
+    return Velodrome.addPerFieldVelodromeMetadata();
+  }
+
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/Velodrome.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/Velodrome.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/Velodrome.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/Velodrome.java	2014-04-03 17:43:49.592692143 -0400
@@ -0,0 +1,479 @@
+package org.jikesrvm.velodrome;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+
+import org.jikesrvm.Callbacks;
+import org.jikesrvm.Callbacks.ExitMonitor;
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.Atom;
+import org.jikesrvm.classloader.FieldReference;
+import org.jikesrvm.classloader.MethodReference;
+import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.classloader.RVMMember;
+import org.jikesrvm.classloader.RVMMethod;
+import org.jikesrvm.classloader.TypeReference;
+import org.jikesrvm.compilers.opt.ir.operand.MethodOperand;
+import org.jikesrvm.mm.mminterface.Barriers;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.objectmodel.JavaHeader;
+import org.jikesrvm.octet.Octet;
+import org.jikesrvm.scheduler.SpinLock;
+import org.jikesrvm.util.HashSetRVM;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.Pure;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
+import org.vmmagic.pragma.Untraced;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.OffsetArray;
+
+/*
+ * Velodrome: LATER: Check for 
+ * 2) emit_aastore() does not currently have unlock metadata instrumentation. It can possibly done by 
+ *    duplicating the contents of the SP.
+ * 3) Instead of emitting a call to unlock metadata, we can emit the instructions directly in baseline and 
+ *    opt compilers.
+ * 6) Arrays are not supported for now, need to make changes in the compilers to support arrays.
+ * 7) has velodrome offset check can be required for inheritance cases where the base class is the library. The 
+ *    per-field metadata in that case will not be laid out, but we would want it for derived application classes
+ * 10) Maintain the stack while recursing during dfs.
+ * 13) Runtimefinal - Using a static reference to TIB object has an additional load from the JTOC. 
+ *     However, Runtimefinal seems to work only for booleans.
+ * 15) Post-barrier call instructions are currently not being inlined
+ * 18) Test the FCFG graph.
+ * 19) Plenty of cycles for the start node in each thread. And the same cycle is probably reported multiple times.
+ * 20) Can we avoid cycle detection from transactions that are part of the dacapo harness?
+ * 21) Use Raja benchmark, check REDCard paper.
+ * 
+ * */
+
+@Uninterruptible
+public final class Velodrome implements Constants {
+
+  static BenchmarkInfo bench = null;
+
+  // Sync these uses with DoubleChecker
+  static final int OCTET_FINALIZER_THREAD_ID = 0;
+  static final int DACAPO_DRIVER_THREAD_OCTET_ID = 1;
+  static final int JAVA_GRANDE_DRIVER_THREAD_OCTET_ID = 1;
+  static final int ELEVATOR_DRIVER_THREAD_OCTET_ID = 1;
+  static final int TSP_DRIVER_THREAD_OCTET_ID = 1;
+  
+  public static final int START_TRANSACTION_ID = 1;
+  
+  public static final int UNITIALIZED_OFFSET = RVMMember.NO_OFFSET;
+  
+  private static final int NUM_METADATA_FIELDS = 2; // One for write, one for read (in order)
+  public static final int LOG_FIELD_SIZE = LOG_BYTES_IN_WORD; // 2
+  public static final int FIELD_SIZE = 1 << LOG_FIELD_SIZE; // 4
+  
+  // Velodrome: TODO: Check if using untraced works. Static fields would get added to the JTOC and would anyway
+  // be treated as roots.
+  @Untraced
+  private static Transaction dummyTrans = new Transaction();
+  public static Address tibForTransaction;
+  @Untraced
+  public static ReadHashMap dummyMap = null;
+  public static Address tibForReadHashMap = null;
+
+  public static final Atom transactionDescriptor = Atom.findOrCreateAsciiAtom("Lorg/jikesrvm/velodrome/Transaction");
+  public static final Atom readMapDescriptor = Atom.findOrCreateAsciiAtom("Lorg/jikesrvm/velodrome/ReadHashMap;");
+
+  /** String ends with a / (e.g., /home/biswass/) */
+  public static String homePrefix = System.getProperty("user.home") + "/";
+  public static String directoryName = homePrefix + "velodrome-output/"; 
+  private static String directoryPrefix = homePrefix + "velodromeRvmRoot/velodrome/";
+  public static final HashSetRVM<Atom> notTransactions = new HashSetRVM<Atom>();
+  
+  public static final Atom method = Atom.findOrCreateAsciiAtom("getNextToken");
+  public static final Atom parent = Atom.findOrCreateAsciiAtom("execute");
+  public static final Atom methodClass = Atom.findOrCreateAsciiAtom("Lorg/eclipse/jdt/internal/compiler/parser/Scanner;");
+  public static final Atom parentClass = Atom.findOrCreateAsciiAtom("Lorg/apache/xalan/templates/ElemLiteralResult;");
+  
+  /** This array can only grow, it contains offsets of all interesting metadata references. 
+   *  Protect accesses to this array with the associated {@code jtocMetadataReferencesLock} lock */
+  public static OffsetArray jtocMetadataReferences;
+  private static int currentNumSlotsInJtocReferences = 1 << 10;
+  private static final int LOG_GROWTH_FACTOR = 1; // 2X
+  public static int jtocMetadataReferencesIndex = 0; 
+  private static final SpinLock jtocMetadataReferencesLock = new SpinLock();
+  
+  @Pure
+  @Inline
+  public static boolean needsSites() {
+    return Octet.getConfig().needsSites();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean methodsAsTransactions() {
+    return Octet.getConfig().methodsAsTransactions();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean syncBlocksAsTransactions() {
+    return Octet.getConfig().syncBlocksAsTransactions();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean createCrossThreadEdges() {
+    return Octet.getConfig().createCrossThreadEdges();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean invokeCycleDetection() {
+    return Octet.getConfig().invokeCycleDetection();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean recordVelodromeStats() {
+    return Octet.getConfig().recordVelodromeStats();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean trackSynchronizationPrimitives() {
+    return Octet.getConfig().trackSynchronizationPrimitives();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean instrumentArrays() {
+    return Octet.getConfig().instrumentArrays();
+  }
+
+  @Pure
+  @Inline
+  public static boolean trackThreadSynchronizationPrimitives() {
+    return Octet.getConfig().trackThreadSynchronizationPrimitives();
+  }
+  
+  @Pure
+  @Inline
+  public boolean insertStartEndTransactionBarriers() {
+    return Octet.getConfig().insertStartEndTransactionBarriers();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean inlineStartEndTransactions() {
+    return Octet.getConfig().inlineStartEndTransactions();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean insertBarriers() {
+    return Octet.getConfig().insertBarriers();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean insertPostBarriers() {
+    return Octet.getConfig().insertPostBarriers();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean addPerFieldVelodromeMetadata() {
+    return Octet.getConfig().addPerFieldVelodromeMetadata();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean trackLastAccess() {
+    return Octet.getConfig().trackLastAccess();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean addMiscHeader() {
+    return Octet.getConfig().addMiscHeader();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean isVelodromeEnabled() {
+    return Octet.getConfig().isVelodromeEnabled();
+  }
+  
+  @Pure
+  @Inline
+  public static boolean isPerformanceRun() {
+    return Octet.getConfig().isPerformanceRun();
+  }
+  
+  /** Used only for debugging at start and end transaction instrumentation. */
+  @Pure
+  @Inline
+  public static boolean checkStartTransactionInstrumentation() {
+    return Octet.getConfig().checkStartTransactionInstrumentation();
+  }
+  
+  /** Used only for debugging static context of methods at every prolog. */
+  @Pure
+  @Inline
+  public static boolean checkMethodContextAtProlog() {
+    return Octet.getConfig().checkMethodContextAtProlog();
+  }
+  
+  static {
+    
+    if (Velodrome.addPerFieldVelodromeMetadata()) {
+      jtocMetadataReferences = OffsetArray.create(currentNumSlotsInJtocReferences);
+    }
+    
+    Callbacks.addExitMonitor(new ExitMonitor() {
+      public void notifyExit(int value) {  
+        if (Velodrome.recordVelodromeStats()) {
+          printVelodromeStats();
+        }
+      }
+    });
+    
+  }
+  
+  protected static void printVelodromeStats() {
+    VM.sysWriteln("/***************************************************************/");
+    VelodromeStats.numTransactions.report();
+    VelodromeStats.numRegularTransactions.report();
+    VelodromeStats.numUnaryTransactions.report();
+    VelodromeStats.numCrossThreadEdges.report();
+    VelodromeStats.numAccessesTotal.report();
+    VelodromeStats.numAccessesTracked.report();
+    if (VM.VerifyAssertions) { VM._assert(VelodromeStats.numAccessesAvoidedPre.report() == VelodromeStats.numAccessesAvoidedPost.report()); }
+    VM.sysWriteln("/***************************************************************/");
+  }
+  
+  /** Perform activities that are supposed to be carried out during boot time. 
+   * 1) Create a reference to Transaction tib
+   * 2) Read the set of methods that are not to be treated as transactions
+   */
+  @Interruptible
+  public static void boot() {
+    tibForTransaction = ObjectReference.fromObject(dummyTrans).toAddress().loadAddress(JavaHeader.getTibOffset());
+    dummyTrans = null;
+    
+    dummyMap = ReadHashMap.newReadHashMap();
+    Velodrome.tibForReadHashMap = ObjectReference.fromObject(Velodrome.dummyMap).toAddress().loadAddress(JavaHeader.getTibOffset());
+    dummyMap = null;
+    
+    bench = new BenchmarkInfo();
+
+    // Prepare the hash set of methods
+    if (VM.VerifyAssertions) { VM._assert(methodsAsTransactions()); }
+    String prefix = directoryPrefix;
+    if (isPerformanceRun()) { // Performance run, or imprecise analysis in multi-run mode
+      prefix += "atomicity-specifications/";
+    } else {
+      prefix += "exclusion-list/";
+    }
+    readGenericFile(prefix + "methodNames.txt");
+    if (!bench.isMicroBenchmark()) {
+      readIndividualFile(prefix);
+    }
+  }
+  
+  /** This is for all benchmarks excepting DaCapo */
+  @Interruptible
+  private static void readGenericFile(String path) {
+    readFile(new File(path));
+  }
+  
+  /** This method is to read and populate the set of non-transactions. Current invoked only for DaCapo benchmarks. */
+  @Interruptible
+  static void readIndividualFile(String path) {
+    if (VM.VerifyAssertions) { VM._assert(methodsAsTransactions()); }
+    String name = "";
+    if (bench.getId() == BenchmarkInfo.ELEVATOR) { name = "elevator.txt"; }
+    else if (bench.getId() == BenchmarkInfo.PHILO) { name = "philo.txt"; }
+    else if (bench.getId() == BenchmarkInfo.SOR) { name = "sor.txt"; }
+    else if (bench.getId() == BenchmarkInfo.TSP) { name = "tsp.txt"; }
+    else if (bench.getId() == BenchmarkInfo.HEDC) { name = "hedc.txt"; }
+    else if (bench.getId() == BenchmarkInfo.MOLDYN) { name = "moldyn.txt"; }
+    else if (bench.getId() == BenchmarkInfo.MONTECARLO) { name = "montecarlo.txt"; }
+    else if (bench.getId() == BenchmarkInfo.RAYTRACER) { name = "raytracer.txt"; }
+    else if (bench.getId() == BenchmarkInfo.HSQLDB6) { name = "hsqldb6.txt"; }
+    else if (bench.getId() == BenchmarkInfo.ECLIPSE6) { name = "eclipse6.txt"; }
+    else if (bench.getId() == BenchmarkInfo.XALAN6) { name = "xalan6.txt"; }
+    else if (bench.getId() == BenchmarkInfo.LUSEARCH6) { name = "lusearch6.txt"; }
+    else if (bench.getId() == BenchmarkInfo.AVRORA9) { name = "avrora9.txt"; }
+    else if (bench.getId() == BenchmarkInfo.PMD9) { name = "pmd9.txt"; }
+    else if (bench.getId() == BenchmarkInfo.LUINDEX9) { name = "luindex9.txt"; }
+    else if (bench.getId() == BenchmarkInfo.LUSEARCH9_FIXED) { name = "lusearch9.txt"; }
+    else if (bench.getId() == BenchmarkInfo.XALAN9) { name = "xalan9.txt"; }
+    else if (bench.getId() == BenchmarkInfo.SUNFLOW9) { name = "sunflow9.txt"; }
+    else if (bench.getId() == BenchmarkInfo.JYTHON9) { name = "jython9.txt"; }
+    else if (bench.getId() == BenchmarkInfo.RAJA) { name = "raja.txt"; }
+    else { if (VM.VerifyAssertions) { VM._assert(NOT_REACHED);} }
+    readFile(new File(path + name));
+  }
+
+  /** Read method names from the given {@code file}. */
+  @Interruptible
+  private static void readFile(File file) {
+    try {
+      BufferedReader reader = new BufferedReader(new FileReader(file));
+      String line = null;
+      try {
+        while ((line = reader.readLine()) != null) {      
+          if (line.length() == 0 || line.charAt(0) == '#' /*Indicates a comment in the file, ignore*/) { 
+            continue;
+          }
+          String newline = line.substring(0, line.lastIndexOf(":")); // Stripping line and bci information
+          notTransactions.add(Atom.findOrCreateAsciiAtom(newline));
+        } 
+      } catch(IndexOutOfBoundsException e) {
+        VM.sysWriteln("Possibly wrong method name format in exclusion file");
+        VM.sysWriteln("String:", line);
+        VM.sysFail("Possibly wrong method name format in exclusion file");
+      } finally {
+        reader.close(); // Done with reading the file
+      }
+    } catch(IOException e) {
+      VM.sysWrite("Cannot read atomicity specification from file ");
+      VM.sysWriteln(file.getAbsolutePath());
+      VM.sysFail("Exiting");
+    }
+  }
+
+  @Interruptible
+  public static Atom constructMethodSignature(RVMMethod method) {
+    if (VM.VerifyAssertions) { VM._assert(method != null); }
+    if (VM.VerifyAssertions) { VM._assert(method.getDeclaringClass() != null); }
+    String str = method.getDeclaringClass().getDescriptor().toString() + "." +
+        method.getName().toString() + " " + method.getDescriptor().toString();
+    Atom at = Atom.findOrCreateAsciiAtom(str);
+    return at;
+  }
+  
+  @Interruptible
+  public static Atom constructMethodSignature(MethodReference methodRef) {
+    if (VM.VerifyAssertions) { VM._assert(methodRef != null); }
+    String str = methodRef.getType().getName().toString() + "." +
+        methodRef.getName().toString() + " " + methodRef.getDescriptor().toString();
+    Atom at = Atom.findOrCreateAsciiAtom(str);
+    return at;
+  }  
+  
+  @Interruptible
+  public static Atom constructMethodSignature(MethodOperand methOp) {
+    if (VM.VerifyAssertions) { VM._assert(methOp != null); }
+    TypeReference tRef = methOp.getMemberRef().getType();
+    String str = tRef.getName().toString() + "." + methOp.getMemberRef().getName().toString() + 
+        " " + methOp.getMemberRef().getDescriptor().toString();
+    Atom at = Atom.findOrCreateAsciiAtom(str);
+    return at;
+  }
+  
+  /** Check whether the method referenced by <code>methOp</code> is an RVM method, if yes return true. 
+   *  This method does not check MMTk prefixes. */
+  @Interruptible
+  public static boolean isRVMMethod(NormalMethod method, MethodOperand methOp) {
+    if (VM.VerifyAssertions) { VM._assert(method != null); }
+    if (VM.VerifyAssertions) { VM._assert(methOp != null); }
+    TypeReference tRef = methOp.getMemberRef().getType();
+    String str = tRef.getName().toString();
+    // Velodrome: LATER: Improve this, make this generic
+    return (str.indexOf("Lorg/jikesrvm/") >= 0);
+  }
+
+  /** Check whether the method referenced by <code>methOp</code> needs to be instrumented, or not */
+  @Interruptible
+  public static boolean instrumentCalleeMethod(NormalMethod method, MethodOperand methOp) {
+    if (VM.VerifyAssertions) { Octet.shouldInstrumentMethod((RVMMethod)method); }
+    if (VM.VerifyAssertions) { VM._assert(methOp != null); }
+    TypeReference tRef = methOp.getMemberRef().getType();
+    return Octet.shouldInstrumentClass(tRef);
+  }
+  
+  /** Instrument a static field? The parameter is the parent class of the static field. */
+  @Inline @Pure
+  public static boolean shouldAddVelodromeMetadataForStaticField(FieldReference fieldRef) {
+    return Octet.shouldAddMetadataForField(fieldRef);
+  }
+  
+  public static boolean shouldAddPerFieldVelodromeMetadata(RVMField field) {
+    if (field.isFinal()) {
+      return false;
+    }
+    return Octet.shouldInstrumentClass(field.getMemberRef().asFieldReference().getType());
+  }
+
+  @Inline
+  public static int getNumFields(RVMField field) {
+    return NUM_METADATA_FIELDS;
+  }
+  
+  /** Determine whether generational write barriers are required for stores. */
+  @Inline
+  public final static boolean useGenerationalBarriers() {
+    return Barriers.NEEDS_OBJECT_PUTFIELD_BARRIER;
+  }
+  
+  /** 
+   * @param writeOff Write offset of the metadata reference in the JTOC. This should be negative, since we don't want 
+   *                 GC to trace the metadata slots.
+   * @param readOff Read offset of the metadata reference in the JTOC. This should be negative, since we don't want
+   *                 GC to trace the metadata slots.
+   */
+  public static void addStaticOffsets(Offset writeOff, Offset readOff) {
+    if (VM.VerifyAssertions) { VM._assert(writeOff.sLT(Offset.zero()) && readOff.sLT(Offset.zero())); }
+    jtocMetadataReferencesLock.lock();
+    if (jtocMetadataReferencesIndex == currentNumSlotsInJtocReferences) { // Array is full
+      growOffsetArray(currentNumSlotsInJtocReferences << LOG_GROWTH_FACTOR);
+    }
+    jtocMetadataReferences.set(jtocMetadataReferencesIndex++, writeOff);
+    jtocMetadataReferences.set(jtocMetadataReferencesIndex++, readOff);
+    if (VM.VerifyAssertions) { VM._assert(jtocMetadataReferencesIndex % 2 == 0); }
+    jtocMetadataReferencesLock.unlock();
+  }
+
+  private static void growOffsetArray(int newSize) {
+    OffsetArray newArray = createNewOffsetArray(newSize);
+    int i = 0;
+    Offset value;
+    for ( ; i < currentNumSlotsInJtocReferences; i++) {
+       value = jtocMetadataReferences.get(i);
+       if (VM.VerifyAssertions) { VM._assert(value.sLT(Offset.zero()) ); }
+       newArray.set(i, value);
+    }
+    jtocMetadataReferences = newArray;
+    currentNumSlotsInJtocReferences = newSize;
+  }
+  
+  @UninterruptibleNoWarn
+  private static OffsetArray createNewOffsetArray(int size) {
+    MemoryManager.startAllocatingInUninterruptibleCode();
+    OffsetArray newArray = OffsetArray.create(size); 
+    MemoryManager.stopAllocatingInUninterruptibleCode();
+    return newArray;
+  }
+  
+  // Velodrome offset helper methods. The reference metadata for fields are stored in a way that
+  // the read slot comes after the write slot. The reference metadata for statics are stored in primitive slots
+  // in the JTOC, i.e., at negative indices. However, there is no guarantee on the ordering of the read 
+  // and write slots.
+  
+  @Inline
+  static int getReadOffsetForField(int writeOffset) {
+    return (writeOffset + BYTES_IN_ADDRESS);
+  }
+  
+  @Inline
+  static Offset getReadOffsetForField(Offset writeOffset) {
+    return writeOffset.plus(BYTES_IN_ADDRESS);
+  }
+  
+}
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeMetadataHelper.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeMetadataHelper.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeMetadataHelper.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeMetadataHelper.java	2014-04-03 17:43:49.593692144 -0400
@@ -0,0 +1,401 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.Constants;
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.mm.mminterface.Barriers;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.objectmodel.JavaHeader;
+import org.jikesrvm.objectmodel.MiscHeader;
+import org.jikesrvm.octet.OctetBarriers;
+import org.jikesrvm.octet.Site;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Entrypoint;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+
+@Uninterruptible
+public class VelodromeMetadataHelper implements Constants {
+
+  /** Lock bit (LSB) to protect access to field metadata */
+  private static final Word LOCK_BIT = Word.one(); // 000...001
+  private static final Word LOCK_MASK = Word.max().minus(Word.one()); // 111...110
+  
+  public static Object lockFieldMetadata(Address objAddr, Offset writeOffset, boolean isStatic) {
+    Word oldValue = objAddr.loadWord(writeOffset);
+    do {
+      do {
+        oldValue = objAddr.prepareWord(writeOffset);
+      } while (oldValue.and(LOCK_BIT).EQ(LOCK_BIT));    
+    } while (!objAddr.attempt(oldValue, oldValue.or(LOCK_BIT), writeOffset));
+    if (VM.VerifyAssertions) { 
+      VM._assert(!RVMThread.getCurrentThread().betweenPreAndPost);
+      RVMThread.getCurrentThread().betweenPreAndPost = true;
+      RVMThread.getCurrentThread().lockedMetadata = objAddr.loadWord(writeOffset);
+    }
+    
+    return oldValue.toAddress().toObjectReference().toObject();
+  }
+  
+  @Entrypoint
+  public static void unlockResolvedFieldMetadata(Object o, int velodromeOffset, int siteID, int read) {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.insertPostBarriers()); }
+    if (VM.VerifyAssertions) { VM._assert(MemoryManager.validRef(ObjectReference.fromObject(o))); }
+    boolean isRead = (read == 1) ? true : false;
+    Address objAddr = ObjectReference.fromObject(o).toAddress();
+    if (velodromeOffset != Velodrome.UNITIALIZED_OFFSET) {
+      if (VM.VerifyAssertions) { VM._assert(velodromeOffset >= 0); }
+      Offset vOffset = Offset.fromIntSignExtend(velodromeOffset);
+      // An MFENCE is required over here
+      Magic.fence();
+      Address oldValue = objAddr.prepareAddress(vOffset);
+      // Assert that the metadata is indeed locked
+      // Velodrome: LATER: eclipse6 fails here
+      if (VM.VerifyAssertions) { VM._assert(oldValue.toWord().and(LOCK_BIT).EQ(Word.one())); }
+      Address newValue = oldValue.toWord().and(LOCK_MASK).toAddress();
+      Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+      if (Velodrome.useGenerationalBarriers()) {
+        if (isRead) {
+          Barriers.objectFieldWrite(o, newValue.toObjectReference().toObject(), vOffset, 0);
+        } else { // This is the new write
+          Barriers.objectFieldWrite(o, currTx, vOffset, 0);
+        }
+      } else {
+        if (isRead) {
+          objAddr.store(newValue, vOffset);
+        } else {
+          objAddr.store(ObjectReference.fromObject(currTx), vOffset);
+        }
+      }
+      if (VM.VerifyAssertions) {
+        VM._assert(RVMThread.getCurrentThread().betweenPreAndPost);
+        RVMThread.getCurrentThread().betweenPreAndPost = false;
+      }
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPost.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static void unlockUnresolvedFieldMetadata(Object o, int fieldID, int siteID, int read) {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.insertPostBarriers()); }
+    if (VM.VerifyAssertions) { VM._assert(MemoryManager.validRef(ObjectReference.fromObject(o))); }
+    boolean isRead = (read == 1) ? true : false;
+    Address objAddr = ObjectReference.fromObject(o).toAddress();
+    RVMField field = OctetBarriers.handleUnresolvedField(fieldID);
+    if (field.hasVelodromeMetadataOffset()) {
+      Offset writeOffset = field.getWriteMetadataOffset();
+      if (VM.VerifyAssertions) { VM._assert(writeOffset.toInt() >= 0); }
+      Word oldValue = objAddr.prepareWord(writeOffset);
+      // An MFENCE is required over here
+      Magic.fence();
+      // Assert that the metadata is indeed locked
+      if (VM.VerifyAssertions) { VM._assert(oldValue.and(LOCK_BIT).EQ(Word.one())); }
+      Address newValue = oldValue.and(LOCK_MASK).toAddress();
+      if (Velodrome.useGenerationalBarriers()) {
+        if (isRead) {
+          Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), newValue.toObjectReference().toObject(), writeOffset, 0);
+        } else { // This is the new write
+          Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+          Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), currTx, writeOffset, 0);
+        }
+      } else {
+        if (isRead) {
+          objAddr.store(newValue, writeOffset);
+        } else { // This is the new write
+          Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+          objAddr.store(ObjectReference.fromObject(currTx), writeOffset);
+        }
+      }
+      if (VM.VerifyAssertions) {
+        VM._assert(RVMThread.getCurrentThread().betweenPreAndPost);
+        RVMThread.getCurrentThread().betweenPreAndPost = false;
+      }
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPost.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static void unlockMetadataForStaticResolved(Offset velodromeOffset, int fieldID, int siteID, int read) {
+    if (VM.VerifyAssertions) { VM._assert(velodromeOffset.toInt() < 0); }
+    boolean isRead = (read == 1) ? true : false;
+    // Using Magic.getJTOC() seems to be causing problems during opt compilation
+    Address objAddr = Magic.getTocPointer();
+    Word oldValue = objAddr.loadWord(velodromeOffset);
+    // An MFENCE is required over here
+    Magic.fence();
+    // Assert that the metadata is indeed locked
+    if (VM.VerifyAssertions) { VM._assert(oldValue.and(LOCK_BIT).EQ(LOCK_BIT)); }
+    if (Velodrome.useGenerationalBarriers()) {
+      if (isRead) {
+        Address newValue = oldValue.and(LOCK_MASK).toAddress();
+        Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), newValue.toObjectReference().toObject(), velodromeOffset, 0);
+      } else { // This is the new write
+        Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+        Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), currTx, velodromeOffset, 0);
+      }
+    } else {
+      if (isRead) {
+        Address newValue = oldValue.and(LOCK_MASK).toAddress();
+        objAddr.store(newValue, velodromeOffset);
+      } else { // This is the new write
+        Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+        objAddr.store(ObjectReference.fromObject(currTx), velodromeOffset);
+      }
+    }
+    if (VM.VerifyAssertions) {
+      VM._assert(RVMThread.getCurrentThread().betweenPreAndPost);
+      RVMThread.getCurrentThread().betweenPreAndPost = false;
+    }
+  }
+  
+  @Entrypoint
+  public static void unlockMetadataForStaticUnresolved(int fieldID, int siteID, int read) {
+    boolean isRead = (read == 1) ? true : false;
+    // Using Magic.getJTOC() seems to be causing problems during opt compilation
+    Address objAddr = Magic.getTocPointer();
+    RVMField field = OctetBarriers.handleUnresolvedField(fieldID);
+    if (field.hasVelodromeMetadataOffset()) { 
+      Offset writeOffset = field.getWriteMetadataOffset();
+      if (VM.VerifyAssertions) { VM._assert(writeOffset.toInt() < 0); }
+      // An MFENCE is required over here
+      Magic.fence();
+      Word oldValue = objAddr.prepareWord(writeOffset);
+      // Assert that the metadata is indeed locked
+      if (VM.VerifyAssertions) { VM._assert(oldValue.and(LOCK_BIT).EQ(Word.one())); }
+      if (Velodrome.useGenerationalBarriers()) {
+        if (isRead) {
+          Address newValue = oldValue.and(LOCK_MASK).toAddress();
+          Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), newValue.toObjectReference().toObject(), writeOffset, 0);
+        } else { // This is the new write
+          Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+          Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), currTx, writeOffset, 0);
+        }
+      } else {
+        if (isRead) {
+          Address newValue = oldValue.and(LOCK_MASK).toAddress();
+          objAddr.store(newValue, writeOffset);
+        } else { // This is the new write
+          Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+          objAddr.store(ObjectReference.fromObject(currTx), writeOffset);
+        }
+      }
+      if (VM.VerifyAssertions) {
+        VM._assert(RVMThread.getCurrentThread().betweenPreAndPost);
+        RVMThread.getCurrentThread().betweenPreAndPost = false;
+      }
+    } else if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesAvoidedPost.inc(1L);
+    }
+  }
+   
+  public static void updateLastWrite(Address objAddr, Offset writeOffset, Offset readOffset, Transaction lastWrite, int siteID) {
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    Transaction currTx = currentThread.currentTransaction;
+    if (Velodrome.createCrossThreadEdges()) {
+      // Always attempt to create WAR anti dependence edges
+      ObjectReference readMetadata = objAddr.loadObjectReference(readOffset);
+      if (!readMetadata.isNull()) {
+        Address tib = ObjectReference.fromObject(readMetadata).toAddress().loadAddress(JavaHeader.getTibOffset());
+        if (tib.EQ(Velodrome.tibForTransaction)) { // Single read information
+          Transaction lastRead = (Transaction) readMetadata.toObject();
+          TransactionalHBGraph.createRdWrEdge(lastRead, lastRead.siteID, currTx, siteID);
+        } else { // Read map
+          ReadHashMap map = (ReadHashMap) readMetadata.toObject();
+          TransactionalHBGraph.createRdWrEdges(map, currTx, siteID);
+        }
+      } else { // No read information, nothing to do
+      }
+      // Create WAW output dependence edge
+      if (lastWrite != null && currTx != lastWrite) {
+        if (VM.VerifyAssertions && currentThread == lastWrite.octetThread) {
+          VM._assert(currTx.transactionID > lastWrite.transactionID); 
+        } 
+        TransactionalHBGraph.createWrWrEdge(lastWrite, lastWrite.siteID, currTx, siteID);
+      }
+    }
+    // Velodrome: LATER: Do we require a generational store here? Probably not.
+    if (Velodrome.useGenerationalBarriers()) {
+      Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), ObjectReference.nullReference().toObject(), readOffset, 0);
+    } else {
+      objAddr.store(ObjectReference.nullReference(), readOffset); // Clear all reads
+    }
+    // We update the current write in the post barrier
+    // Test that the write metadata lock bit is still set
+    if (VM.VerifyAssertions) { VM._assert(objAddr.loadAddress(writeOffset).toWord().and(LOCK_BIT).EQ(LOCK_BIT)); }
+  }
+  
+  /** This is the first read to an object (maybe after a write). This is indicated by the readMetadata offset being 
+   *  equal to zero. */
+  public static void setOnlyRead(Address objAddr, Offset writeOffset, Offset readOffset, Transaction lastWrite, int siteID) {
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    Transaction currTx = currentThread.currentTransaction;
+    if (Velodrome.createCrossThreadEdges() && lastWrite != null) {
+      // Always attempt to create RAW true dependence edge
+      TransactionalHBGraph.createWrRdEdge(lastWrite, lastWrite.siteID, currTx, siteID);
+    }
+    if (Velodrome.useGenerationalBarriers()) {
+      Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), currTx, readOffset, 0);
+    } else {
+      objAddr.store(ObjectReference.fromObject(currTx), readOffset);
+    }
+    // Test that the write metadata lock bit is still set
+    if (VM.VerifyAssertions) { VM._assert(objAddr.loadAddress(writeOffset).toWord().and(LOCK_BIT).EQ(LOCK_BIT)); }
+  }
+  
+  /** If the read metadata offset already contains a data, then it is expected to be a reference to a Transaction. The
+   *  current read is then the second read. In such cases, the single reference is updated to a Read map. */
+  public static void upgradeToReadHashMap(Address objAddr, Offset writeOffset, Offset readOffset, Transaction lastRead, 
+      Transaction lastWrite, int siteID) {
+    if (VM.VerifyAssertions) { VM._assert(lastRead != null); }
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    Transaction currentTx = currentThread.currentTransaction;
+    if (lastRead.octetThread != currentThread) {
+      if (Velodrome.createCrossThreadEdges() && lastWrite != null && lastWrite.octetThread != lastRead.octetThread) {
+        if (VM.VerifyAssertions) {
+          // No cross-thread edges are created for driver threads in DaCapo and Tsp
+          if (Velodrome.bench.getId() == BenchmarkInfo.TSP &&
+              (lastWrite.octetThread.octetThreadID != Velodrome.TSP_DRIVER_THREAD_OCTET_ID &&
+              lastRead.octetThread.octetThreadID != Velodrome.TSP_DRIVER_THREAD_OCTET_ID)) {
+            VM._assert(TransactionalHBGraph.isCrossThreadEdgeAlreadyPresent(lastWrite, lastRead));
+          }
+          if (Velodrome.bench.isDaCapoBenchmark() && 
+              (lastWrite.octetThread.octetThreadID != Velodrome.DACAPO_DRIVER_THREAD_OCTET_ID 
+              && lastRead.octetThread.octetThreadID != Velodrome.DACAPO_DRIVER_THREAD_OCTET_ID)) {
+            VM._assert(TransactionalHBGraph.isCrossThreadEdgeAlreadyPresent(lastWrite, lastRead)); 
+          }
+          if (Velodrome.bench.getId() != BenchmarkInfo.TSP && !Velodrome.bench.isDaCapoBenchmark()) {
+            VM._assert(TransactionalHBGraph.isCrossThreadEdgeAlreadyPresent(lastWrite, lastRead)); 
+          }
+        }
+        // Always attempt to create RAW true dependence edge
+        TransactionalHBGraph.createWrRdEdge(lastWrite, lastWrite.siteID, currentTx, siteID);
+      }
+      ReadHashMap map = ReadHashMap.newReadHashMap();
+      ReadHashMapElement elem1 = ReadHashMap.newReadHashMapElement(lastRead, lastRead.siteID);
+      map.put(elem1);
+      Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+      ReadHashMapElement elem2 = ReadHashMap.newReadHashMapElement(currTx, siteID);
+      map.put(elem2);
+      if (Velodrome.useGenerationalBarriers()) {
+        Barriers.objectFieldWrite(objAddr.toObjectReference().toObject(), map, readOffset, 0);
+      } else {
+        objAddr.store(ObjectReference.fromObject(map), readOffset);
+      }
+    } else { // Same thread performing the second read, so no need to upgrade to a map immediately
+      if (VM.VerifyAssertions) { VM._assert(currentTx.transactionID >= lastRead.transactionID); }
+      if (currentTx.transactionID > lastRead.transactionID) {
+        setOnlyRead(objAddr, writeOffset, readOffset, lastWrite, siteID);
+      } else { // Same transaction        
+        if (Velodrome.createCrossThreadEdges() && VM.VerifyAssertions && lastWrite != null && lastWrite.octetThread != currentThread) {
+          VM._assert(currentTx == lastRead);
+          // No cross-thread edges are created for driver threads in DaCapo and Tsp
+          if (Velodrome.bench.getId() == BenchmarkInfo.TSP && 
+              (lastWrite.octetThread.octetThreadID != Velodrome.TSP_DRIVER_THREAD_OCTET_ID &&
+              lastRead.octetThread.octetThreadID != Velodrome.TSP_DRIVER_THREAD_OCTET_ID)) {
+            VM._assert(TransactionalHBGraph.isCrossThreadEdgeAlreadyPresent(lastWrite, lastRead));
+          }
+          if (Velodrome.bench.isDaCapoBenchmark() && 
+              (lastWrite.octetThread.octetThreadID != Velodrome.DACAPO_DRIVER_THREAD_OCTET_ID 
+              && lastRead.octetThread.octetThreadID != Velodrome.DACAPO_DRIVER_THREAD_OCTET_ID)) {
+            VM._assert(TransactionalHBGraph.isCrossThreadEdgeAlreadyPresent(lastWrite, lastRead)); 
+          }
+          if (Velodrome.bench.getId() != BenchmarkInfo.TSP && !Velodrome.bench.isDaCapoBenchmark()) {
+            VM._assert(TransactionalHBGraph.isCrossThreadEdgeAlreadyPresent(lastWrite, lastRead)); 
+          }
+        }
+      }
+    }
+    // Test that the write metadata lock bit is still set
+    if (VM.VerifyAssertions) { VM._assert(objAddr.loadAddress(writeOffset).toWord().and(LOCK_BIT).EQ(LOCK_BIT)); }
+  }
+  
+  public static void appendCurrentRead(Address objAddr, Offset writeOffset, Offset readOffset, Transaction lastWrite, int siteID) {
+    RVMThread currentThread = RVMThread.getCurrentThread();
+    Transaction currTx = currentThread.currentTransaction;
+    if (Velodrome.createCrossThreadEdges() && lastWrite != null) {
+      // Always attempt to create RAW true dependence edge
+      TransactionalHBGraph.createWrRdEdge(lastWrite, lastWrite.siteID, currTx, siteID);
+    }
+    if (VM.VerifyAssertions) { 
+      Address tib = objAddr.loadAddress(readOffset).loadAddress(JavaHeader.getTibOffset()); 
+      VM._assert(!tib.EQ(Velodrome.tibForTransaction));
+    } 
+    ReadHashMap map = (ReadHashMap) objAddr.loadObjectReference(readOffset).toObject();
+    ReadHashMapElement elem1 = ReadHashMap.newReadHashMapElement(currTx, siteID);
+    map.put(elem1);
+    // Test that the write metadata lock bit is still set
+    if (VM.VerifyAssertions) { VM._assert(objAddr.loadAddress(writeOffset).toWord().and(LOCK_BIT).EQ(LOCK_BIT)); }
+  }
+  
+  /** Track lock acquire */
+  // Since the lock is already acquired, therefore we can safely perform the read of the lock metadata
+  public static void trackLockAcquire(Object o) {
+    Transaction current = RVMThread.getCurrentThread().currentTransaction;
+    // Create edge from last release 
+    Address addr = ObjectReference.fromObject(o).toAddress().loadAddress(MiscHeader.VELODROME_OFFSET);
+    if (addr.NE(Address.zero())) {
+      Transaction lastTransaction = (Transaction) addr.toObjectReference().toObject();
+      TransactionalHBGraph.createLockReleaseAcquireEdge(lastTransaction, current);
+    } else { // This is the first acquire 
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+      VelodromeStats.numAccessesTracked.inc(1L);
+    }
+  }
+
+  /** Track lock release */
+  // Since the lock is still acquired, therefore we can safely write to the lock metadata
+  public static void trackLockRelease(Object o) {
+    Transaction current = RVMThread.getCurrentThread().currentTransaction;
+    if (Velodrome.useGenerationalBarriers()) {
+      Barriers.objectFieldWrite(o, current, MiscHeader.VELODROME_OFFSET, 0);
+    } else {
+      ObjectReference.fromObject(o).toAddress().store(ObjectReference.fromObject(current), MiscHeader.VELODROME_OFFSET);
+    }
+    if (Velodrome.recordVelodromeStats()) {
+      VelodromeStats.numAccessesTotal.inc(1L);
+      VelodromeStats.numAccessesTracked.inc(1L);
+    }
+  }
+  
+  @Entrypoint
+  public static void arrayPostBarrier(Object o, int index, int siteID, int read) {
+    if (VM.VerifyAssertions) { VM._assert(Velodrome.insertPostBarriers() && Velodrome.instrumentArrays()); }
+    if (VM.VerifyAssertions) { VM._assert(MemoryManager.validRef(ObjectReference.fromObject(o))); }
+    boolean isRead = (read == 1) ? true : false;
+    Address objAddr = ObjectReference.fromObject(o).toAddress();
+    Offset writeOffset = MiscHeader.VELODROME_WRITE_OFFSET;
+    // An MFENCE is required over here
+    Magic.fence();
+    Address oldValue = objAddr.prepareAddress(writeOffset);
+    // Assert that the metadata is indeed locked
+    if (VM.VerifyAssertions) { VM._assert(oldValue.toWord().and(LOCK_BIT).EQ(Word.one())); }
+    Address newValue = oldValue.toWord().and(LOCK_MASK).toAddress();
+    Transaction currTx = RVMThread.getCurrentThread().currentTransaction;
+    if (Velodrome.useGenerationalBarriers()) {
+      if (isRead) {
+        Barriers.objectFieldWrite(o, newValue.toObjectReference().toObject(), writeOffset, 0);
+      } else { // This is the new write
+        Barriers.objectFieldWrite(o, currTx, writeOffset, 0);
+      }
+    } else {
+      if (isRead) {
+        objAddr.store(newValue, writeOffset);
+      } else {
+        objAddr.store(ObjectReference.fromObject(currTx), writeOffset);
+      }
+    }
+    if (VM.VerifyAssertions) {
+      VM._assert(RVMThread.getCurrentThread().betweenPreAndPost);
+      RVMThread.getCurrentThread().betweenPreAndPost = false;
+    }
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeStats.java workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeStats.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/velodrome/VelodromeStats.java	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/velodrome/VelodromeStats.java	2014-04-03 17:43:49.592692143 -0400
@@ -0,0 +1,79 @@
+package org.jikesrvm.velodrome;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Uninterruptible;
+
+@Uninterruptible
+public class VelodromeStats {
+  
+  // Related to transactions
+  public static final VelodromeThreadSafeCounter numTransactions = new VelodromeThreadSafeCounter("VelodromeNodes");
+  public static final VelodromeThreadSafeCounter numRegularTransactions = new VelodromeThreadSafeCounter("VelodromeNumRegularTransactions");
+  public static final VelodromeThreadSafeCounter numUnaryTransactions = new VelodromeThreadSafeCounter("VelodromeNumUnaryTransactions");
+
+  // Cross-thread edges
+  public static final VelodromeThreadSafeCounter numCrossThreadEdges = new VelodromeThreadSafeCounter("VelodromeNumCrossThreadEdges");
+
+  // Total accesses
+  public static final VelodromeThreadSafeCounter numAccessesTotal = new VelodromeThreadSafeCounter("VelodromeNumAccessesTotal");
+  public static final VelodromeThreadSafeCounter numAccessesTracked = new VelodromeThreadSafeCounter("VelodromeNumAccessesTracked");
+  public static final VelodromeThreadSafeCounter numAccessesAvoidedPre = new VelodromeThreadSafeCounter("VelodromeNumAccessedAvoidedPre");
+  public static final VelodromeThreadSafeCounter numAccessesAvoidedPost = new VelodromeThreadSafeCounter("VelodromeNumAccessesAvoidedPost");
+  
+  // Inner class definitions
+
+  @Uninterruptible
+  public static class VelodromeThreadSafeCounter {
+    
+    private final long[] values;
+    final String name;
+    
+    VelodromeThreadSafeCounter(String name) {
+      this.name = name;
+      values = Velodrome.recordVelodromeStats() ? new long[RVMThread.MAX_THREADS] : null;
+    }
+    
+    @Inline
+    public void inc(long value) {
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.recordVelodromeStats()); }
+      if (VM.runningVM) {
+        // Do not increment dynamic stats if we are not in Harness, but inHarness() is false, why?
+        if (MemoryManager.inHarness()) { // Remember to change this in two places
+          values[RVMThread.getCurrentThreadSlot()] += value;
+        } 
+      }
+    }
+    
+    @Inline
+    public void inc(RVMThread thread, long value) {
+      if (VM.VerifyAssertions) { VM._assert(Velodrome.recordVelodromeStats()); }
+      if (VM.runningVM) {
+        // Do not increment dynamic stats if we are not in Harness, but inHarness() is false, why?
+        if (MemoryManager.inHarness()) { // Remember to change this in two places
+          values[thread.getGivenThreadSlot()] += value;
+        }
+      }
+    }
+    
+    @Inline
+    final long total() {
+      long total = 0;
+      for (long value : values) {
+        total += value;
+      }
+      return total;
+    }
+    
+    final long report() {
+      VM.sysWrite("VelodromeStats:", this.name, ": ");
+      long total = total(); 
+      VM.sysWriteln(total);
+      return total;
+    }
+    
+  }
+  
+}
diff -rupN workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/VM.java workspace/velodrome-sound/rvm/src/org/jikesrvm/VM.java
--- workspace/jikesrvm-3.1.3/rvm/src/org/jikesrvm/VM.java	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src/org/jikesrvm/VM.java	2014-04-03 17:43:45.325678120 -0400
@@ -12,15 +12,17 @@
  */
 package org.jikesrvm;
 
+import static org.jikesrvm.runtime.SysCall.sysCall;
+
 import org.jikesrvm.ArchitectureSpecific.ThreadLocalState;
 import org.jikesrvm.adaptive.controller.Controller;
 import org.jikesrvm.adaptive.util.CompilerAdvice;
 import org.jikesrvm.classloader.Atom;
 import org.jikesrvm.classloader.BootstrapClassLoader;
+import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMClass;
 import org.jikesrvm.classloader.RVMClassLoader;
 import org.jikesrvm.classloader.RVMMember;
-import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.TypeDescriptorParsing;
 import org.jikesrvm.classloader.TypeReference;
@@ -28,20 +30,19 @@ import org.jikesrvm.compilers.baseline.B
 import org.jikesrvm.compilers.common.BootImageCompiler;
 import org.jikesrvm.compilers.common.RuntimeCompiler;
 import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.octet.Octet;
 import org.jikesrvm.runtime.BootRecord;
 import org.jikesrvm.runtime.DynamicLibrary;
 import org.jikesrvm.runtime.Entrypoints;
 import org.jikesrvm.runtime.ExitStatus;
+import org.jikesrvm.runtime.FileSystem;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
 import org.jikesrvm.runtime.SysCall;
-
-import static org.jikesrvm.runtime.SysCall.sysCall;
 import org.jikesrvm.scheduler.Lock;
 import org.jikesrvm.scheduler.MainThread;
-import org.jikesrvm.scheduler.Synchronization;
 import org.jikesrvm.scheduler.RVMThread;
-import org.jikesrvm.runtime.FileSystem;
+import org.jikesrvm.scheduler.Synchronization;
 import org.jikesrvm.tuningfork.TraceEngine;
 import org.vmmagic.pragma.Entrypoint;
 import org.vmmagic.pragma.Inline;
@@ -129,6 +130,10 @@ public class VM extends Properties imple
     sysWriteLockOffset = Entrypoints.sysWriteLockField.getOffset();
     if (verboseBoot >= 1) VM.sysWriteln("Booting");
 
+    // Velodrome: Adding a non-standard argument to identify benchmark category
+    benchmarkCategory = BootRecord.the_boot_record.benchmarkCategory;
+    if (VM.VerifyAssertions) { VM._assert(benchmarkCategory >= 0); }
+
     // Set up the current RVMThread object.  The bootstrap program
     // has placed a pointer to the current RVMThread in a special
     // register.
@@ -402,6 +407,15 @@ public class VM extends Properties imple
 
     // Inform interested subsystems that VM is fully booted.
     VM.fullyBooted = true;
+
+    // Octet: perform startup activities. It is important that boot() is called after the variable fullyBooted is set,
+    // otherwise there could be issues faced with class loading. For example, consider that a client analysis that 
+    // overrides boot() and wants to read from a file, say using the following logic: 
+    // BufferedReader reader = new BufferedReader(new FileReader(file));
+    // During such cases, the class will be resolved, and resolution might fail in BootstrapClassLoader.findClass() 
+    // since fullyBooted is not set yet.
+    Octet.boot();
+
     MemoryManager.fullyBootedVM();
     BaselineCompiler.fullyBootedVM();
     TraceEngine.engine.fullyBootedVM();
diff -rupN workspace/jikesrvm-3.1.3/rvm/src-generated/options/BooleanOptions.opt.dat workspace/velodrome-sound/rvm/src-generated/options/BooleanOptions.opt.dat
--- workspace/jikesrvm-3.1.3/rvm/src-generated/options/BooleanOptions.opt.dat	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src-generated/options/BooleanOptions.opt.dat	2014-04-03 17:43:41.414665260 -0400
@@ -102,6 +102,8 @@ Turn whiles into untils
 ##########
 # Simple escape optimization options
 ##########
+# Octet: enable method summaries for escape analysis at all opt levels (was ESCAPE_SIMPLE_IPA -1 false)
+# Octet: TODO: disabling for now since it seems to be completely broken (was 0 true)
 ESCAPE_SIMPLE_IPA -1 false
 Eagerly compute method summaries for simple escape analysis
 
@@ -321,3 +323,6 @@ Enable detailed debugging statements for
 DEBUG_GCP -1 false
 Perform noisy global code placement
 
+# Octet: Command-line option(s)
+VISUALIZE_CFG -1 false
+Visualize CFGs of methods.
diff -rupN workspace/jikesrvm-3.1.3/rvm/src-generated/options/BooleanOptions.vm.dat workspace/velodrome-sound/rvm/src-generated/options/BooleanOptions.vm.dat
--- workspace/jikesrvm-3.1.3/rvm/src-generated/options/BooleanOptions.vm.dat	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src-generated/options/BooleanOptions.vm.dat	2014-04-03 17:43:41.414665260 -0400
@@ -38,3 +38,6 @@ Trace when calls into JNI happen
 countThreadTransitions false
 Count, and report, the number of thread state transitions.  This works better on IA32 than on PPC at the moment.
 
+# Octet: command-line option(s)
+octetForceHardAffinity false
+Force each Octet thread to be bound to its own processor. All Octet threads are distributed evenly across cpuID 0 to n-1 for n available processors.
diff -rupN workspace/jikesrvm-3.1.3/rvm/src-generated/options/ValueOptions.vm.dat workspace/velodrome-sound/rvm/src-generated/options/ValueOptions.vm.dat
--- workspace/jikesrvm-3.1.3/rvm/src-generated/options/ValueOptions.vm.dat	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src-generated/options/ValueOptions.vm.dat	2014-04-03 17:43:41.412665254 -0400
@@ -72,3 +72,25 @@ V forceOneCPU int -1
 Force all threads to run on one CPU.  The argument specifies which CPU (starting from 0).
 
 
+# Octet: command-line options
+# Octet: TODO: the change from 100 to 300 was part of the counter branch; I'm not sure if the results were conclusive enough to support changing it.
+# In any case, it's unrelated to RBA.
+V octetWaitSpinCount int 300
+When waiting, how many spin loops to do before switching to pthread yield?
+
+
+V octetWaitYieldCount int 1
+When waiting, how many yields to do before switching to a pthread condition wait?
+
+
+V octetIODir String null
+Where to store the visualized CFGS, plus potentially other input/output files
+
+
+V staticRaceDir String null
+Path where Chord static race detection output is present
+
+
+V benchmarkName String null
+Name of the benchmark that is currently being executed 
+
diff -rupN workspace/jikesrvm-3.1.3/rvm/src-generated/opt-ir/OperatorList.dat workspace/velodrome-sound/rvm/src-generated/opt-ir/OperatorList.dat
--- workspace/jikesrvm-3.1.3/rvm/src-generated/opt-ir/OperatorList.dat	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src-generated/opt-ir/OperatorList.dat	2014-04-03 17:43:41.129664323 -0400
@@ -470,9 +470,10 @@ none
 
 
 # memory fence
+# Octet: LATER: We added the "acquire" attribute here. This seems like a Jikes bug.
 FENCE
 Empty
-memAsLoad | memAsStore | release
+memAsLoad | memAsStore | release | acquire
 
 
 
diff -rupN workspace/jikesrvm-3.1.3/rvm/src-generated/vm-configuration/Configuration.template workspace/velodrome-sound/rvm/src-generated/vm-configuration/Configuration.template
--- workspace/jikesrvm-3.1.3/rvm/src-generated/vm-configuration/Configuration.template	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src-generated/vm-configuration/Configuration.template	2014-04-03 17:43:41.016663952 -0400
@@ -119,4 +119,12 @@ public abstract class Configuration {
    * run Jikes with only one processor.
    */
   public static final boolean AlignmentChecking = @_RVM_WITH_ALIGNMENT_CHECKING_@;
+  
+  // Octet: build-time option: configuration class
+  public static final org.jikesrvm.config.BaseConfig octetConfig = new @_RVM_WITH_CONFIG_CLASS_@();
+  static {
+    if (VM.VerifyAssertions) {
+      System.out.println("config name = @_RVM_WITH_CONFIG_CLASS_@");
+    }
+  }
 }
diff -rupN workspace/jikesrvm-3.1.3/rvm/src-generated/vm-configuration/HeapLayoutConstants.template workspace/velodrome-sound/rvm/src-generated/vm-configuration/HeapLayoutConstants.template
--- workspace/jikesrvm-3.1.3/rvm/src-generated/vm-configuration/HeapLayoutConstants.template	2013-02-12 13:28:47.000000000 -0500
+++ workspace/velodrome-sound/rvm/src-generated/vm-configuration/HeapLayoutConstants.template	2014-04-03 17:43:41.017663956 -0400
@@ -35,11 +35,16 @@ public interface HeapLayoutConstants {
   Address MAXIMUM_MAPPABLE =
     Address.@_ADDRESS_METHOD_@( @_MAXIMUM_MAPPABLE_ADDRESS_@ );
 
+  // Octet: Now, we no longer need to tinker with HeapLayoutConstants.template file even if we make  
+  // changes to the address ranges in x86_64-linux.properties
+
   /** The maximum boot image data size */
-  int BOOT_IMAGE_DATA_SIZE = 56<<20;
+  int BOOT_IMAGE_DATA_SIZE = (BOOT_IMAGE_CODE_START.diff(BOOT_IMAGE_DATA_START).toInt());
+  //int BOOT_IMAGE_DATA_SIZE = 56<<20;
 
   /** The maximum boot image code size */
-  int BOOT_IMAGE_CODE_SIZE = 24<<20;
+  int BOOT_IMAGE_CODE_SIZE = (BOOT_IMAGE_RMAP_START.diff(BOOT_IMAGE_CODE_START).toInt());
+  //int BOOT_IMAGE_CODE_SIZE = 24<<20;
 
   /* Typical compression ratio is about 1/20 */
   int BAD_MAP_COMPRESSION = 5;  // conservative heuristic
diff -rupN workspace/jikesrvm-3.1.3/tools/bootImageRunner/bootImageRunner.h workspace/velodrome-sound/tools/bootImageRunner/bootImageRunner.h
--- workspace/jikesrvm-3.1.3/tools/bootImageRunner/bootImageRunner.h	2013-02-12 13:28:51.000000000 -0500
+++ workspace/velodrome-sound/tools/bootImageRunner/bootImageRunner.h	2014-04-03 17:43:40.930663668 -0400
@@ -81,6 +81,9 @@ unsigned int parse_memory_size(
 
 extern int verboseBoot;
 
+// Velodrome: Adding a non-standard argument to identify benchmark category
+extern int benchmarkCategory;
+
 /* define in sys.c, used in libvm.c */
 extern void sysInitialize();
 
diff -rupN workspace/jikesrvm-3.1.3/tools/bootImageRunner/cmdLine.h workspace/velodrome-sound/tools/bootImageRunner/cmdLine.h
--- workspace/jikesrvm-3.1.3/tools/bootImageRunner/cmdLine.h	2013-02-12 13:28:51.000000000 -0500
+++ workspace/velodrome-sound/tools/bootImageRunner/cmdLine.h	2014-04-03 17:43:40.909663600 -0400
@@ -37,8 +37,10 @@ static const int BASE_INDEX             
 static const int OPT_INDEX                     = BASE_INDEX+1;
 static const int VMCLASSES_INDEX               = OPT_INDEX+1;
 static const int PROCESSORS_INDEX              = VMCLASSES_INDEX+1;
+// Velodrome: Adding a non-standard argument to identify benchmark category
+static const int BENCHMARKCATEGORY_INDEX       = PROCESSORS_INDEX+1;
 
-static const int numNonstandardArgs      = PROCESSORS_INDEX+1;
+static const int numNonstandardArgs      = BENCHMARKCATEGORY_INDEX+1;
 
 static const char* nonStandardArgs[numNonstandardArgs] = {
    "-X",
@@ -59,6 +61,7 @@ static const char* nonStandardArgs[numNo
    "-X:opt",
    "-X:vmClasses=",
    "-X:availableProcessors=",
+   "-X:benchmarkCategory=", // Velodrome: Adding a non-standard argument to identify benchmark category
 };
 
 // a NULL-terminated list.
@@ -66,6 +69,8 @@ static const char* nonStandardUsage[] = 
    "  -X                         Print usage on nonstandard options",
    "  -X:verbose                 Print out additional lowlevel information",
    "  -X:verboseBoot=<number>    Print out messages while booting VM",
+   // Velodrome: Adding a non-standard argument to identify benchmark category
+   "  -X:benchmarkCategory=<num> Velodrome specific, pass benchmark identification information to the RVM, check EXP for values",
    "  -Xms<number><unit>         Initial size of heap",
    "  -Xmx<number><unit>         Maximum size of heap",
    "  -X:sysLogfile=<filename>   Write standard error message to <filename>",
diff -rupN workspace/jikesrvm-3.1.3/tools/bootImageRunner/ia32/libvm.c workspace/velodrome-sound/tools/bootImageRunner/ia32/libvm.c
--- workspace/jikesrvm-3.1.3/tools/bootImageRunner/ia32/libvm.c	2013-02-12 13:28:51.000000000 -0500
+++ workspace/velodrome-sound/tools/bootImageRunner/ia32/libvm.c	2014-04-03 17:43:40.839663370 -0400
@@ -679,6 +679,12 @@ hardwareTrapHandler(int signo, siginfo_t
             fprintf(SysTraceFile,
                      "%s: internal error: recursive use of"
                     " hardware exception registers (exiting)\n", Me);
+
+         /* Octet: print an alternative debugging strategy */
+         fprintf(SysTraceFile,
+                 "If this error report doesn't help you, try disabling "
+                 "this block (search Jikes for \"Test for recursive errors\").\n", Me);
+
         /*
          * Things went badly wrong, so attempt to generate a useful error dump
          * before exiting by returning to Scheduler.dumpStackAndDie passing
@@ -832,7 +838,8 @@ softwareSignalHandler(int signo,
                       void *context)
 {
     // asynchronous signal used to awaken internal debugger
-    if (signo == SIGQUIT) {
+    // Octet: make it possible to debug when running from EXP (by sending SIGABRT)
+    if (signo == SIGQUIT || signo == SIGABRT) {
         // Turn on debug-request flag.
         // Note that "jtoc" is not necessarily valid, because we might have interrupted
         // C-library code, so we use boot image jtoc address (== VmToc) instead.
@@ -1051,6 +1058,8 @@ createVM(void)
     bootRecord->bootImageRMapStart   = (Address) bootRMapRegion;
     bootRecord->bootImageRMapEnd     = (Address) bootRMapRegion + roundedRMapRegionSize;
     bootRecord->verboseBoot      = verboseBoot;
+    // Velodrome: Adding a non-standard argument to identify benchmark category
+    bootRecord->benchmarkCategory = benchmarkCategory;
 
     /* write sys.C linkage information into boot record */
 
@@ -1151,6 +1160,12 @@ createVM(void)
         fprintf(SysErrorFile, "%s: sigaction failed (errno=%d)\n", Me, errno);
         return 1;
     }
+    // Octet: help debugging by enabling sending SIGABRT to JikesRVM when running inside EXP, and getting a stack dump
+    if (sigaction (SIGABRT, &action, 0)) { /* catch ABRT to invoke debugger
+                                            * thread */
+        fprintf(SysErrorFile, "%s: sigaction failed (errno=%d)\n", Me, errno);
+        return 1;
+    }
     if (sigaction (SIGTERM, &action, 0)) { /* catch TERM to dump and die */
         fprintf(SysErrorFile, "%s: sigaction failed (errno=%d)\n", Me, errno);
         return 1;
diff -rupN workspace/jikesrvm-3.1.3/tools/bootImageRunner/ppc/libvm.c workspace/velodrome-sound/tools/bootImageRunner/ppc/libvm.c
--- workspace/jikesrvm-3.1.3/tools/bootImageRunner/ppc/libvm.c	2013-02-12 13:28:51.000000000 -0500
+++ workspace/velodrome-sound/tools/bootImageRunner/ppc/libvm.c	2014-04-03 17:43:40.910663604 -0400
@@ -1210,6 +1210,8 @@ createVM(void)
     bootRecord.bootImageRMapStart   = (Address) bootRMapRegion;
     bootRecord.bootImageRMapEnd     = (Address) bootRMapRegion + roundedRMapRegionSize;
     bootRecord.verboseBoot      = verboseBoot;
+    // Velodrome: Adding a non-standard argument to identify benchmark category
+    bootRecord.benchmarkCategory = benchmarkCategory;
 
     // set host o/s linkage information into boot record
     //
diff -rupN workspace/jikesrvm-3.1.3/tools/bootImageRunner/RunBootImage.C workspace/velodrome-sound/tools/bootImageRunner/RunBootImage.C
--- workspace/jikesrvm-3.1.3/tools/bootImageRunner/RunBootImage.C	2013-02-12 13:28:51.000000000 -0500
+++ workspace/velodrome-sound/tools/bootImageRunner/RunBootImage.C	2014-04-03 17:43:40.836663361 -0400
@@ -72,6 +72,8 @@ uint64_t initialHeapSize;       /* Decla
 uint64_t maximumHeapSize;       /* Declared in bootImageRunner.h */
 
 int verboseBoot;                /* Declared in bootImageRunner.h */
+// Velodrome: Adding a non-standard argument to identify benchmark category
+int benchmarkCategory;			    /* Declared in bootImageRunner.h */
 
 static int DEBUG = 0;                   // have to set this from a debugger
 static const unsigned BYTES_IN_PAGE = MMTk_Constants_BYTES_IN_PAGE;
@@ -227,6 +229,31 @@ processCommandLineArguments(const char *
             verboseBoot = vb;
             continue;
         }
+        // Velodrome: Adding a non-standard argument to identify benchmark category
+        // "-X:benchmarkCategory=" is of 21 characters
+        if (strnequal(token, nonStandardArgs[BENCHMARKCATEGORY_INDEX], 21)) {
+            subtoken = token + 21;
+            errno = 0;
+            char *endp;
+            long bc = strtol(subtoken, &endp, 0);
+            while (*endp && isspace(*endp)) // gobble trailing spaces
+                ++endp;
+
+            if (bc < 0) {
+                fprintf(SysTraceFile, "%s: \"%s\": You may not specify a negative benchmarkCategory value\n", Me, token);
+                *fastExit = true; break;
+            } else if (errno == ERANGE
+                       || bc > INT_MAX ) {
+                fprintf(SysTraceFile, "%s: \"%s\": too big a number to represent internally\n", Me, token);
+                *fastExit = true; break;
+            } else if (*endp) {
+                fprintf(SysTraceFile, "%s: \"%s\": I don't recognize \"%s\" as a number\n", Me, token, subtoken);
+                *fastExit = true; break;
+            }
+
+            benchmarkCategory = bc;
+            continue;
+        }
         /*  Args that don't apply to us (from the Sun JVM); skip 'em. */
         if (strequal(token, "-server"))
             continue;
diff -rupN workspace/jikesrvm-3.1.3/tools/bootImageRunner/sys.C workspace/velodrome-sound/tools/bootImageRunner/sys.C
--- workspace/jikesrvm-3.1.3/tools/bootImageRunner/sys.C	2013-02-12 13:28:51.000000000 -0500
+++ workspace/velodrome-sound/tools/bootImageRunner/sys.C	2014-04-03 17:43:40.908663596 -0400
@@ -1565,7 +1565,11 @@ sysMalloc(int length)
 {
     void *result=malloc(length);
     if (inRVMAddressSpace((Address)result)) {
-      fprintf(stderr,"malloc returned something that is in RVM address space: %p\n",result);
+      // Octet: avoid complaining about memory range that isn't actually an overlap error
+      // Octet: TODO: implement a better change
+      if ((int)result < 0x40000000 || (int)result >= 0x48000000) {
+        fprintf(stderr,"malloc returned something that is in RVM address space: %p\n",result);
+      }
     }
     return result;
 }
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/avrora9.txt workspace/velodrome-sound/velodrome/atomicity-specifications/avrora9.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/avrora9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/avrora9.txt	2014-04-03 17:43:57.383717735 -0400
@@ -0,0 +1,37 @@
+# Trivially left out
+Lavrora/Main;.main ([Ljava/lang/String;)V:100(0)
+Lavrora/sim/SimulatorThread;.run ()V:96(0)
+Lavrora/sim/Simulator;.start ()V:522(9)
+Lavrora/actions/Action;.run ()V:67(0)
+Lavrora/actions/SimAction;.run ([Ljava/lang/String;)V:84(0)
+Lavrora/sim/Simulation;.join ()V:505(0)
+Lavrora/sim/clock/Synchronizer;.join ()V:87(0)
+Lavrora/sim/clock/RippleSynchronizer;.join ()V:221(0)
+
+# Merged results
+
+Lavrora/arch/legacy/LegacyInterpreter;.fastLoop ()V:251(0)
+Lavrora/arch/legacy/LegacyInterpreter;.runLoop ()V:82(0)
+Lavrora/arch/legacy/LegacyInterpreter;.sleepLoop ()V:244(0)
+Lavrora/sim/AtmelInterpreter;.advanceClock (J)V:522(0)
+Lavrora/sim/AtmelInterpreter;.commit ()V:1057(-2)
+Lavrora/sim/AtmelInterpreter;.start ()V:381(0)
+Lavrora/sim/clock/DeltaQueue;.advance (J)V:238(0)
+Lavrora/sim/clock/DeltaQueue;.advanceSlow (J)V:274(0)
+Lavrora/sim/clock/DeltaQueue$Link;.fire ()V:123(-2)
+Lavrora/sim/clock/DeltaQueue;.skipAhead ()V:259(-2)
+Lavrora/sim/clock/MainClock;.advance (J)V:100(0)
+Lavrora/sim/clock/MainClock;.skipAhead ()V:118(-2)
+Lavrora/sim/clock/RippleSynchronizer;.access$000 (Lavrora/sim/clock/RippleSynchronizer;JLavrora/sim/clock/RippleSynchronizer$WaitLink;)Lavrora/sim/clock/RippleSynchronizer$WaitLink;:22(0)
+Lavrora/sim/clock/RippleSynchronizer;.advance (JLavrora/sim/clock/RippleSynchronizer$WaitLink;)Lavrora/sim/clock/RippleSynchronizer$WaitLink;:124(-2)
+Lavrora/sim/clock/RippleSynchronizer$NotifyEvent;.fire ()V:84(-2)
+Lavrora/sim/clock/RippleSynchronizer;.removeNode (Lavrora/sim/Simulation$Node;)V:289(0)
+Lavrora/sim/clock/RippleSynchronizer;.waitFor (JLavrora/sim/clock/RippleSynchronizer$WaitLink;)V:155(0)
+Lavrora/sim/clock/RippleSynchronizer;.waitForLink (Lavrora/sim/clock/RippleSynchronizer$WaitLink;)V:179(-2)
+Lavrora/sim/clock/RippleSynchronizer;.waitForNeighbors (J)V:307(0)
+Lavrora/sim/radio/Medium$Receiver;.access$000 (Lavrora/sim/radio/Medium$Receiver;J)V:260(0)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.deliverByte (J)V:378(0)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.fireLocked (J)V:367(0)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.fireUnlocked (J)V:329(0)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.fire ()V:311(-2)
+Lavrora/sim/radio/Medium$Receiver;.waitForNeighbors (J)V:537(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/eclipse6.txt workspace/velodrome-sound/velodrome/atomicity-specifications/eclipse6.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/eclipse6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/eclipse6.txt	2014-04-03 17:43:57.382717732 -0400
@@ -0,0 +1,266 @@
+Ldacapo/eclipse/Main;.main ([Ljava/lang/String;)V:16(0)
+Lorg/eclipse/osgi/framework/eventmgr/EventManager$EventThread;.run ()V:287(0)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager;.run ()V:333(0)
+Lorg/eclipse/debug/internal/core/OutputStreamMonitor$1;.run ()V:0(0) 
+Lorg/eclipse/debug/internal/core/InputStreamMonitor$1;.run ()V:0(0)
+Lorg/eclipse/core/internal/jobs/Worker;.run ()V:0(0)
+Lorg/eclipse/osgi/framework/internal/core/PackageAdminImpl$1;.run ()V:0(0)
+Lorg/eclipse/debug/core/model/RuntimeProcess$ProcessMonitorThread;.run ()V:0(0)
+Lorg/eclipse/core/internal/runtime/PlatformActivator$1;.run ()V:0(0)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager;.run ()V:0(0)
+Lorg/eclipse/osgi/framework/internal/core/SystemBundle$1;.run ()V:0(0)
+Lorg/eclipse/core/internal/jobs/WorkerPool;.sleep (J)V:0(0)
+
+# Merged results
+
+
+Lorg/apache/xerces/impl/XMLDocumentFragmentScannerImpl$FragmentContentDispatcher;.dispatch (Z)Z:0(0)
+Lorg/apache/xerces/impl/XMLDocumentFragmentScannerImpl;.scanDocument (Z)Z:0(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl$JAXPSAXParser;.parse (Lorg/xml/sax/InputSource;)V:0(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl;.parse (Lorg/xml/sax/InputSource;Lorg/xml/sax/helpers/DefaultHandler;)V:0(0)
+Lorg/apache/xerces/parsers/AbstractSAXParser;.parse (Lorg/xml/sax/InputSource;)V:0(0)
+Lorg/apache/xerces/parsers/XML11Configuration;.parse (Lorg/apache/xerces/xni/parser/XMLInputSource;)V:0(0)
+Lorg/apache/xerces/parsers/XML11Configuration;.parse (Z)Z:0(0)
+Lorg/apache/xerces/parsers/XMLParser;.parse (Lorg/apache/xerces/xni/parser/XMLInputSource;)V:0(0)
+Lorg/eclipse/core/internal/compatibility/PluginActivator;.stop (Lorg/osgi/framework/BundleContext;)V:41(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog$7;.visit (Lorg/eclipse/core/internal/content/ContentType;)I:525(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.getDescriptionFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Ljava/io/InputStream;Ljava/lang/String;[Lorg/eclipse/core/runtime/QualifiedName;)Lorg/eclipse/core/runtime/content/IContentDescription;:316(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.getDescriptionFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Lorg/eclipse/core/internal/content/ILazySource;Ljava/lang/String;[Lorg/eclipse/core/runtime/QualifiedName;)Lorg/eclipse/core/runtime/content/IContentDescription;:302(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.internalAccept (Lorg/eclipse/core/internal/content/ContentTypeVisitor;Lorg/eclipse/core/internal/content/ContentType;)Z:332(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.internalFindContentTypesFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Ljava/lang/String;Ljava/util/Comparator;)[[Lorg/eclipse/core/runtime/content/IContentType;:403(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.internalFindContentTypesFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Lorg/eclipse/core/internal/content/ILazySource;Ljava/lang/String;Z)[Lorg/eclipse/core/runtime/content/IContentType;:376(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.selectMatchingByName (Lorg/eclipse/core/runtime/preferences/IScopeContext;Ljava/util/Collection;Ljava/util/Collection;Ljava/lang/String;I)Ljava/util/Set;:515(0)
+Lorg/eclipse/core/internal/content/ContentType;.hasFileSpec (Lorg/eclipse/core/runtime/preferences/IScopeContext;Ljava/lang/String;I)Z:370(0)
+Lorg/eclipse/core/internal/content/ContentTypeManager;.registryChanged (Lorg/eclipse/core/runtime/IRegistryChangeEvent;)V:151(0)
+Lorg/eclipse/core/internal/content/ContentTypeMatcher;.getDescriptionFor (Ljava/io/InputStream;Ljava/lang/String;[Lorg/eclipse/core/runtime/QualifiedName;)Lorg/eclipse/core/runtime/content/IContentDescription;:87(0)
+Lorg/eclipse/core/internal/content/ContentTypeMatcher;.getSpecificDescription (Lorg/eclipse/core/internal/content/BasicDescription;)Lorg/eclipse/core/runtime/content/IContentDescription;:136(0)
+Lorg/eclipse/core/internal/dtree/AbstractDataTreeNode;.childAtOrNull (Ljava/lang/String;)Lorg/eclipse/core/internal/dtree/AbstractDataTreeNode;:212(-2)
+Lorg/eclipse/core/internal/dtree/AbstractDataTreeNode;.indexOfChild (Ljava/lang/String;)I:421(-2)
+Lorg/eclipse/core/internal/dtree/AbstractDataTreeNode;.storeStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:536(0)
+Lorg/eclipse/core/internal/dtree/DataTreeNode;.storeStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:343(0)
+Lorg/eclipse/core/internal/dtree/DeltaDataTree;.lookup (Lorg/eclipse/core/runtime/IPath;)Lorg/eclipse/core/internal/dtree/DataTreeLookup;:661(-2)
+Lorg/eclipse/core/internal/dtree/DeltaDataTree;.setData (Lorg/eclipse/core/runtime/IPath;Ljava/lang/Object;)V:915(-2)
+Lorg/eclipse/core/internal/dtree/DeltaDataTree;.storeStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:953(0)
+Lorg/eclipse/core/internal/events/AutoBuildJob;.doBuild (Lorg/eclipse/core/runtime/IProgressMonitor;)V:129(0)
+Lorg/eclipse/core/internal/events/AutoBuildJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:192(0)
+Lorg/eclipse/core/internal/events/BuildManager;.createBuildersPersistentInfo (Lorg/eclipse/core/resources/IProject;)Ljava/util/ArrayList;:363(0)
+Lorg/eclipse/core/internal/events/BuildManager;.getBuildersPersistentInfo (Lorg/eclipse/core/resources/IProject;)Ljava/util/ArrayList;:489(0)
+Lorg/eclipse/core/internal/events/NotificationManager$2;.run ()V:276(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.broadcastChanges (Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/internal/events/ResourceChangeEvent;Z)V:132(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.getDelta (Lorg/eclipse/core/internal/watson/ElementTree;I)Lorg/eclipse/core/internal/events/ResourceDelta;:209(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.notify ([Lorg/eclipse/core/internal/events/ResourceChangeListenerList$ListenerEntry;Lorg/eclipse/core/resources/IResourceChangeEvent;Z)V:260(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.requestNotify ()V:196(0)
+Lorg/eclipse/core/internal/events/ResourceDeltaFactory;.computeDelta (Lorg/eclipse/core/internal/resources/Workspace;Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/runtime/IPath;J)Lorg/eclipse/core/internal/events/ResourceDelta;:41(0)
+Lorg/eclipse/core/internal/jobs/ImplicitJobs;.begin (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;Z)V:51(0)
+Lorg/eclipse/core/internal/jobs/ImplicitJobs;.end (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Z)V:110(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.beginRule (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:189(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.endJob (Lorg/eclipse/core/internal/jobs/InternalJob;Lorg/eclipse/core/runtime/IStatus;Z)V:443(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.endRule (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;)V:487(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.nextJob ()Lorg/eclipse/core/runtime/jobs/Job;:724(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.schedule (Lorg/eclipse/core/internal/jobs/InternalJob;JZ)V:840(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.startJob ()Lorg/eclipse/core/runtime/jobs/Job;:1019(0)
+Lorg/eclipse/core/internal/jobs/OrderedLock;.acquire (J)Z:92(0)
+Lorg/eclipse/core/internal/jobs/OrderedLock;.acquire ()V:80(0)
+Lorg/eclipse/core/internal/jobs/OrderedLock;.doAcquire (Lorg/eclipse/core/internal/jobs/Semaphore;J)Z:148(0)
+Lorg/eclipse/core/internal/jobs/Semaphore;.acquire (J)Z:27(0)
+Lorg/eclipse/core/internal/jobs/ThreadJob;.joinRun (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/internal/jobs/ThreadJob;:148(0)
+Lorg/eclipse/core/internal/jobs/WorkerPool;.endJob (Lorg/eclipse/core/internal/jobs/InternalJob;Lorg/eclipse/core/runtime/IStatus;)V:93(0)
+Lorg/eclipse/core/internal/jobs/WorkerPool;.startJob (Lorg/eclipse/core/internal/jobs/Worker;)Lorg/eclipse/core/internal/jobs/InternalJob;:188(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.getDescriptionLocationFor (Lorg/eclipse/core/resources/IProject;)Lorg/eclipse/core/runtime/IPath;:204(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.hasSavedProject (Lorg/eclipse/core/resources/IProject;)Z:251(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.internalWrite (Lorg/eclipse/core/resources/IProject;Lorg/eclipse/core/resources/IProjectDescription;IZZ)Z:263(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.isDescriptionSynchronized (Lorg/eclipse/core/resources/IProject;)Z:354(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.locationFor (Lorg/eclipse/core/resources/IResource;)Lorg/eclipse/core/runtime/IPath;:423(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.read (Lorg/eclipse/core/resources/IFile;ZLorg/eclipse/core/runtime/IProgressMonitor;)Ljava/io/InputStream;:507(0)
+Lorg/eclipse/core/internal/preferences/AbstractScope;.equals (Ljava/lang/Object;)Z:51(0)
+Lorg/eclipse/core/internal/registry/EclipseBundleListener;.addBundle (Lorg/osgi/framework/Bundle;)V:99(0)
+Lorg/eclipse/core/internal/registry/EclipseBundleListener;.bundleChanged (Lorg/osgi/framework/BundleEvent;)V:68(0)
+Lorg/eclipse/core/internal/registry/EclipseBundleListener;.getBundleModel (Lorg/osgi/framework/Bundle;)Lorg/eclipse/core/internal/registry/Contribution;:153(0)
+Lorg/eclipse/core/internal/registry/ExtensionRegistry;.addExtension (I)Ljava/lang/String;:154(0)
+Lorg/eclipse/core/internal/registry/ExtensionRegistry;.addExtensionsAndExtensionPoints (Lorg/eclipse/core/internal/registry/Contribution;)Ljava/util/Set;:187(0)
+Lorg/eclipse/core/internal/registry/ExtensionRegistry;.add (Lorg/eclipse/core/internal/registry/Contribution;)V:125(0)
+Lorg/eclipse/core/internal/registry/ExtensionRegistry;.basicAdd (Lorg/eclipse/core/internal/registry/Contribution;Z)V:216(0)
+Lorg/eclipse/core/internal/registry/ExtensionRegistry$ExtensionEventDispatcherJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:58(0)
+Lorg/eclipse/core/internal/registry/ExtensionRegistry;.recordChange (Lorg/eclipse/core/internal/registry/ExtensionPoint;II)Ljava/lang/String;:492(0)
+Lorg/eclipse/core/internal/registry/ExtensionsParser;.parseManifest (Lorg/osgi/util/tracker/ServiceTracker;Lorg/xml/sax/InputSource;Ljava/lang/String;Ljava/lang/String;Lorg/eclipse/core/internal/registry/RegistryObjectManager;Lorg/eclipse/core/internal/registry/Contribution;Ljava/util/ResourceBundle;)Lorg/eclipse/core/internal/registry/Contribution;:346(0)
+Lorg/eclipse/core/internal/registry/RegistryChangeEvent;.getExtensionDeltas (Ljava/lang/String;Ljava/lang/String;)[Lorg/eclipse/core/runtime/IExtensionDelta;:71(0)
+Lorg/eclipse/core/internal/registry/RegistryDelta;.getExtensionDeltas (Ljava/lang/String;)[Lorg/eclipse/core/runtime/IExtensionDelta;:37(0)
+Lorg/eclipse/core/internal/resources/CharsetManager;.getCharsetFor (Lorg/eclipse/core/runtime/IPath;Z)Ljava/lang/String;:200(0)
+Lorg/eclipse/core/internal/resources/CharsetManager;.getPreferences (Lorg/eclipse/core/resources/IProject;Z)Lorg/osgi/service/prefs/Preferences;:215(0)
+Lorg/eclipse/core/internal/resources/CharsetManager$Listener;.processEntryChanges (Lorg/eclipse/core/resources/IResourceDelta;Ljava/util/Set;)V:119(0)
+Lorg/eclipse/core/internal/resources/CharsetManager$Listener;.resourceChanged (Lorg/eclipse/core/resources/IResourceChangeEvent;)V:163(0)
+Lorg/eclipse/core/internal/resources/Container;.findMember (Lorg/eclipse/core/runtime/IPath;)Lorg/eclipse/core/resources/IResource;:69(0)
+Lorg/eclipse/core/internal/resources/Container;.findMember (Lorg/eclipse/core/runtime/IPath;Z)Lorg/eclipse/core/resources/IResource;:76(0)
+Lorg/eclipse/core/internal/resources/Container;.getChildren (I)[Lorg/eclipse/core/resources/IResource;:91(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager$1;.visitElement (Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/internal/watson/IPathRequestor;Ljava/lang/Object;)Z:239(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.clearContentFlags (Lorg/eclipse/core/runtime/IPath;Lorg/eclipse/core/runtime/IProgressMonitor;)V:233(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.doFlushCache (Lorg/eclipse/core/runtime/IProgressMonitor;[Lorg/eclipse/core/runtime/IPath;)V:204(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager$FlushJob;.runInWorkspace (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:63(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.getContentTypeMatcher (Lorg/eclipse/core/internal/resources/Project;)Lorg/eclipse/core/runtime/content/IContentTypeMatcher;:289(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.getDescriptionFor (Lorg/eclipse/core/internal/resources/File;Lorg/eclipse/core/internal/resources/ResourceInfo;)Lorg/eclipse/core/runtime/content/IContentDescription;:293(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.readDescription (Lorg/eclipse/core/internal/resources/File;)Lorg/eclipse/core/runtime/content/IContentDescription;:388(0)
+Lorg/eclipse/core/internal/resources/DelayedSnapshotJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:39(0)
+Lorg/eclipse/core/internal/resources/File;.getCharset ()Ljava/lang/String;:205(0)
+Lorg/eclipse/core/internal/resources/File;.getCharset (Z)Ljava/lang/String;:213(0)
+Lorg/eclipse/core/internal/resources/File;.getContents (Z)Ljava/io/InputStream;:290(0)
+Lorg/eclipse/core/internal/resources/File;.internalGetCharset (ZLorg/eclipse/core/internal/resources/ResourceInfo;)Ljava/lang/String;:253(0)
+Lorg/eclipse/core/internal/resources/InternalWorkspaceJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:31(0)
+Lorg/eclipse/core/internal/resources/LocalMetaArea;.writePrivateDescription (Lorg/eclipse/core/resources/IProject;)V:327(0)
+Lorg/eclipse/core/internal/resources/Marker;.delete ()V:66(0)
+Lorg/eclipse/core/internal/resources/Marker;.getAttribute (Ljava/lang/String;)Ljava/lang/Object;:97(0)
+Lorg/eclipse/core/internal/resources/Marker;.getInfo ()Lorg/eclipse/core/internal/resources/MarkerInfo;:181(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.add (Lorg/eclipse/core/resources/IResource;Lorg/eclipse/core/internal/resources/MarkerInfo;)V:52(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.basicAdd (Lorg/eclipse/core/resources/IResource;Lorg/eclipse/core/internal/resources/MarkerSet;Lorg/eclipse/core/internal/resources/MarkerInfo;)V:79(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.changedMarkers (Lorg/eclipse/core/resources/IResource;[Lorg/eclipse/core/internal/resources/IMarkerSetElement;)V:179(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.findMarkerInfo (Lorg/eclipse/core/resources/IResource;J)Lorg/eclipse/core/internal/resources/MarkerInfo;:208(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.findMarkers (Lorg/eclipse/core/resources/IResource;Ljava/lang/String;ZI)[Lorg/eclipse/core/resources/IMarker;:224(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.recursiveFindMarkers (Lorg/eclipse/core/runtime/IPath;Ljava/util/ArrayList;Ljava/lang/String;ZI)V:317(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.removeMarker (Lorg/eclipse/core/resources/IResource;J)V:375(0)
+Lorg/eclipse/core/internal/resources/Marker;.setAttributes ([Ljava/lang/String;[Ljava/lang/Object;)V:266(0)
+Lorg/eclipse/core/internal/resources/Project;.basicSetDescription (Lorg/eclipse/core/internal/resources/ProjectDescription;I)Lorg/eclipse/core/runtime/MultiStatus;:35(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes;.getMatcherFor (Lorg/eclipse/core/internal/resources/Project;)Lorg/eclipse/core/runtime/content/IContentTypeMatcher;:196(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.equals (Ljava/lang/Object;)Z:55(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.getDelegate ()Lorg/eclipse/core/runtime/preferences/IScopeContext;:67(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.getLocation ()Lorg/eclipse/core/runtime/IPath;:73(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.getName ()Ljava/lang/String;:77(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes;.usesContentTypePreferences (Ljava/lang/String;)Z:108(0)
+Lorg/eclipse/core/internal/resources/Project;.getDescription ()Lorg/eclipse/core/resources/IProjectDescription;:346(0)
+Lorg/eclipse/core/internal/resources/Project;.getWorkingLocation (Ljava/lang/String;)Lorg/eclipse/core/runtime/IPath;:403(0)
+Lorg/eclipse/core/internal/resources/Project;.hasNature (Ljava/lang/String;)Z:479(0)
+Lorg/eclipse/core/internal/resources/Project;.internalGetDescription ()Lorg/eclipse/core/internal/resources/ProjectDescription;:617(0)
+Lorg/eclipse/core/internal/resources/Project;.isAccessible ()Z:656(0)
+Lorg/eclipse/core/internal/resources/Project;.isOpen ()Z:697(0)
+Lorg/eclipse/core/internal/resources/ProjectPreferences;.nodeExists (Ljava/lang/String;)Z:129(0)
+Lorg/eclipse/core/internal/resources/Project;.setDescription (Lorg/eclipse/core/resources/IProjectDescription;ILorg/eclipse/core/runtime/IProgressMonitor;)V:908(0)
+Lorg/eclipse/core/internal/resources/Project;.setDescription (Lorg/eclipse/core/resources/IProjectDescription;Lorg/eclipse/core/runtime/IProgressMonitor;)V:968(0)
+Lorg/eclipse/core/internal/resources/Project;.writeDescription (Lorg/eclipse/core/resources/IProjectDescription;IZZ)V:1048(0)
+Lorg/eclipse/core/internal/resources/Resource$1;.visitElement (Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/internal/watson/IPathRequestor;Ljava/lang/Object;)Z:44(0)
+Lorg/eclipse/core/internal/resources/Resource;.accept (Lorg/eclipse/core/resources/IResourceProxyVisitor;I)V:41(0)
+Lorg/eclipse/core/internal/resources/Resource;.createMarker (Ljava/lang/String;)Lorg/eclipse/core/resources/IMarker;:617(0)
+Lorg/eclipse/core/internal/resources/Resource;.exists ()Z:783(0)
+Lorg/eclipse/core/internal/resources/Resource;.findMarkers (Ljava/lang/String;ZI)[Lorg/eclipse/core/resources/IMarker;:802(0)
+Lorg/eclipse/core/internal/resources/Resource;.getLocation ()Lorg/eclipse/core/runtime/IPath;:874(0)
+Lorg/eclipse/core/internal/resources/Resource;.getResourceInfo (ZZ)Lorg/eclipse/core/internal/resources/ResourceInfo;:973(0)
+Lorg/eclipse/core/internal/resources/Resource;.getSessionProperty (Lorg/eclipse/core/runtime/QualifiedName;)Ljava/lang/Object;:980(0)
+Lorg/eclipse/core/internal/resources/Resource;.isLinked ()Z:1470(0)
+Lorg/eclipse/core/internal/resources/SaveManager$1;.run ()V:153(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.broadcastLifecycle (ILjava/util/Map;Lorg/eclipse/core/runtime/MultiStatus;Lorg/eclipse/core/runtime/IProgressMonitor;)V:127(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.collapseTrees ()V:221(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.executeLifecycle (ILorg/eclipse/core/resources/ISaveParticipant;Lorg/eclipse/core/internal/resources/SaveContext;)V:316(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.save (ILorg/eclipse/core/internal/resources/Project;Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:941(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.saveMetaInfo (Lorg/eclipse/core/internal/resources/Project;Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:1094(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.saveMetaInfo (Lorg/eclipse/core/runtime/MultiStatus;Lorg/eclipse/core/runtime/IProgressMonitor;)V:1069(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.shareStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:1154(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.shutdown (Lorg/eclipse/core/runtime/IProgressMonitor;)V:1161(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.visitAndSnap (Lorg/eclipse/core/resources/IResource;)V:1438(0)
+Lorg/eclipse/core/internal/resources/WorkManager;.beginUnprotected ()I:79(0)
+Lorg/eclipse/core/internal/resources/WorkManager;.checkIn (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:90(0)
+Lorg/eclipse/core/internal/resources/WorkManager;.checkOut (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;)V:111(0)
+Lorg/eclipse/core/internal/resources/WorkManager;.endUnprotected (I)V:159(0)
+Lorg/eclipse/core/internal/resources/Workspace;.beginOperation (Z)V:163(0)
+Lorg/eclipse/core/internal/resources/Workspace;.broadcastBuildEvent (Ljava/lang/Object;II)V:184(0)
+Lorg/eclipse/core/internal/resources/Workspace;.broadcastPostChange ()V:179(0)
+Lorg/eclipse/core/internal/resources/Workspace;.close (Lorg/eclipse/core/runtime/IProgressMonitor;)V:314(0)
+Lorg/eclipse/core/internal/resources/Workspace;.endOperation (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;ZLorg/eclipse/core/runtime/IProgressMonitor;)V:883(0)
+Lorg/eclipse/core/internal/resources/Workspace;.getResourceInfo (Lorg/eclipse/core/runtime/IPath;ZZ)Lorg/eclipse/core/internal/resources/ResourceInfo;:1129(-2)
+Lorg/eclipse/core/internal/resources/Workspace;.newWorkingTree ()Lorg/eclipse/core/internal/watson/ElementTree;:1580(0)
+Lorg/eclipse/core/internal/resources/Workspace;.prepareOperation (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:1674(0)
+Lorg/eclipse/core/internal/resources/WorkspaceRoot;.getProjects ()[Lorg/eclipse/core/resources/IProject;:152(0)
+Lorg/eclipse/core/internal/resources/Workspace;.run (Lorg/eclipse/core/resources/IWorkspaceRunnable;Lorg/eclipse/core/runtime/jobs/ISchedulingRule;ILorg/eclipse/core/runtime/IProgressMonitor;)V:1710(0)
+Lorg/eclipse/core/internal/resources/Workspace;.shutdown (Lorg/eclipse/core/runtime/IProgressMonitor;)V:1807(0)
+Lorg/eclipse/core/internal/runtime/InternalPlatform;.run (Lorg/eclipse/core/runtime/ISafeRunnable;)V:1042(0)
+Lorg/eclipse/core/internal/utils/StringPoolJob$1;.run ()V:130(0)
+Lorg/eclipse/core/internal/utils/StringPoolJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:83(0)
+Lorg/eclipse/core/internal/utils/StringPoolJob;.shareStrings ([Lorg/eclipse/core/internal/utils/IStringPoolParticipant;Lorg/eclipse/core/runtime/IProgressMonitor;)I:119(0)
+Lorg/eclipse/core/internal/watson/ElementTree;.getElementData (Lorg/eclipse/core/runtime/IPath;)Ljava/lang/Object;:363(-2)
+Lorg/eclipse/core/internal/watson/ElementTree;.includes (Lorg/eclipse/core/runtime/IPath;)Z:526(-2)
+Lorg/eclipse/core/internal/watson/ElementTreeIterator;.doIteration (Lorg/eclipse/core/internal/dtree/DataTreeNode;Lorg/eclipse/core/internal/watson/IElementContentVisitor;)V:75(0)
+Lorg/eclipse/core/internal/watson/ElementTreeIterator;.iterate (Lorg/eclipse/core/internal/watson/IElementContentVisitor;)V:112(0)
+Lorg/eclipse/core/internal/watson/ElementTree;.openElementData (Lorg/eclipse/core/runtime/IPath;)Ljava/lang/Object;:640(0)
+Lorg/eclipse/core/internal/watson/ElementTree;.shareStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:706(0)
+Lorg/eclipse/core/resources/ProjectScope;.getNode (Ljava/lang/String;)Lorg/eclipse/core/runtime/preferences/IEclipsePreferences;:65(0)
+Lorg/eclipse/core/resources/ResourcesPlugin;.shutdown ()V:330(0)
+Lorg/eclipse/core/runtime/adaptor/EclipseAdaptor;.frameworkStopping (Lorg/osgi/framework/BundleContext;)V:764(0)
+Lorg/eclipse/core/runtime/internal/adaptor/BundleStopper;.basicStopBundles ()V:77(0)
+Lorg/eclipse/core/runtime/internal/adaptor/BundleStopper;.stopBundles ()V:67(0)
+Lorg/eclipse/core/runtime/Platform;.run (Lorg/eclipse/core/runtime/ISafeRunnable;)V:783(0)
+Lorg/eclipse/debug/internal/core/InputStreamMonitor;.write ()V:104(0)
+Lorg/eclipse/jdt/core/JavaCore;.getResolvedClasspathEntry (Lorg/eclipse/jdt/core/IClasspathEntry;)Lorg/eclipse/jdt/core/IClasspathEntry;:2437(0)
+Lorg/eclipse/jdt/core/JavaCore;.run (Lorg/eclipse/core/resources/IWorkspaceRunnable;Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:3756(0)
+Lorg/eclipse/jdt/core/JavaCore;.stop (Lorg/osgi/framework/BundleContext;)V:4099(0)
+Lorg/eclipse/jdt/internal/core/ClasspathEntry;.validateClasspathEntry (Lorg/eclipse/jdt/core/IJavaProject;Lorg/eclipse/jdt/core/IClasspathEntry;ZZ)Lorg/eclipse/jdt/core/IJavaModelStatus;:1506(0)
+Lorg/eclipse/jdt/internal/core/ClasspathEntry;.validateClasspath (Lorg/eclipse/jdt/core/IJavaProject;[Lorg/eclipse/jdt/core/IClasspathEntry;Lorg/eclipse/core/runtime/IPath;)Lorg/eclipse/jdt/core/IJavaModelStatus;:1241(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessingState$ProjectUpdateInfo;.updateProjectReferencesIfNecessary ()V:94(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessingState;.resourceChanged (Lorg/eclipse/core/resources/IResourceChangeEvent;)V:416(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.checkProjectsBeingAddedOrRemoved (Lorg/eclipse/core/resources/IResourceDelta;)V:357(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.createElement (Lorg/eclipse/core/resources/IResource;ILorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;)Lorg/eclipse/jdt/internal/core/Openable;:566(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.createExternalArchiveDelta (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:688(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.outputsInfo (Lorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;Lorg/eclipse/core/resources/IResource;)Lorg/eclipse/jdt/internal/core/DeltaProcessor$OutputsInfo;:1524(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.processResourceDelta (Lorg/eclipse/core/resources/IResourceDelta;)Lorg/eclipse/jdt/core/IJavaElementDelta;:1598(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.resourceChanged (Lorg/eclipse/core/resources/IResourceChangeEvent;)V:1766(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.traverseDelta (Lorg/eclipse/core/resources/IResourceDelta;ILorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;Lorg/eclipse/jdt/internal/core/DeltaProcessor$OutputsInfo;)V:1868(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.updateClasspathMarkers (Lorg/eclipse/core/resources/IResourceDelta;Ljava/util/HashSet;Ljava/util/Map;Ljava/util/Map;)V:2025(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.updateClasspathMarkers (Lorg/eclipse/core/resources/IResourceDelta;)V:2113(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.updateCurrentDeltaAndIndex (Lorg/eclipse/core/resources/IResourceDelta;ILorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;)Z:2174(0)
+Lorg/eclipse/jdt/internal/core/JavaModel;.getTarget (Lorg/eclipse/core/resources/IContainer;Lorg/eclipse/core/runtime/IPath;Z)Ljava/lang/Object;:343(0)
+Lorg/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo;.rememberExternalLibTimestamps ()V:711(0)
+Lorg/eclipse/jdt/internal/core/JavaModelManager;.saving (Lorg/eclipse/core/resources/ISaveContext;)V:2325(0)
+Lorg/eclipse/jdt/internal/core/JavaModelManager;.shutdown ()V:2566(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.createClasspathProblemMarker (Lorg/eclipse/jdt/core/IJavaModelStatus;)V:716(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.flushClasspathProblemMarkers (ZZ)V:1165(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getEclipsePreferences ()Lorg/eclipse/core/runtime/preferences/IEclipsePreferences;:1369(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getOption (Ljava/lang/String;Z)Ljava/lang/String;:1536(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getOptions (Z)Ljava/util/Map;:1553(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getPluginWorkingLocation ()Lorg/eclipse/core/runtime/IPath;:1796(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getResolvedClasspath ([Lorg/eclipse/jdt/core/IClasspathEntry;Lorg/eclipse/core/runtime/IPath;ZZLjava/util/Map;)[Lorg/eclipse/jdt/core/IClasspathEntry;:2001(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getSharedProperty (Ljava/lang/String;)Ljava/lang/String;:2111(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.hasJavaNature (Lorg/eclipse/core/resources/IProject;)Z:224(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.loadPreferences ()Lorg/eclipse/core/runtime/Preferences;:2387(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.readClasspathFile (ZZLjava/util/Map;)[Lorg/eclipse/jdt/core/IClasspathEntry;:2553(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.readClasspathFile (ZZ)[Lorg/eclipse/jdt/core/IClasspathEntry;:2547(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updateAllCycleMarkers (Ljava/util/Map;)V:240(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updateClasspathMarkers (Ljava/util/Map;Ljava/util/Map;)V:2915(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updateCycleParticipants (Ljava/util/ArrayList;Ljava/util/HashSet;Lorg/eclipse/core/resources/IWorkspaceRoot;Ljava/util/HashSet;Ljava/util/Map;)V:2965(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updatePreferences (Lorg/eclipse/core/runtime/preferences/IEclipsePreferences;)V:3024(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/AddJarFileToIndex;.execute (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:60(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexAllProject$1;.visit (Lorg/eclipse/core/resources/IResourceProxy;)Z:135(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexAllProject;.execute (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:53(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexManager$1;.execute (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:591(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexManager;.indexDocument (Lorg/eclipse/jdt/core/search/SearchDocument;Lorg/eclipse/jdt/core/search/SearchParticipant;Lorg/eclipse/jdt/internal/core/index/Index;Lorg/eclipse/core/runtime/IPath;)V:289(-2)
+Lorg/eclipse/jdt/internal/core/search/indexing/SourceIndexer;.indexDocument ()V:51(0)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchDocument;.getCharContents ()[C:51(0)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchDocument;.getEncoding ()Ljava/lang/String;:63(0)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchDocument;.getLocation ()Lorg/eclipse/core/runtime/IPath;:84(0)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchParticipant;.indexDocument (Lorg/eclipse/jdt/core/search/SearchDocument;Lorg/eclipse/core/runtime/IPath;)V:68(0)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager$1$ProgressJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:320(0)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager;.shutdown ()V:414(0)
+Lorg/eclipse/jdt/internal/core/util/Util;.getResourceContentsAsByteArray (Lorg/eclipse/core/resources/IFile;)[B:995(0)
+Lorg/eclipse/jdt/internal/launching/LaunchingPlugin$JREUpdateJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:296(0)
+Lorg/eclipse/jdt/internal/launching/LaunchingPlugin$VMChanges;.doit (Lorg/eclipse/core/runtime/IProgressMonitor;)V:208(0)
+Lorg/eclipse/osgi/framework/eventmgr/EventManager;.dispatchEvent ([Lorg/eclipse/osgi/framework/eventmgr/EventListeners$ListElement;Lorg/eclipse/osgi/framework/eventmgr/EventDispatcher;ILjava/lang/Object;)V:181(0)
+Lorg/eclipse/osgi/framework/eventmgr/EventManager$EventThread;.getNextEvent ()Lorg/eclipse/osgi/framework/eventmgr/EventManager$EventThread$Queued;:347(0)
+Lorg/eclipse/osgi/framework/eventmgr/ListenerQueue;.dispatchEventSynchronous (ILjava/lang/Object;)V:133(0)
+Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;.resume ()V:332(0)
+Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;.stop ()V:404(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl$2;.run ()Ljava/lang/Object;:990(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl$3;.run ()Ljava/lang/Object;:1033(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.dispatchEvent (Ljava/lang/Object;Ljava/lang/Object;ILjava/lang/Object;)V:1179(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.startActivator (Lorg/osgi/framework/BundleActivator;)V:985(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.start ()V:965(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.stop ()V:1031(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleHost;.startWorker (Z)V:282(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleHost;.stopWorker (Z)V:385(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.publishBundleEvent (ILorg/osgi/framework/Bundle;)V:1416(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.publishBundleEventPrivileged (Lorg/osgi/framework/BundleEvent;)V:1437(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.resumeBundle (Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;)V:1012(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.shutdown ()V:518(0)
+Lorg/eclipse/osgi/framework/internal/core/PackageAdminImpl;.doResolveBundles ([Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;Z)V:160(0)
+Lorg/eclipse/osgi/framework/internal/core/PackageAdminImpl;.processDelta ([Lorg/eclipse/osgi/service/resolver/BundleDelta;Z)[Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;:306(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.dispatchEvent (Ljava/lang/Object;Ljava/lang/Object;ILjava/lang/Object;)V:451(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.doSetStartLevel (ILorg/eclipse/osgi/framework/internal/core/AbstractBundle;)V:266(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.incFWSL (ILorg/eclipse/osgi/framework/internal/core/AbstractBundle;)V:469(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.resumeBundles ([Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;Z)V:546(0)
+Lorg/eclipse/osgi/framework/internal/core/SystemBundle;.suspend ()V:190(0)
+Lorg/eclipse/update/internal/configurator/ConfigurationActivator;.installBundles ()Z:139(0)
+Lorg/eclipse/update/internal/configurator/ConfigurationActivator;.refreshPackages ([Lorg/osgi/framework/Bundle;)V:341(0)
+Lorg/eclipse/update/internal/configurator/ConfigurationActivator;.start (Lorg/osgi/framework/BundleContext;)V:64(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/elevator.txt workspace/velodrome-sound/velodrome/atomicity-specifications/elevator.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/elevator.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/elevator.txt	2014-04-03 17:43:57.383717735 -0400
@@ -0,0 +1,14 @@
+Lelevator/Elevator;.main ([Ljava/lang/String;)V:117(0)
+# Does Velodrome include this in their count?
+Lelevator/Lift;.run ()V:60(0)
+Lelevator/Lift;.sleep (J)V:866(0)
+# This method contains a join()
+Lelevator/Elevator;.waitForLiftsToFinishOperation ()V:105(0)
+Lelevator/Lift;.join ()V:0(0)
+# This method contains a sleep, so shouldn't be reported
+Lelevator/Elevator;.begin ()V:73(0)
+
+# Merged results
+
+Lelevator/Lift;.doIdle ()V:78(0)
+Lelevator/Controls;.claimUp (Ljava/lang/String;I)Z:50(0)
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/hedc.txt workspace/velodrome-sound/velodrome/atomicity-specifications/hedc.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/hedc.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/hedc.txt	2014-04-03 17:43:57.381717729 -0400
@@ -0,0 +1,15 @@
+# HEDC
+
+Lhedc/Tester;.main ([Ljava/lang/String;)V:48(0)
+Lhedc/Tester;.run ()V:109(0)
+
+# Does Velodrome consider this to be a violation?
+Lhedc/PooledExecutorWithInvalidate$Worker;.run ()V:297(0)
+Lhedc/Task;.run ()V:38(0)
+
+# Merged results
+
+Lhedc/MetaSearchRequest;.go ()V:42(0)
+Lhedc/MetaSearchImpl;.search (Ljava/util/Hashtable;Lhedc/MetaSearchRequest;)Ljava/util/List;:69(0)
+Lhedc/PooledExecutorWithInvalidate;.execute (Lhedc/Task;)V:414(0)
+Lhedc/PooledExecutorWithInvalidate;.getTask ()Lhedc/Task;:279(0)
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/hsqldb6.txt workspace/velodrome-sound/velodrome/atomicity-specifications/hsqldb6.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/hsqldb6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/hsqldb6.txt	2014-04-03 17:43:57.381717729 -0400
@@ -0,0 +1,68 @@
+# Trivial
+Ldacapo/hsqldb/PseudoJDBCBench;.main ([Ljava/lang/String;)V:94(0)
+Ldacapo/hsqldb/HsqldbHarness;.iterate (Ljava/lang/String;)V:19(0)
+Ldacapo/hsqldb/HsqldbHarness;.postIteration (Ljava/lang/String;)V:23(0)
+Ldacapo/hsqldb/PseudoJDBCBench$ClientThread;.run ()V:901(0)
+Ldacapo/hsqldb/PseudoJDBCBench$MemoryWatcherThread;.join ()V:0(0)
+Ldacapo/hsqldb/PseudoJDBCBench$MemoryWatcherThread;.run ()V:0(0)
+Ldacapo/hsqldb/PseudoJDBCBench$MemoryWatcherThread;.start ()V:0(0)
+
+# Merged results
+
+Ldacapo/hsqldb/PseudoJDBCBench$ClientThread;.doOne (IIII)I:950(0)
+Ldacapo/hsqldb/PseudoJDBCBench;.connectClose (Ljava/sql/Connection;)V:832(0)
+Lorg/hsqldb/Column;.convertObject (Ljava/lang/Object;I)Ljava/lang/Object;:0(0)
+Lorg/hsqldb/CompiledStatementExecutor;.executeImpl (Lorg/hsqldb/CompiledStatement;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/CompiledStatementExecutor;.executeInsertValuesStatement (Lorg/hsqldb/CompiledStatement;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/CompiledStatementExecutor;.execute (Lorg/hsqldb/CompiledStatement;[Ljava/lang/Object;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/CompiledStatementExecutor;.executeSelectStatement (Lorg/hsqldb/CompiledStatement;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/CompiledStatementExecutor;.executeUpdateStatement (Lorg/hsqldb/CompiledStatement;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/DatabaseCommandInterpreter;.execute (Ljava/lang/String;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/DatabaseCommandInterpreter;.executePart (ILjava/lang/String;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Expression;.getValue (Lorg/hsqldb/Session;I)Ljava/lang/Object;:0(0)
+Lorg/hsqldb/Expression;.getValue (Lorg/hsqldb/Session;)Ljava/lang/Object;:0(0)
+Lorg/hsqldb/GroupedResult;.addRow ([Ljava/lang/Object;)V:0(0)
+Lorg/hsqldb/Index;.balance (Lorg/hsqldb/Session;Lorg/hsqldb/Node;Z)V:0(0)
+Lorg/hsqldb/Index;.insert (Lorg/hsqldb/Session;Lorg/hsqldb/Row;I)V:0(0)
+Lorg/hsqldb/Index;.replace (Lorg/hsqldb/Session;Lorg/hsqldb/Node;Lorg/hsqldb/Node;)V:0(0)
+Lorg/hsqldb/jdbc/jdbcConnection;.close ()V:0(0)
+Lorg/hsqldb/jdbc/jdbcPreparedStatement;.close ()V:0(0)
+Lorg/hsqldb/jdbc/jdbcPreparedStatement;.executeQuery ()Ljava/sql/ResultSet;:0(0)
+Lorg/hsqldb/jdbc/jdbcPreparedStatement;.executeUpdate ()I:0(0)
+Lorg/hsqldb/jdbc/jdbcStatement;.executeQuery (Ljava/lang/String;)Ljava/sql/ResultSet;:0(0)
+Lorg/hsqldb/jdbc/jdbcStatement;.executeUpdate (Ljava/lang/String;)I:0(0)
+Lorg/hsqldb/jdbc/jdbcStatement;.fetchResult (Ljava/lang/String;)V:0(0)
+Lorg/hsqldb/Parser;.compileUpdateStatement ()Lorg/hsqldb/CompiledStatement;:0(0)
+Lorg/hsqldb/Parser;.parseExpression ()Lorg/hsqldb/Expression;:0(0)
+Lorg/hsqldb/Parser;.readAnd ()Lorg/hsqldb/Expression;:0(0)
+Lorg/hsqldb/Parser;.readConcat ()Lorg/hsqldb/Expression;:0(0)
+Lorg/hsqldb/Parser;.readCondition ()Lorg/hsqldb/Expression;:0(0)
+Lorg/hsqldb/Parser;.readOr ()Lorg/hsqldb/Expression;:0(0)
+Lorg/hsqldb/Parser;.readSum ()Lorg/hsqldb/Expression;:0(0)
+Lorg/hsqldb/Parser;.read ()V:0(0)
+Lorg/hsqldb/Record;.<init> ()V:0(0)
+Lorg/hsqldb/Result;.setParameterData ([Ljava/lang/Object;)V:0(0)
+Lorg/hsqldb/Select;.buildResult (Lorg/hsqldb/Session;I)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Select;.getResult (Lorg/hsqldb/Session;I)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Select;.getSingleResult (Lorg/hsqldb/Session;I)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Session;.close ()V:0(0)
+Lorg/hsqldb/Session;.execute (Lorg/hsqldb/Result;)Lorg/hsqldb/Result;:0(-2)
+Lorg/hsqldb/Session;.sqlExecuteCompiledNoPreChecks (Lorg/hsqldb/CompiledStatement;[Ljava/lang/Object;)Lorg/hsqldb/Result;:0(0))
+Lorg/hsqldb/Session;.sqlExecuteDirectNoPreChecks (Ljava/lang/String;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Session;.sqlExecute (Lorg/hsqldb/CompiledStatement;[Ljava/lang/Object;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Session;.sqlExecute (Lorg/hsqldb/Result;)Lorg/hsqldb/Result;:0(-2)
+Lorg/hsqldb/store/HashIndex;.linkNode (II)I:0(0)
+Lorg/hsqldb/store/ValuePool;.getInt (I)Ljava/lang/Integer;:0(0)
+Lorg/hsqldb/store/ValuePool;.getLong (J)Ljava/lang/Long;:0(0)
+Lorg/hsqldb/store/ValuePoolHashMap;.getOrAddInteger (I)Ljava/lang/Integer;:0(0)
+Lorg/hsqldb/Table;.deleteNoCheck (Lorg/hsqldb/Session;Lorg/hsqldb/Row;Z)V:0(-2)
+Lorg/hsqldb/TableFilter;.findFirst (Lorg/hsqldb/Session;)Z:0(0)
+Lorg/hsqldb/Table;.indexRow (Lorg/hsqldb/Session;Lorg/hsqldb/Row;)V:0(0)
+Lorg/hsqldb/Table;.insert (Lorg/hsqldb/Session;[Ljava/lang/Object;)V:0(0)
+Lorg/hsqldb/Table;.insertNoCheck (Lorg/hsqldb/Session;[Ljava/lang/Object;)V:0(0)
+Lorg/hsqldb/Table;.insertRow (Lorg/hsqldb/Session;[Ljava/lang/Object;)V:0(0)
+Lorg/hsqldb/Table;.newRow ([Ljava/lang/Object;)Lorg/hsqldb/Row;:0(0)
+Lorg/hsqldb/Table;.update (Lorg/hsqldb/Session;Lorg/hsqldb/lib/HashMappedList;[I)I:0(0)
+Lorg/hsqldb/Table;.updateRowSet (Lorg/hsqldb/Session;Lorg/hsqldb/lib/HashMappedList;[IZ)V:0(0)
+Lorg/hsqldb/Tokenizer;.getAsValue ()Ljava/lang/Object;:0(0)
+Lorg/hsqldb/TransactionManager;.nextActionTimestamp ()J:0(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/jython9.txt workspace/velodrome-sound/velodrome/atomicity-specifications/jython9.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/jython9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/jython9.txt	2014-04-03 17:43:57.381717729 -0400
@@ -0,0 +1,5 @@
+Lorg/dacapo/harness/Jython;.iterate (Ljava/lang/String;)V:48(0)
+Lorg/python/util/jython;.main ([Ljava/lang/String;)V:0(0)
+
+# Merged results
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/luindex9.txt workspace/velodrome-sound/velodrome/atomicity-specifications/luindex9.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/luindex9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/luindex9.txt	2014-04-03 17:43:57.380717726 -0400
@@ -0,0 +1,12 @@
+# Trivial
+Lorg/dacapo/luindex/Index;.main (Ljava/io/File;[Ljava/lang/String;)V:66(0)
+
+# Not sure about these, just blindly searched for all Thread::run() methods in the lucene library
+Lorg/apache/lucene/index/ConcurrentMergeScheduler$MergeThread;.run ()V:248(0)
+Lorg/apache/lucene/search/MultiSearcherThread;.run ()V:248(0)
+Lorg/apache/lucene/search/TimeLimitedCollector$TimerThread;.run ()V:69(0)
+
+
+# Merged results
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/lusearch6.txt workspace/velodrome-sound/velodrome/atomicity-specifications/lusearch6.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/lusearch6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/lusearch6.txt	2014-04-03 17:43:57.380717726 -0400
@@ -0,0 +1,10 @@
+#Lusearch6
+
+Ldacapo/lusearch/LusearchHarness$QueryThread;.run ()V:159(0)
+#Lorg/dacapo/lusearch/Search$QueryThread;.run ()V:176(0)
+#Lorg/dacapo/lusearch/Search$QueryProcessor;.run ()V:217(0)
+
+# Merged results
+
+Ldacapo/lusearch/LusearchHarness$QueryThread;.runQuery ()V:166(0)
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/lusearch9.txt workspace/velodrome-sound/velodrome/atomicity-specifications/lusearch9.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/lusearch9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/lusearch9.txt	2014-04-03 17:43:57.380717726 -0400
@@ -0,0 +1,51 @@
+# Lusearch9-fixed
+
+# Need to check for specifications, lusearch harness for example
+Lorg/dacapo/lusearch/Search;.main ([Ljava/lang/String;)V:77(0) 
+Lorg/dacapo/lusearch/Search$QueryThread;.run ()V:176(0)
+Lorg/dacapo/lusearch/Search$QueryThread;.start ()V:0(0)
+Lorg/dacapo/lusearch/Search$QueryProcessor;.run ()V:0(0)
+
+# Merged results
+
+Lorg/apache/lucene/analysis/standard/StandardAnalyzer;.reusableTokenStream (Ljava/lang/String;Ljava/io/Reader;)Lorg/apache/lucene/analysis/TokenStream;:225(0)
+Lorg/apache/lucene/index/DirectoryIndexReader$1;.doBody (Ljava/lang/String;)Ljava/lang/Object;:94(0)
+Lorg/apache/lucene/index/DirectoryIndexReader;.open (Lorg/apache/lucene/store/Directory;ZLorg/apache/lucene/index/IndexDeletionPolicy;Lorg/apache/lucene/index/IndexCommit;Z)Lorg/apache/lucene/index/DirectoryIndexReader;:90(0)
+Lorg/apache/lucene/index/FieldsReader;.addField (Lorg/apache/lucene/document/Document;Lorg/apache/lucene/index/FieldInfo;ZZZ)V:329(0)
+Lorg/apache/lucene/index/FieldsReader;.doc (ILorg/apache/lucene/document/FieldSelector;)Lorg/apache/lucene/document/Document;:177(0)
+Lorg/apache/lucene/index/IndexReader;.document (I)Lorg/apache/lucene/document/Document;:636(0)
+Lorg/apache/lucene/index/IndexReader;.open (Ljava/lang/String;)Lorg/apache/lucene/index/IndexReader;:206(0)
+Lorg/apache/lucene/index/IndexReader;.open (Lorg/apache/lucene/store/Directory;ZLorg/apache/lucene/index/IndexDeletionPolicy;Lorg/apache/lucene/index/IndexCommit;Z)Lorg/apache/lucene/index/IndexReader;:316(0)
+Lorg/apache/lucene/index/SegmentInfos$FindSegmentsFile;.run ()Ljava/lang/Object;:495(0)
+Lorg/apache/lucene/index/SegmentReader;.docFreq (Lorg/apache/lucene/index/Term;)I:751(0)
+Lorg/apache/lucene/index/SegmentReader;.document (ILorg/apache/lucene/document/FieldSelector;)Lorg/apache/lucene/document/Document;:729(0)
+Lorg/apache/lucene/index/SegmentReader;.get (ZLorg/apache/lucene/index/SegmentInfos;Lorg/apache/lucene/index/SegmentInfo;Z)Lorg/apache/lucene/index/SegmentReader;:269(0)
+Lorg/apache/lucene/index/SegmentReader;.get (ZLorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Lorg/apache/lucene/index/SegmentInfos;ZZIZ)Lorg/apache/lucene/index/SegmentReader;:298(0)
+Lorg/apache/lucene/index/SegmentReader;.initialize (Lorg/apache/lucene/index/SegmentInfo;IZ)V:311(0)
+Lorg/apache/lucene/index/SegmentTermEnum;.<init> (Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/index/FieldInfos;Z)V:44(0)
+Lorg/apache/lucene/index/TermInfosReader;.get (Lorg/apache/lucene/index/Term;)Lorg/apache/lucene/index/TermInfo;:218(0)
+Lorg/apache/lucene/index/TermInfosReader;.get (Lorg/apache/lucene/index/Term;Z)Lorg/apache/lucene/index/TermInfo;:223(0)
+Lorg/apache/lucene/index/TermInfosReader;.getThreadResources ()Lorg/apache/lucene/index/TermInfosReader$ThreadResources;:156(0)
+Lorg/apache/lucene/index/TermInfosReader;.<init> (Lorg/apache/lucene/store/Directory;Ljava/lang/String;Lorg/apache/lucene/index/FieldInfos;I)V:68(0)
+Lorg/apache/lucene/queryParser/QueryParser;.Clause (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1191(0)
+Lorg/apache/lucene/queryParser/QueryParser;.getFieldQuery (Ljava/lang/String;Ljava/lang/String;)Lorg/apache/lucene/search/Query;:515(0)
+Lorg/apache/lucene/queryParser/QueryParser;.<init> (Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;)V:157(0)
+Lorg/apache/lucene/queryParser/QueryParser;.<init> (Lorg/apache/lucene/queryParser/CharStream;)V:1553(0)
+Lorg/apache/lucene/queryParser/QueryParser;.parse (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:167(0)
+Lorg/apache/lucene/queryParser/QueryParser;.Query (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1145(0)
+Lorg/apache/lucene/queryParser/QueryParser;.Term (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1254(0)
+Lorg/apache/lucene/queryParser/QueryParser;.TopLevelQuery (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1138(0)
+Lorg/apache/lucene/search/IndexSearcher;.docFreq (Lorg/apache/lucene/index/Term;)I:86(0)
+Lorg/apache/lucene/search/IndexSearcher;.doc (I)Lorg/apache/lucene/document/Document;:91(0)
+Lorg/apache/lucene/search/IndexSearcher;.search (Lorg/apache/lucene/search/Weight;Lorg/apache/lucene/search/Filter;I)Lorg/apache/lucene/search/TopDocs;:108(0)
+Lorg/apache/lucene/search/Query;.weight (Lorg/apache/lucene/search/Searcher;)Lorg/apache/lucene/search/Weight;:94(0)
+Lorg/apache/lucene/search/Searcher;.createWeight (Lorg/apache/lucene/search/Query;)Lorg/apache/lucene/search/Weight;:185(0)
+Lorg/apache/lucene/search/Searcher;.search (Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/Filter;I)Lorg/apache/lucene/search/TopDocs;:136(0)
+Lorg/apache/lucene/search/Similarity;.idf (Lorg/apache/lucene/index/Term;Lorg/apache/lucene/search/Searcher;)F:457(0)
+Lorg/apache/lucene/search/TermQuery;.createWeight (Lorg/apache/lucene/search/Searcher;)Lorg/apache/lucene/search/Weight;:146(0)
+Lorg/apache/lucene/search/TermQuery$TermWeight;.<init> (Lorg/apache/lucene/search/TermQuery;Lorg/apache/lucene/search/Searcher;)V:42(0)
+Lorg/apache/lucene/store/FSDirectory;.getDirectory (Ljava/io/File;Lorg/apache/lucene/store/LockFactory;)Lorg/apache/lucene/store/FSDirectory;:168(0)
+Lorg/apache/lucene/store/FSDirectory;.getDirectory (Ljava/lang/String;)Lorg/apache/lucene/store/FSDirectory;:139(0)
+Lorg/apache/lucene/store/FSDirectory;.list ()[Ljava/lang/String;:320(0)
+Lorg/dacapo/lusearch/Search$QueryProcessor;.doPagingSearch (Lorg/apache/lucene/search/Query;)V:272(0)
+Lorg/dacapo/lusearch/Search$QueryProcessor;.<init> (Lorg/dacapo/lusearch/Search;Lorg/dacapo/lusearch/Search;Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ZI)V:201(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/methodNames.txt workspace/velodrome-sound/velodrome/atomicity-specifications/methodNames.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/methodNames.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/methodNames.txt	2014-04-03 17:43:57.382717732 -0400
@@ -0,0 +1,119 @@
+#Merged from AVD and Velodrome
+
+
+
+# Java library methods
+
+Ljava/lang/Thread;.run ():742(0)
+Ljava/lang/Runnable;.run ():61(0)
+Ljava/lang/System;.exit (I)V:577(-2)
+Ljava/lang/Thread;.join ()V:0(0)
+
+# Common DaCapo benchmark methods (both 2006 & 2009)
+LMMTkCallback;.<init> ()V:0(0)
+LMMTkCallback;.start ()V:42(0)
+LMMTkCallback;.start (Ljava/lang/String;)V:14(0)
+LMMTkCallback;.stop ()V:53(0)
+LMMTkCallback;.isWarmup ()Z:0(0)
+
+Ldacapo/Callback;.start (Ljava/lang/String;)V:9(0)
+Ldacapo/Callback;.start (Ljava/lang/String;Z)V:15(0)
+Ldacapo/Callback;.complete (Ljava/lang/String;Z)V:29(0)
+Ldacapo/Callback;.stop ()V:22(0)
+Ldacapo/Callback;.complete (Ljava/lang/String;ZZ)V:35(0)
+
+Lharness/Callback;.<init> ()V:0(0)
+Lharness/Callback;.start ()V:15(0)
+Lharness/Callback;.start (Ljava/lang/String;)V:8(0)
+Lharness/Callback;.start (Ljava/lang/String;Z)V:14(0)
+Lharness/Callback;.stop ()V:22(0)
+Lharness/Callback;.complete (Ljava/lang/String;Z)V:29(0)
+Lharness/Callback;.complete (Ljava/lang/String;ZZ)V:35(0)
+Lharness/Callback;.salutation (Z)V:24(0)
+Lharness/Callback;.startWarmup ()V:0(0)
+Lharness/Callback;.stopWarmup ()V:0(0)
+Lharness/Callback;.message (ZZJ)V:0(0)
+
+LHarness;.main ([Ljava/lang/String;)V:5(0)
+
+Ldacapo/TestHarness;.main ([Ljava/lang/String;)V:110(0)
+Ldacapo/TestHarness;.runBenchmark (Ljava/io/File;Ljava/lang/String;Ldacapo/TestHarness;)V:268(0)
+Ldacapo/TestHarness;.findClass ()Ljava/lang/Class;:414(0)
+Ldacapo/TestHarness;.rmdir (Ljava/io/File;)V:376(0)
+Ldacapo/TestHarness;.printUsage ()V:351(0)
+
+# Mostly for DaCapo 2006
+Ldacapo/Benchmark;.preIteration (Ljava/lang/String;)V:182(0)
+Ldacapo/Benchmark;.startIteration ()V:204(0)
+Ldacapo/Benchmark;.postIteration (Ljava/lang/String;)V:364(0)
+Ldacapo/Benchmark;.postIterationCleanup (Ljava/lang/String;)V:375(0)
+Ldacapo/Benchmark;.run (Ldacapo/Callback;Ljava/lang/String;Z)Z:126(50)
+Ldacapo/Benchmark;.cleanup ()V:391(0)
+Ldacapo/Benchmark/Main;.main ()V:18(0)
+Ldacapo/Benchmark;.validate (Ljava/lang/String;)Z:246(0)
+Ldacapo/Benchmark;.deleteTree (Ljava/io/File;)V:519(0)
+Ldacapo/Benchmark;.stopIteration ()V:230(0)
+Ldacapo/Benchmark;.deleteFile (Ljava/io/File;)V:532(0)
+Ldacapo/Benchmark;.iterate (Ljava/lang/String;)V:222(0)
+
+LMMTkHarness;.harnessBegin ()V:41(0)
+LMMTkHarness;.harnessEnd ()V:49(0)
+
+Ldacapo/TeePrintStream;.openLog ()V:37(0)
+Ldacapo/TeePrintStream;.closeLog ()V:40(0)
+Ldacapo/TeeOutputStream;.openLog ()V:50(0)
+Ldacapo/TeeOutputStream;.closeLog ()V:54(0)
+
+# Should be for DaCapo 2009
+Lorg/dacapo/harness/TestHarness;.main ([Ljava/lang/String;)V:100(0)
+Lorg/dacapo/harness/TestHarness;.runBenchmark (Ljava/io/File;Ljava/lang/String;Lorg/dacapo/harness/TestHarness;)V:207(0)
+Lorg/dacapo/harness/CommandLineArgs;.getSize ()Ljava/lang/String;:0(0)
+Lorg/dacapo/harness/TestHarness;.getBuildVersion ()Ljava/lang/String;:0(0)
+Lorg/dacapo/harness/Benchmark;.run (Lorg/dacapo/harness/Callback;Ljava/lang/String;)Z:142(0)
+Lorg/dacapo/harness/Benchmark;.iterate (Ljava/lang/String;)V:304(0)
+Lorg/dacapo/harness/Benchmark;.preIteration (Ljava/lang/String;)V:260(0)
+Lorg/dacapo/harness/Benchmark;.startIteration ()V:282(0)
+Lorg/dacapo/harness/Benchmark;.stopIteration ()V:311(0)
+Lorg/dacapo/harness/Benchmark;.postIteration (Ljava/lang/String;)V:467(0)
+Lorg/dacapo/harness/Benchmark;.useBenchmarkClassLoader ()V:327(0)
+Lorg/dacapo/harness/Benchmark;.prepare (Ljava/lang/String;)V:0(0)
+Lorg/dacapo/harness/TeePrintStream;.openLog ()V:41(0)
+Lorg/dacapo/harness/TeePrintStream;.closeLog ()V:45(0)
+Lorg/dacapo/harness/TeeOutputStream;.openLog ()V:58(0)
+Lorg/dacapo/harness/TeeOutputStream;.closeLog ()V:62(0)
+Lorg/dacapo/harness/TeeOutputStream;.newLog ()V:50(0)
+
+Lorg/dacapo/harness/Callback;.complete (Ljava/lang/String;Z)V:192(0)
+Lorg/dacapo/harness/Callback;.stop ()V:178(0)
+Lorg/dacapo/harness/Callback;.start (Ljava/lang/String;)V:161(0)
+Lorg/dacapo/harness/Callback;.start (Ljava/lang/String;Z)V:170(0)
+Lorg/dacapo/harness/Callback;.complete (Ljava/lang/String;ZZ)V:201(0)
+
+# microbenchmarks
+
+Latomicity/test2;.main ([Ljava/lang/String;)V:5(0)
+Latomicity/ThreadDemo2;.main ([Ljava/lang/String;)V:7(0)
+Latomicity/NewThread2;.run ()V:21(0)
+Latomicity/ThreadDemo4;.main ([Ljava/lang/String;)V:8(0)
+Latomicity/NewThread4;.run ()V:24(0)
+Latomicity/ThreadDemo5;.main ([Ljava/lang/String;)V:8(0)
+Latomicity/NewThread5;.run ()V:25(0)
+Latomicity/ThreadDemo6;.main ([Ljava/lang/String;)V:5(0)
+Latomicity/NewThread6;.run ()V:34(0)
+#Latomicity/NewThread6;.access ()V:39(0)
+Latomicity/ThreadDemo7;.main ([Ljava/lang/String;)V:5(0)
+Latomicity/NewThread7;.run ()V:25(0)
+
+# Doug Lea's concurrent library, details copied from velodrome specification. Each of the following methods contain 
+# a synchronization primitive or overrides Thread::run()
+
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;.run ()V:793(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;.scanWhileIdling ()V:718(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup$InvokableFJTask;.awaitTermination ()V:611(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.checkActive (LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;J)V:534(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.invoke (Ljava/lang/Runnable;)V:214(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.setActive (LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;)V:465(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.signalNewTask ()V:565(0) 
+LEDU/oswego/cs/dl/util/concurrent/LinkedQueue;.take ()Ljava/lang/Object;:105(0)
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/moldyn.txt workspace/velodrome-sound/velodrome/atomicity-specifications/moldyn.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/moldyn.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/moldyn.txt	2014-04-03 17:43:57.381717729 -0400
@@ -0,0 +1,13 @@
+# Moldyn
+LJGFMolDynBenchSizeA;.main ([Ljava/lang/String;)V:0(0)
+#Lmoldyn/JGFMolDynBenchSizeA;.main ([Ljava/lang/String;)V:29(0)
+Lmoldyn/JGFMolDynBench;.JGFrun (I)V:71(0)
+Lmoldyn/JGFMolDynBench;.JGFapplication ()V:48(0)
+Lmoldyn/JGFMolDynBench;.runiters ()V:64(0)
+Lmoldyn/md;.runiters ()V:64(0)
+Lmoldyn/mdRunner;.run ()V:68(0)
+
+# This method calls Thread.yield()
+Lmoldyn/TournamentBarrier;.DoBarrier (I)V:53(0)
+
+# Merged results
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/montecarlo.txt workspace/velodrome-sound/velodrome/atomicity-specifications/montecarlo.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/montecarlo.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/montecarlo.txt	2014-04-03 17:43:57.381717729 -0400
@@ -0,0 +1,13 @@
+
+LJGFMonteCarloBenchSizeA;.main ([Ljava/lang/String;)V:32(0)
+Lmontecarlo/AppDemo;.runThread ()V:151(0)
+Lmontecarlo/CallAppDemo;.runiters ()V:50(0)
+Lmontecarlo/JGFMonteCarloBench;.runiters ()V:0(0)
+Lmontecarlo/JGFMonteCarloBench;.JGFapplication ()V:45(0)
+Lmontecarlo/JGFMonteCarloBench;.JGFrun (I)V:72(0)
+Lmontecarlo/AppDemoThread;.run ()V:366(0)
+
+# Merged results
+
+Lmontecarlo/PriceStock;.<init> ()V:85(0)
+Lmontecarlo/PriceStock;.run ()V:135(0)
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/philo.txt workspace/velodrome-sound/velodrome/atomicity-specifications/philo.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/philo.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/philo.txt	2014-04-03 17:43:57.382717732 -0400
@@ -0,0 +1,14 @@
+# Philo
+
+LPhilo;.main ([Ljava/lang/String;)V:69(0)
+LPhilo;.run ()V:49(0)
+LPhilo;.start ()V:917(0)
+LPhilo;.join ()V:675(0)
+LPhilo;.sleep (J)V:866(0)
+
+# These methods have wait/notify calls within them
+LTable;.getForks (I)I:14(0)
+LTable;.putForks (I)V:28(0)
+
+#Merged results
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/pmd9.txt workspace/velodrome-sound/velodrome/atomicity-specifications/pmd9.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/pmd9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/pmd9.txt	2014-04-03 17:43:57.382717732 -0400
@@ -0,0 +1,7 @@
+# Trivial
+Lnet/sourceforge/pmd/PMD$PmdThread;.run ()V:0(0) 
+Lnet/sourceforge/pmd/PMD;.main ([Ljava/lang/String;)V:405(0)
+
+# Merged results
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/raytracer.txt workspace/velodrome-sound/velodrome/atomicity-specifications/raytracer.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/raytracer.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/raytracer.txt	2014-04-03 17:43:57.380717726 -0400
@@ -0,0 +1,15 @@
+# Raytracer
+
+LJGFRayTracerBenchSizeA;.main ([Ljava/lang/String;)V:33(0)
+Lraytracer/JGFRayTracerBench;.JGFapplication ()V:52(0)
+Lraytracer/JGFRayTracerBench;.JGFrun (I)V:102(0)
+Ljava/lang/Thread;.run ()V:744(-2)
+Lraytracer/RayTracerRunner;.run ()V:161(0)
+# This method calls Thread.yield()
+Lraytracer/TournamentBarrier;.DoBarrier (I)V:0(0)
+
+# This is a huge transaction which causes problems for Phase 2 in AVD, so omitting this. This is not reported as a violation.
+Lraytracer/RayTracer;.render (Lraytracer/Interval;)V:180(0)
+
+# Merged results
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/sor.txt workspace/velodrome-sound/velodrome/atomicity-specifications/sor.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/sor.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/sor.txt	2014-04-03 17:43:57.381717729 -0400
@@ -0,0 +1,13 @@
+# Sor
+# These methods are trivially left out
+Lsor/Sor;.main ([Ljava/lang/String;)V:31(0)
+Lsor/sor_first_row_even;.run ()V:236(0)
+Lsor/sor_first_row_odd;.run ()V:171(0))
+
+# These methods might not be intended to be atomic since they have wait()/notify() calls in them. 
+# These are false warnings. These should not be considered.
+LEDU/oswego/cs/dl/util/concurrent/CyclicBarrier;.barrier ()I:177(0)
+LEDU/oswego/cs/dl/util/concurrent/CyclicBarrier;.doBarrier (ZJ)I:214(0)
+
+#Merged results
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/sunflow9.txt workspace/velodrome-sound/velodrome/atomicity-specifications/sunflow9.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/sunflow9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/sunflow9.txt	2014-04-03 17:43:57.379717723 -0400
@@ -0,0 +1,28 @@
+# Trivial
+Lorg/sunflow/core/LightServer$1;.run ()V:202(0)
+Lorg/sunflow/core/renderer/SimpleRenderer$BucketThread;.run ()V:57(0)
+Lorg/sunflow/core/renderer/ProgressiveRenderer$SmallBucketThread;.run ()V:78(0)
+Lorg/sunflow/core/renderer/BucketRenderer$BucketThread;.run ()V:178(0)
+
+# The following methods cause trouble if it is part of a Phase 1 cycle, since it has almost 98% read/write accesses, and
+# Phase 2 runs into memory issues if while processing these transactions
+Lorg/sunflow/core/renderer/BucketRenderer;.access$300 (Lorg/sunflow/core/renderer/BucketRenderer;Lorg/sunflow/core/Display;IIILorg/sunflow/core/IntersectionState;)V:24(0)
+Lorg/sunflow/core/renderer/BucketRenderer;.renderBucket (Lorg/sunflow/core/Display;IIILorg/sunflow/core/IntersectionState;)V:199(0)
+
+# Merged results
+
+Lorg/sunflow/core/accel/BoundingIntervalHierarchy;.intersect (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:374(0)
+Lorg/sunflow/core/Geometry;.intersect (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:89(0)
+Lorg/sunflow/core/Geometry;.tesselate ()V:98(0)
+Lorg/sunflow/core/Instance;.intersect (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:133(0)
+Lorg/sunflow/core/InstanceList;.intersectPrimitive (Lorg/sunflow/core/Ray;ILorg/sunflow/core/IntersectionState;)V:30(0)
+Lorg/sunflow/core/LightServer;.access$008 (Lorg/sunflow/core/LightServer;)I:13(0)
+Lorg/sunflow/core/LightServer;.shadePhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/image/Color;)V:260(0)
+Lorg/sunflow/core/LightServer;.traceDiffusePhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:268(0)
+Lorg/sunflow/core/LightServer;.traceRefractionPhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:292(0)
+Lorg/sunflow/core/Scene;.trace (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:193(0)
+Lorg/sunflow/core/shader/DiffuseShader;.scatterPhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/image/Color;)V:40(0)
+Lorg/sunflow/core/shader/GlassShader;.scatterPhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/image/Color;)V:90(0)
+Lorg/sunflow/core/ShadingState;.traceDiffusePhoton (Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:654(0)
+Lorg/sunflow/core/ShadingState;.traceRefractionPhoton (Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:637(0)
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/tsp.txt workspace/velodrome-sound/velodrome/atomicity-specifications/tsp.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/tsp.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/tsp.txt	2014-04-03 17:43:57.382717732 -0400
@@ -0,0 +1,16 @@
+# Tsp
+
+LTsp;.main ([Ljava/lang/String;)V:27(0)
+LTspSolver;.run ()V:33(0)
+
+# Merged results
+
+LTspSolver;.Worker ()V:37(0)
+LTspSolver;.get_tour (I)I:454(0)
+LTspSolver;.recursive_solve (I)V:473(0)
+LTspSolver;.find_solvable_tour ()I:362(0)
+LTspSolver;.visit_nodes (I)V:516(0)
+LTspSolver;.split_tour (I)V:270(0)
+LTspSolver;.set_best (I[I)V:104(0)
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/xalan6.txt workspace/velodrome-sound/velodrome/atomicity-specifications/xalan6.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/xalan6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/xalan6.txt	2014-04-03 17:43:57.379717723 -0400
@@ -0,0 +1,75 @@
+# Xalan6
+
+# Trivial
+Ldacapo/xalan/XalanHarness$XalanWorker;.run ()V:80(0)
+
+# Merged results
+
+Lorg/apache/xalan/serialize/CharInfo;.getEntityNameForChar (C)Ljava/lang/String;:296(-2)
+Lorg/apache/xalan/serialize/SerializerFactory;.getSerializer (Ljava/util/Properties;)Lorg/apache/xalan/serialize/Serializer;:106(0)
+Lorg/apache/xalan/serialize/SerializerToHTML;.characters ([CII)V:1192(0)
+Lorg/apache/xalan/serialize/SerializerToXML;.accumDefaultEntity (CI[CIZ)I:2128(-2)
+Lorg/apache/xalan/serialize/SerializerToXML;.accumDefaultEscape (CI[CIZ)I:2178(0)
+Lorg/apache/xalan/templates/AVT;.evaluate (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Ljava/lang/String;:517(0)
+Lorg/apache/xalan/templates/AVTPartXPath;.evaluate (Lorg/apache/xpath/XPathContext;Lorg/apache/xml/utils/FastStringBuffer;ILorg/apache/xml/utils/PrefixResolver;)V:175(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:191(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:244(0)
+Lorg/apache/xalan/templates/ElemAttribute;.constructNode (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/apache/xalan/transformer/TransformerImpl;)V:222(0)
+Lorg/apache/xalan/templates/ElemAttribute;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:123(0)
+Lorg/apache/xalan/templates/ElemCallTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:225(0)
+Lorg/apache/xalan/templates/ElemChoose;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:125(0)
+Lorg/apache/xalan/templates/ElemCopy;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:138(0)
+Lorg/apache/xalan/templates/ElemElement;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:282(0)
+Lorg/apache/xalan/templates/ElemForEach;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:294(0)
+Lorg/apache/xalan/templates/ElemForEach;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:369(0)
+Lorg/apache/xalan/templates/ElemIf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:174(0)
+Lorg/apache/xalan/templates/ElemLiteralResult;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:664(0)
+Lorg/apache/xalan/templates/ElemMessage;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:160(0)
+Lorg/apache/xalan/templates/ElemNumber;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:601(0)
+Lorg/apache/xalan/templates/ElemNumber;.formatNumberList (Lorg/apache/xalan/transformer/TransformerImpl;[JI)Ljava/lang/String;:1208(0)
+Lorg/apache/xalan/templates/ElemNumber;.getCountString (Lorg/apache/xalan/transformer/TransformerImpl;I)Ljava/lang/String;:840(0)
+Lorg/apache/xalan/templates/ElemNumber;.getFormattedNumber (Lorg/apache/xalan/transformer/TransformerImpl;ICIJLorg/apache/xml/utils/FastStringBuffer;)V:1367(0)
+Lorg/apache/xalan/templates/ElemTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:423(0)
+Lorg/apache/xalan/templates/ElemValueOf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:260(0)
+Lorg/apache/xalan/templates/ElemVariable;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:286(0)
+Lorg/apache/xalan/templates/ElemVariable;.getValue (Lorg/apache/xalan/transformer/TransformerImpl;I)Lorg/apache/xpath/objects/XObject;:315(0)
+Lorg/apache/xalan/templates/OutputProperties;.getDefaultMethodProperties (Ljava/lang/String;)Ljava/util/Properties;:317(0)
+Lorg/apache/xalan/templates/OutputProperties;.<init> (Ljava/lang/String;)V:129(0)
+Lorg/apache/xalan/templates/StylesheetRoot;.newTransformer ()Ljavax/xml/transform/Transformer;:212(0)
+Lorg/apache/xalan/transformer/ResultTreeHandler;.characters ([CII)V:480(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.applyTemplateToNode (Lorg/apache/xalan/templates/ElemTemplateElement;Lorg/apache/xalan/templates/ElemTemplate;I)Z:2024(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.createResultContentHandler (Ljavax/xml/transform/Result;Lorg/apache/xalan/templates/OutputProperties;)Lorg/xml/sax/ContentHandler;:996(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.createResultContentHandler (Ljavax/xml/transform/Result;)Lorg/xml/sax/ContentHandler;:975(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.executeChildTemplates (Lorg/apache/xalan/templates/ElemTemplateElement;Z)V:2291(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.<init> (Lorg/apache/xalan/templates/StylesheetRoot;)V:400(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;)V:1107(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;Z)V:1122(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Z)V:628(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformNode (I)V:1169(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformToString (Lorg/apache/xalan/templates/ElemTemplateElement;)Ljava/lang/String;:1921(0)
+Lorg/apache/xerces/jaxp/SAXParserFactoryImpl;.newSAXParser ()Ljavax/xml/parsers/SAXParser;:0(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl;.<init> (Lorg/apache/xerces/jaxp/SAXParserFactoryImpl;Ljava/util/Hashtable;Z)V:0(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl$JAXPSAXParser;.<init> (Lorg/apache/xerces/jaxp/SAXParserImpl;)V:0(0)
+Lorg/apache/xerces/parsers/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:0(0)
+Lorg/apache/xerces/parsers/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:0(0)
+Lorg/apache/xerces/parsers/SAXParser;.<init> (Lorg/apache/xerces/util/SymbolTable;Lorg/apache/xerces/xni/grammars/XMLGrammarPool;)V:0(0)
+Lorg/apache/xerces/parsers/SAXParser;.<init> ()V:0(0)
+Lorg/apache/xml/dtm/DTMManager;.findFactory (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;:405(0)
+Lorg/apache/xml/dtm/DTMManager;.newInstance (Lorg/apache/xml/utils/XMLStringFactory;)Lorg/apache/xml/dtm/DTMManager;:179(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getDTM (Ljavax/xml/transform/Source;ZLorg/apache/xml/dtm/DTMWSFilter;ZZ)Lorg/apache/xml/dtm/DTM;:285(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getXMLReader (Ljavax/xml/transform/Source;)Lorg/xml/sax/XMLReader;:647(0)
+Lorg/apache/xml/dtm/ref/sax2dtm/SAX2DTM;.dispatchCharactersEvents (ILorg/xml/sax/ContentHandler;Z)V:484(0)
+Lorg/apache/xml/utils/FastStringBuffer;.sendSAXcharacters (Lorg/xml/sax/ContentHandler;II)V:1011(0)
+Lorg/apache/xml/utils/StringBufferPool;.free (Lorg/apache/xml/utils/FastStringBuffer;)V:93(-2)
+Lorg/apache/xpath/axes/LocPathIterator;.asIterator (Lorg/apache/xpath/XPathContext;I)Lorg/apache/xml/dtm/DTMIterator;:315(-2)
+Lorg/apache/xpath/axes/LocPathIterator;.asNode (Lorg/apache/xpath/XPathContext;)I:344(0)
+Lorg/apache/xpath/axes/LocPathIterator;.bool (Lorg/apache/xpath/XPathContext;)Z:368(0)
+Lorg/apache/xpath/axes/LocPathIterator;.detach ()V:726(0)
+Lorg/apache/xpath/axes/LocPathIterator;.executeCharsToContentHandler (Lorg/apache/xpath/XPathContext;Lorg/xml/sax/ContentHandler;)V:281(0)
+Lorg/apache/xpath/axes/LocPathIterator;.execute (Lorg/apache/xpath/XPathContext;)Lorg/apache/xpath/objects/XObject;:255(0)
+Lorg/apache/xpath/axes/NodeSequence;.detach ()V:378(0)
+Lorg/apache/xpath/operations/And;.bool (Lorg/apache/xpath/XPathContext;)Z:111(0)
+Lorg/apache/xpath/XPath;.bool (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Z:377(0)
+Lorg/apache/xpath/XPathContext;.<init> (Ljava/lang/Object;)V:357(0)
+Lorg/apache/xpath/XPath;.execute (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Lorg/apache/xpath/objects/XObject;:300(0)
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/xalan9.txt workspace/velodrome-sound/velodrome/atomicity-specifications/xalan9.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomicity-specifications/xalan9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomicity-specifications/xalan9.txt	2014-04-03 17:43:57.380717726 -0400
@@ -0,0 +1,87 @@
+# Trivial
+Lorg/dacapo/xalan/XSLTBench$XalanWorker;.run ()V:91(0)
+
+# Merged results
+
+Lorg/apache/xalan/templates/AVT;.evaluate (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Ljava/lang/String;:490(0)
+Lorg/apache/xalan/templates/AVTPartXPath;.evaluate (Lorg/apache/xpath/XPathContext;Lorg/apache/xml/utils/FastStringBuffer;ILorg/apache/xml/utils/PrefixResolver;)V:135(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:153(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:205(0)
+Lorg/apache/xalan/templates/ElemAttribute;.constructNode (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/apache/xalan/transformer/TransformerImpl;)V:184(0)
+Lorg/apache/xalan/templates/ElemCallTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:196(0)
+Lorg/apache/xalan/templates/ElemChoose;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:81(0)
+Lorg/apache/xalan/templates/ElemCopy;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:92(0)
+Lorg/apache/xalan/templates/ElemElement;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:205(0)
+Lorg/apache/xalan/templates/ElemForEach;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:259(0)
+Lorg/apache/xalan/templates/ElemForEach;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:333(0)
+Lorg/apache/xalan/templates/ElemIf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:130(0)
+Lorg/apache/xalan/templates/ElemLiteralResult;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:1303(0)
+Lorg/apache/xalan/templates/ElemMessage;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:117(0)
+Lorg/apache/xalan/templates/ElemNumber;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:560(0)
+Lorg/apache/xalan/templates/ElemNumber;.formatNumberList (Lorg/apache/xalan/transformer/TransformerImpl;[JI)Ljava/lang/String;:1171(0)
+Lorg/apache/xalan/templates/ElemNumber;.getCountMatchPattern (Lorg/apache/xpath/XPathContext;I)Lorg/apache/xpath/XPath;:730(0)
+Lorg/apache/xalan/templates/ElemNumber;.getCountString (Lorg/apache/xalan/transformer/TransformerImpl;I)Ljava/lang/String;:799(0)
+Lorg/apache/xalan/templates/ElemNumber;.getFormattedNumber (Lorg/apache/xalan/transformer/TransformerImpl;ICIJLorg/apache/xml/utils/FastStringBuffer;)V:1330(0)
+Lorg/apache/xalan/templates/ElemNumber;.getMatchingAncestors (Lorg/apache/xpath/XPathContext;IZ)Lorg/apache/xml/utils/NodeVector;:990(0)
+Lorg/apache/xalan/templates/ElemTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:382(0)
+Lorg/apache/xalan/templates/ElemValueOf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:215(0)
+Lorg/apache/xalan/templates/ElemVariable;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:243(0)
+Lorg/apache/xalan/templates/ElemVariable;.getValue (Lorg/apache/xalan/transformer/TransformerImpl;I)Lorg/apache/xpath/objects/XObject;:272(0)
+Lorg/apache/xalan/templates/OutputProperties;.<init> (Ljava/lang/String;)V:82(0)
+Lorg/apache/xalan/templates/StylesheetRoot;.newTransformer ()Ljavax/xml/transform/Transformer;:200(0)
+Lorg/apache/xalan/templates/TemplateList;.getTemplateFast (Lorg/apache/xpath/XPathContext;IILorg/apache/xml/utils/QName;IZLorg/apache/xml/dtm/DTM;)Lorg/apache/xalan/templates/ElemTemplate;:504(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.applyTemplateToNode (Lorg/apache/xalan/templates/ElemTemplateElement;Lorg/apache/xalan/templates/ElemTemplate;I)Z:2133(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.createSerializationHandler (Ljavax/xml/transform/Result;Lorg/apache/xalan/templates/OutputProperties;)Lorg/apache/xml/serializer/SerializationHandler;:1087(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.createSerializationHandler (Ljavax/xml/transform/Result;)Lorg/apache/xml/serializer/SerializationHandler;:1060(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.executeChildTemplates (Lorg/apache/xalan/templates/ElemTemplateElement;Z)V:2352(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.<init> (Lorg/apache/xalan/templates/StylesheetRoot;)V:392(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.reset ()V:486(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;)V:1251(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;Z)V:1266(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Z)V:639(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformNode (I)V:1312(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformToString (Lorg/apache/xalan/templates/ElemTemplateElement;)Ljava/lang/String;:2045(0)
+Lorg/apache/xml/dtm/DTMManager;.newInstance (Lorg/apache/xml/utils/XMLStringFactory;)Lorg/apache/xml/dtm/DTMManager;:134(0)
+Lorg/apache/xml/dtm/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:103(0)
+Lorg/apache/xml/dtm/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:133(0)
+Lorg/apache/xml/dtm/ObjectFactory;.findClassLoader ()Ljava/lang/ClassLoader;:396(0)
+Lorg/apache/xml/dtm/ObjectFactory;.findJarServiceProviderName (Ljava/lang/String;)Ljava/lang/String;:537(0)
+Lorg/apache/xml/dtm/ObjectFactory;.lookUpFactoryClass (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Class;:208(0)
+Lorg/apache/xml/dtm/ObjectFactory;.lookUpFactoryClassName (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;:261(0)
+Lorg/apache/xml/dtm/ref/DTMDefaultBase;.getNode (I)Lorg/w3c/dom/Node;:2218(0)
+Lorg/apache/xml/dtm/ref/DTMDefaultBaseTraversers;.getAxisTraverser (I)Lorg/apache/xml/dtm/DTMAxisTraverser;:107(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getDTM (Ljavax/xml/transform/Source;ZLorg/apache/xml/dtm/DTMWSFilter;ZZ)Lorg/apache/xml/dtm/DTM;:247(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getXMLReader (Ljavax/xml/transform/Source;)Lorg/xml/sax/XMLReader;:601(0)
+Lorg/apache/xml/dtm/ref/sax2dtm/SAX2DTM;.<init> (Lorg/apache/xml/dtm/DTMManager;Ljavax/xml/transform/Source;ILorg/apache/xml/dtm/DTMWSFilter;Lorg/apache/xml/utils/XMLStringFactory;ZIZZ)V:253(0)
+Lorg/apache/xml/dtm/ref/sax2dtm/SAX2DTM;.<init> (Lorg/apache/xml/dtm/DTMManager;Ljavax/xml/transform/Source;ILorg/apache/xml/dtm/DTMWSFilter;Lorg/apache/xml/utils/XMLStringFactory;Z)V:224(0)
+Lorg/apache/xml/serializer/CharInfo;.getCharInfoBasedOnPrivilege (Ljava/lang/String;Ljava/lang/String;Z)Lorg/apache/xml/serializer/CharInfo;:462(0)
+Lorg/apache/xml/serializer/CharInfo;.getCharInfo (Ljava/lang/String;Ljava/lang/String;)Lorg/apache/xml/serializer/CharInfo;:491(0)
+Lorg/apache/xml/serializer/ObjectFactory;.findClassLoader ()Ljava/lang/ClassLoader;:395(0)
+Lorg/apache/xml/serializer/OutputPropertiesFactory;.getDefaultMethodProperties (Ljava/lang/String;)Ljava/util/Properties;:254(0)
+Lorg/apache/xml/serializer/SerializerFactory;.getSerializer (Ljava/util/Properties;)Lorg/apache/xml/serializer/Serializer;:96(0)
+Lorg/apache/xml/serializer/ToHTMLStream;.<init> ()V:662(0)
+Lorg/apache/xml/serializer/ToHTMLStream;.setOutputFormat (Ljava/util/Properties;)V:574(0)
+Lorg/apache/xml/serializer/ToStream;.<init> ()V:184(0)
+Lorg/apache/xml/utils/XMLReaderManager;.getXMLReader ()Lorg/xml/sax/XMLReader;:84(0)
+Lorg/apache/xpath/axes/FilterExprWalker;.setRoot (I)V:129(0)
+Lorg/apache/xpath/axes/LocPathIterator;.asIterator (Lorg/apache/xpath/XPathContext;I)Lorg/apache/xml/dtm/DTMIterator;:267(0)
+Lorg/apache/xpath/axes/LocPathIterator;.asNode (Lorg/apache/xpath/XPathContext;)I:296(0)
+Lorg/apache/xpath/axes/LocPathIterator;.bool (Lorg/apache/xpath/XPathContext;)Z:320(0)
+Lorg/apache/xpath/axes/LocPathIterator;.executeCharsToContentHandler (Lorg/apache/xpath/XPathContext;Lorg/xml/sax/ContentHandler;)V:236(0)
+Lorg/apache/xpath/axes/LocPathIterator;.execute (Lorg/apache/xpath/XPathContext;)Lorg/apache/xpath/objects/XObject;:210(0)
+Lorg/apache/xpath/axes/NodeSequence;.setRoot (ILjava/lang/Object;)V:261(0)
+Lorg/apache/xpath/axes/WalkingIterator;.setRoot (ILjava/lang/Object;)V:153(0)
+Lorg/apache/xpath/Expression;.bool (Lorg/apache/xpath/XPathContext;)Z:186(0)
+Lorg/apache/xpath/operations/And;.bool (Lorg/apache/xpath/XPathContext;)Z:72(0)
+Lorg/apache/xpath/operations/Operation;.execute (Lorg/apache/xpath/XPathContext;)Lorg/apache/xpath/objects/XObject;:109(0)
+Lorg/apache/xpath/patterns/StepPattern;.execute (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/dtm/DTM;I)Lorg/apache/xpath/objects/XObject;:386(0)
+Lorg/apache/xpath/patterns/StepPattern;.executeRelativePathPattern (Lorg/apache/xpath/XPathContext;Lorg/apache/xml/dtm/DTM;I)Lorg/apache/xpath/objects/XObject;:669(0)
+Lorg/apache/xpath/XPath;.bool (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Z:406(0)
+Lorg/apache/xpath/XPathContext;.<init> (Ljava/lang/Object;)V:337(0)
+Lorg/apache/xpath/XPathContext;.<init> (Ljava/lang/Object;Z)V:349(0)
+Lorg/apache/xpath/XPathContext;.<init> (Z)V:319(0)
+Lorg/apache/xpath/XPathContext;.reset ()V:362(0)
+Lorg/apache/xpath/XPath;.execute (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Lorg/apache/xpath/objects/XObject;:329(0)
+Lorg/xml/sax/helpers/NewInstance;.newInstance (Ljava/lang/ClassLoader;Ljava/lang/String;)Ljava/lang/Object;:0(0)
+Lorg/xml/sax/helpers/XMLReaderFactory;.createXMLReader ()Lorg/xml/sax/XMLReader;:0(0)
+Lorg/xml/sax/helpers/XMLReaderFactory;.loadClass (Ljava/lang/ClassLoader;Ljava/lang/String;)Lorg/xml/sax/XMLReader;:0(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/elevator.xml workspace/velodrome-sound/velodrome/atomizer_logs/elevator.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/elevator.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/elevator.xml	2014-04-03 17:43:56.637715284 -0400
@@ -0,0 +1,152 @@
+<entry>
+  <data> Mon Mar 04 12:38:12 EST 2013 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> elevator.Elevator data -xml  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> .:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-358.0.1.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe </value> 
+    <memPeak> 88 </memPeak> 
+    <memUsed> 80 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 1115 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 0 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 0 </time> </gc>
+  </system>
+  <instrumented> elevator/ButtonPress elevator/Controls elevator/Elevator elevator/Floor elevator/Lift  </instrumented> 
+  <instrumentedNum> 5 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 3 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 2 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>69.0000</total> <count>5</count> <ave>13.8000</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 3 </threadCount> 
+  <errorTotal> 108 </errorTotal> 
+  <distinctErrorTotal> 5 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> elevator/Controls.claimUp(Ljava/lang/String;I)Z(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> elevator/Lift.doMoving()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> elevator/Controls.claimDown(Ljava/lang/String;I)Z(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 3 </count> </error>
+    </method>
+    <method>
+      <name> elevator/Elevator.begin()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> elevator/Lift.doIdle()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 108 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 24007 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/hedc.xml workspace/velodrome-sound/velodrome/atomizer_logs/hedc.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/hedc.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/hedc.xml	2014-04-03 17:43:56.638715287 -0400
@@ -0,0 +1,242 @@
+<entry>
+  <data> Mon Mar 04 12:51:11 EST 2013 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> hedc.Tester -xml  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> .:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-358.0.1.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe </value> 
+    <memPeak> 182 </memPeak> 
+    <memUsed> 171 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 2452 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 0 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 0 </time> </gc>
+  </system>
+  <instrumented> EDU/oswego/cs/dl/util/concurrent/Channel EDU/oswego/cs/dl/util/concurrent/LinkedNode EDU/oswego/cs/dl/util/concurrent/LinkedQueue EDU/oswego/cs/dl/util/concurrent/Puttable EDU/oswego/cs/dl/util/concurrent/Takable hedc/DateFormatter hedc/FormFiller hedc/Messages hedc/MetaSearch hedc/MetaSearchImpl hedc/MetaSearchRequest hedc/MetaSearchResult hedc/MetaSearchResult$MetaSearchResultIterator hedc/PooledExecutorWithInvalidate hedc/PooledExecutorWithInvalidate$BlockedExecutionHandler hedc/PooledExecutorWithInvalidate$DiscardWhenBlocked hedc/PooledExecutorWithInvalidate$RunWhenBlocked hedc/PooledExecutorWithInvalidate$WaitWhenBlocked hedc/PooledExecutorWithInvalidate$Worker hedc/Rag hedc/RandomDate hedc/SohoSynoptic hedc/SohoSynoptic$SohoIterator hedc/Task hedc/TaskFactory hedc/Tester hedc/ethz/util/BaseProperties hedc/ethz/util/EtcUtil hedc/ethz/util/Generator hedc/ethz/util/Messages hedc/ethz/util/ObservableProperties hedc/ethz/util/PropertyMonitoring hedc/ethz/util/SystemProperties hedc/regexp/Alternatives hedc/regexp/CharArrayState hedc/regexp/CharClass hedc/regexp/CompilerState hedc/regexp/ContextMatch hedc/regexp/Dot hedc/regexp/Group hedc/regexp/GroupReference hedc/regexp/Literal hedc/regexp/MalformedRegexpException hedc/regexp/Multi hedc/regexp/NoSuchMatchException hedc/regexp/Regexp hedc/regexp/RegexpCompiler hedc/regexp/State hedc/regexp/StringState hedc/regexp/SuccessRegexp  </instrumented> 
+  <instrumentedNum> 50 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 8 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 7 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 6 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "ShadowVolatile: objects" </name>                    <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>473.000</total> <count>50</count> <ave>9.46000</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 7 </threadCount> 
+  <errorTotal> 107 </errorTotal> 
+  <distinctErrorTotal> 27 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> hedc/regexp/State.startGroup(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/PooledExecutorWithInvalidate.getTask()Lhedc/Task;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/SohoSynoptic.createResults_()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/Regexp.compile(Ljava/lang/String;)Lhedc/regexp/Regexp;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/MetaSearchImpl.getUniqueInstance()Lhedc/MetaSearchImpl;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/Regexp.compile(Ljava/lang/String;Z)Lhedc/regexp/Regexp;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/MetaSearchImpl.search(Ljava/util/Hashtable;Lhedc/MetaSearchRequest;)Ljava/util/List;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/MetaSearchRequest.printResults()Ljava/lang/String;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/RegexpCompiler.compileAlternative(Lhedc/regexp/CompilerState;Lhedc/regexp/Regexp;)Lhedc/regexp/Regexp;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 8 </count> </error>
+    </method>
+    <method>
+      <name> hedc/ethz/util/SystemProperties.getUniqueInstance()Lhedc/ethz/util/SystemProperties;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/Regexp.makeMulti(I)Lhedc/regexp/Regexp;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/SohoSynoptic.runImpl()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/Regexp.searchForward([CII)Lhedc/regexp/Result;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/MetaSearchResult.toString()Ljava/lang/String;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/Regexp.searchForward(Lhedc/regexp/State;)Lhedc/regexp/Result;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/PooledExecutorWithInvalidate.execute(Lhedc/Task;)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/PooledExecutorWithInvalidate.addThread(Lhedc/Task;)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/Group.advance(Lhedc/regexp/State;)Lhedc/regexp/Regexp;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/State.ensureGroup(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> EDU/oswego/cs/dl/util/concurrent/LinkedQueue.take()Ljava/lang/Object;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/TaskFactory.makeTasks(Ljava/util/Hashtable;Ljava/util/Date;Lhedc/MetaSearchRequest;)Ljava/util/List;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/FormFiller.internalize(Ljava/lang/String;)[C(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/RegexpCompiler.compile(Ljava/lang/String;Z)Lhedc/regexp/Regexp;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/RegexpCompiler.compileAlternatives(Lhedc/regexp/Regexp;Lhedc/regexp/CompilerState;I)Lhedc/regexp/Regexp;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 8 </count> </error>
+    </method>
+    <method>
+      <name> hedc/regexp/Regexp.match(Lhedc/regexp/State;)Z(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/MetaSearchRequest.go()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+    <method>
+      <name> hedc/SohoSynoptic.getInfo()Ljava/util/Iterator;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 4 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 107 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 1313 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/moldynAlog.xml workspace/velodrome-sound/velodrome/atomizer_logs/moldynAlog.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/moldynAlog.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/moldynAlog.xml	2014-04-03 17:43:56.639715290 -0400
@@ -0,0 +1,166 @@
+<entry>
+  <data> Sat Sep 01 11:55:29 EDT 2012 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> JGFMolDynBenchSizeA  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> :/home/biswass/benchmarks/javaGrande:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-279.5.2.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/workspace/benchmarks/javaGrande/classes </value> 
+    <memPeak> 99 </memPeak> 
+    <memUsed> 31 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 2605 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 5 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 26 </time> </gc>
+  </system>
+  <instrumented> JGFMolDynBenchSizeA harness/Callback jgfutil/JGFInstrumentor jgfutil/JGFSection3 jgfutil/JGFTimer moldyn/Barrier moldyn/JGFMolDynBench moldyn/TournamentBarrier moldyn/md moldyn/mdRunner moldyn/particle moldyn/random  </instrumented> 
+  <instrumentedNum> 12 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 1 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 0 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "ShadowVolatile: objects" </name>                    <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>200.000</total> <count>12</count> <ave>16.6667</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 1 </threadCount> 
+  <errorTotal> 109 </errorTotal> 
+  <distinctErrorTotal> 8 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> moldyn/TournamentBarrier.DoBarrier(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFTimer.reset()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/JGFMolDynBench.JGFrun(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/md.initialise()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/JGFMolDynBench.JGFapplication()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/md.runiters()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/JGFMolDynBench.JGFinitialise()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 109 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 2698 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/moldynlog.txt workspace/velodrome-sound/velodrome/atomizer_logs/moldynlog.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/moldynlog.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/moldynlog.txt	2014-04-03 17:43:56.639715290 -0400
@@ -0,0 +1,1820 @@
+java version "1.6.0_24"
+OpenJDK Runtime Environment (IcedTea6 1.11.4) (rhel-1.49.1.11.4.el6_3-x86_64)
+OpenJDK 64-Bit Server VM (build 20.0-b12, mixed mode)
+
+[premain: Installling RoadRunner Agent...]
+[main: RoadRunner Agent Loaded.]
+[main: Running in FAST Mode]
+[RR: Creating Fresh Meta Data]
+[RR: Creating Tool Chain]
+  [RR: Creating tool loader with path [file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple/, file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools/]]
+  [RR: file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple/rrtools.properties]
+    [RR: [LOG, T, TL, S, P, N, C]]
+  [RR: 0.00200 sec]
+  [RR: file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools/rrtools.properties]
+    [RR: [HB, FT, A, LS, RS, FT_CAS, PL, BE]]
+  [RR: 0.00 sec]
+  [RR: Extending States for tools/atomizer/AtomizerTool]
+  [RR: 0.00200 sec]
+  [RR: Transforming rr/state/ShadowThread]
+  [RR: done]
+  [RR: Transforming tools/atomizer/AtomizerTool]
+  [RR: done]
+  [RR:     complete chain: tools.atomizer.AtomizerTool -> Last]
+  [RR:        enter chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:         exit chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:      acquire chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:      release chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:       access chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR: Read Fastpath code found in [Last]]
+  [RR: Write Fastpath code found in [Last]]
+[RR: 0.0290 sec]
+[RR: OPTIONS:]
+  [RR: (rr.state.agent.ThreadStateExtensionAgent) javaArgs             = JGFMolDynBenchSizeB ]
+  [RR: (rr.state.agent.ThreadStateExtensionAgent) noDecInline          = false               ]
+  [RR: (acme.util.Util)                   quiet                = false               ]
+  [RR: (acme.util.Util)                   logs                 = log                 ]
+  [RR: (acme.util.Util)                   out                  =                     ]
+  [RR: (acme.util.Util)                   err                  =                     ]
+  [RR: (rr.RRMain)                        noinst               = false               ]
+  [RR: (rr.RRMain)                        inst                 = INST                ]
+  [RR: (rr.RRMain)                        infThreads           = 0                   ]
+  [RR: (rr.RRMain)                        args                 = []                  ]
+  [RR: (acme.util.Debug)                  d                    = []                  ]
+  [RR: (rr.RRMain$4)                      help                 = false               ]
+  [RR: (rr.tool.RR)                       toolpath             = /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools]
+  [RR: (rr.tool.RR)                       classpath            = .                   ]
+  [RR: (rr.tool.RR)                       tool                 = A                   ]
+  [RR: (rr.tool.RR)                       tools                = false               ]
+  [RR: (rr.tool.RR)                       noxml                = false               ]
+  [RR: (rr.tool.RR)                       constantGC           = false               ]
+  [RR: (rr.tool.RR)                       noFP                 = false               ]
+  [RR: (rr.tool.RR)                       noEnter              = false               ]
+  [RR: (rr.tool.RR)                       xml                  = log.xml             ]
+  [RR: (rr.tool.RR)                       pulse                =                     ]
+  [RR: (rr.tool.RR)                       maxTime              = 0                   ]
+  [RR: (rr.tool.RR)                       maxMem               = 10240               ]
+  [RR: (rr.tool.RR)                       maxTid               = 16                  ]
+  [RR: (rr.tool.RR)                       stacks               = false               ]
+  [RR: (rr.tool.RR)                       values               = false               ]
+  [RR: (rr.tool.RR)                       noTidGC              = false               ]
+  [RR: (rr.tool.RR)                       noEventReuse         = false               ]
+  [RR: (rr.loader.LoaderContext)          repository           =                     ]
+  [RR: (rr.meta.MetaDataInfoMaps)         meta                 = null                ]
+  [RR: (rr.meta.InstrumentationFilter)    methods              = [default=ACCEPT]    ]
+  [RR: (rr.meta.InstrumentationFilter)    fields               = ["-.*this\$.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    lines                = [default=ACCEPT]    ]
+  [RR: (rr.meta.InstrumentationFilter)    classes              = ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    shadowThread         = ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    noop                 = [default=ACCEPT]    ]
+  [RR: (rr.instrument.classes.ThreadDataThunkInserter) noConstructor        = false               ]
+  [RR: (rr.instrument.classes.CloneFixer) noClone              = false               ]
+  [RR: (rr.instrument.Instrumentor)       dump                 =                     ]
+  [RR: (rr.instrument.Instrumentor)       field                = FINE                ]
+  [RR: (rr.instrument.Instrumentor)       fancy                = false               ]
+  [RR: (rr.instrument.Instrumentor)       arraySites           = false               ]
+  [RR: (rr.instrument.Instrumentor)       Use TestAcquires     = false               ]
+  [RR: (rr.tool.RREventGenerator)         nojoin               = false               ]
+  [RR: (rr.tool.RREventGenerator)         multiLoader          = false               ]
+  [RR: (rr.tool.RREventGenerator)         indices              = 2147483647          ]
+  [RR: (rr.state.update.Updaters)         updaters             = SAFE                ]
+  [RR: (rr.state.ArrayStateFactory)       array                = NONE                ]
+  [RR: (rr.barrier.BarrierMonitor)        nobarrier            = false               ]
+  [RR: (rr.state.AbstractArrayStateCache) noArrayLookupOpt     = false               ]
+  [RR: (rr.instrument.methods.ThreadDataInstructionAdapter) callSites            = false               ]
+  [RR: (rr.error.ErrorMessage)            maxWarn              = 100                 ]
+  [RR: (tools.atomizer.AtomizerTool)      noProtLocks          = false               ]
+  [RR: (rr.simple.MethodMonitoringTool)   atomics              = ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT]]
+[RR: 0.00700 sec]
+[RR: Installing DefineClassListener rr.loader.InstrumentingDefineClassLoader@60072ffb]
+[RR: System Class Path = [file:/home/biswass/workspace/benchmarks/javaGrande/classes/./]]
+[RR: Tool Init()]
+[RR: Running target]
+[main: ----- ----- ----- -----       Meep Meep.      ----- ----- ----- -----]
+[main: ]
+[main: Instrumenting JGFMolDynBenchSizeB (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting harness/Callback (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+[main: Creating Free List With 16 Tids]
+[main: New Thread main with tid=0.]
+The no of threads has not been specified, defaulting to 1
+  
+[main: Instrumenting jgfutil/JGFInstrumentor (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+Java Grande Forum Thread Benchmark Suite - Version 1.0 - Section 3 - Size B
+Executing on 1 thread
+
+===== Java Grande starting =====
+[main: Instrumenting moldyn/JGFMolDynBench (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting jgfutil/JGFSection3 (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting moldyn/md (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+  [main: Replace java/lang/Thread.start()V]
+  [main: Replace java/lang/Thread.join()V]
+[main: Instrumenting moldyn/Barrier (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+  [main: Fixing Potential Orphan moldyn/Barrier.__$rr___$rr_DoBarrier__$rr__Original___$rr__with_ThreadState_(ILrr/state/ShadowThread;)V]
+  [main: Fixing Potential Orphan moldyn/Barrier.__$rr_DoBarrier__$rr__with_ThreadState_(ILrr/state/ShadowThread;)V]
+[main: Instrumenting moldyn/TournamentBarrier (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting jgfutil/JGFTimer (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.size I@jgfutil/JGFTimer.java:31
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.name Ljava/lang/String;@jgfutil/JGFTimer.java:43
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/JGFMolDynBench.JGFrun(I)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.size I@jgfutil/JGFTimer.java:31
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.name Ljava/lang/String;@jgfutil/JGFTimer.java:43
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFTimer.reset()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.time D@jgfutil/JGFTimer.java:78
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.calls J@jgfutil/JGFTimer.java:79
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.size I@jgfutil/JGFTimer.java:31
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.name Ljava/lang/String;@jgfutil/JGFTimer.java:43
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFTimer.reset()V
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.time D@jgfutil/JGFTimer.java:78
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.calls J@jgfutil/JGFTimer.java:79
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/md.initialise()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_moldyn/md.mm I@moldyn/md.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: wr_moldyn/md.PARTSIZE I@moldyn/md.java:59
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/JGFMolDynBench.JGFinitialise()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_moldyn/md.mm I@moldyn/md.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: wr_moldyn/md.PARTSIZE I@moldyn/md.java:59
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/md.runiters()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_moldyn/md.epot [D@moldyn/md.java:68
+##    Commit Stack: <no stack>
+##     Error Cause: wr_moldyn/md.vir [D@moldyn/md.java:69
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/JGFMolDynBench.JGFapplication()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_moldyn/md.epot [D@moldyn/md.java:68
+##    Commit Stack: <no stack>
+##     Error Cause: wr_moldyn/md.vir [D@moldyn/md.java:69
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+[main: Instrumenting moldyn/mdRunner (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting moldyn/particle (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting moldyn/random (Loader=0x002A5330 (class rr.RRMain$RRMainLoader))]
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: moldyn/TournamentBarrier.DoBarrier(I)V
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_moldyn/TournamentBarrier.IsDone [Z@moldyn/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_moldyn/Barrier.numThreads I@moldyn/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+Section3:MolDyn:Run:SizeB	21.291 (s) 	 1265884.9	 (Interactions/s)
+Section3:MolDyn:Total:SizeB	21.754 (s) 	 0.04596856	 (Solutions/s)
+===== Java Grande PASSED in 21841 msec =====
+[main: ]
+[main: ----- ----- ----- -----      Thpthpthpth.     ----- ----- ----- -----]
+[RR: 22.2 sec]
+[RR: Total Time: 22191]
+[RR: Tool Fini()]
+<entry>
+  <data> Mon Sep 24 17:28:47 EDT 2012 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> JGFMolDynBenchSizeB  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> /home/biswass/benchmarks/javaGrande:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-279.5.2.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/workspace/benchmarks/javaGrande/classes </value> 
+    <memPeak> 101 </memPeak> 
+    <memUsed> 32 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 2442 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 7 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 26 </time> </gc>
+  </system>
+  <instrumented> JGFMolDynBenchSizeB harness/Callback jgfutil/JGFInstrumentor jgfutil/JGFSection3 jgfutil/JGFTimer moldyn/Barrier moldyn/JGFMolDynBench moldyn/TournamentBarrier moldyn/md moldyn/mdRunner moldyn/particle moldyn/random  </instrumented> 
+  <instrumentedNum> 12 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 1 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 0 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "ShadowVolatile: objects" </name>                    <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>201.000</total> <count>12</count> <ave>16.7500</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 1 </threadCount> 
+  <errorTotal> 109 </errorTotal> 
+  <distinctErrorTotal> 8 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> moldyn/TournamentBarrier.DoBarrier(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFTimer.reset()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/JGFMolDynBench.JGFrun(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/md.initialise()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/JGFMolDynBench.JGFapplication()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/md.runiters()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> moldyn/JGFMolDynBench.JGFinitialise()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 109 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 22191 </time> 
+</entry>
+[RR: Time = 22191]
+[RR: Exiting: 0]
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/montecarloAlog.xml workspace/velodrome-sound/velodrome/atomizer_logs/montecarloAlog.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/montecarloAlog.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/montecarloAlog.xml	2014-04-03 17:43:56.639715290 -0400
@@ -0,0 +1,200 @@
+<entry>
+  <data> Sat Sep 01 12:11:06 EDT 2012 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> JGFMonteCarloBenchSizeA  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> :/home/biswass/benchmarks/javaGrande:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-279.5.2.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/workspace/benchmarks/javaGrande/classes </value> 
+    <memPeak> 417 </memPeak> 
+    <memUsed> 102 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 3684 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 112 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 54 </time> </gc>
+  </system>
+  <instrumented> JGFMonteCarloBenchSizeA harness/Callback jgfutil/JGFInstrumentor jgfutil/JGFSection3 jgfutil/JGFTimer montecarlo/AppDemo montecarlo/AppDemoThread montecarlo/CallAppDemo montecarlo/DemoException montecarlo/JGFMonteCarloBench montecarlo/MonteCarloPath montecarlo/PathId montecarlo/PriceStock montecarlo/RatePath montecarlo/ReturnPath montecarlo/ToInitAllTasks montecarlo/ToResult montecarlo/ToTask montecarlo/Universal montecarlo/Utilities  </instrumented> 
+  <instrumentedNum> 20 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 1 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 0 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>291.000</total> <count>20</count> <ave>14.5500</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 1 </threadCount> 
+  <errorTotal> 316 </errorTotal> 
+  <distinctErrorTotal> 17 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> montecarlo/PriceStock.setInitAllTasks(Ljava/lang/Object;)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/AppDemo.initTasks(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/AppDemo.processSerial()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFTimer.reset()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/JGFMonteCarloBench.JGFrun(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/JGFMonteCarloBench.JGFapplication()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/JGFMonteCarloBench.JGFinitialise()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/AppDemo.processResults()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/RatePath.readRatesFile(Ljava/lang/String;Ljava/lang/String;)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/CallAppDemo.initialise()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/CallAppDemo.runiters()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/AppDemo.runThread()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/PriceStock.getResult()Ljava/lang/Object;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/CallAppDemo.presults()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/AppDemo.initSerial()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> montecarlo/RatePath.getReturnCompounded()Lmontecarlo/ReturnPath;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 316 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 3774 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/philo.xml workspace/velodrome-sound/velodrome/atomizer_logs/philo.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/philo.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/philo.xml	2014-04-03 17:43:56.634715275 -0400
@@ -0,0 +1,136 @@
+<entry>
+  <data> Mon Mar 04 12:40:11 EST 2013 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> Philo -xml  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> .:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-358.0.1.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe </value> 
+    <memPeak> 87 </memPeak> 
+    <memUsed> 27 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 1080 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 12 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 361 </time> </gc>
+  </system>
+  <instrumented> Philo Table  </instrumented> 
+  <instrumentedNum> 2 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 6 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 5 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>25.0000</total> <count>2</count> <ave>12.5000</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 6 </threadCount> 
+  <errorTotal> 5 </errorTotal> 
+  <distinctErrorTotal> 1 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> Table.getForks(I)I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 5 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 5 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 3691 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/raytracerAlog.xml workspace/velodrome-sound/velodrome/atomizer_logs/raytracerAlog.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/raytracerAlog.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/raytracerAlog.xml	2014-04-03 17:43:56.637715284 -0400
@@ -0,0 +1,226 @@
+<entry>
+  <data> Sat Sep 01 12:26:09 EDT 2012 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> JGFRayTracerBenchSizeA  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> :/home/biswass/benchmarks/javaGrande:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-279.5.2.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/workspace/benchmarks/javaGrande/classes </value> 
+    <memPeak> 297 </memPeak> 
+    <memUsed> 17 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 2635 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 58 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 24 </time> </gc>
+  </system>
+  <instrumented> JGFRayTracerBenchSizeA harness/Callback jgfutil/JGFInstrumentor jgfutil/JGFSection3 jgfutil/JGFTimer raytracer/Barrier raytracer/Interval raytracer/Isect raytracer/JGFRayTracerBench raytracer/Light raytracer/Primitive raytracer/Ray raytracer/RayTracer raytracer/RayTracerRunner raytracer/Scene raytracer/Sphere raytracer/Surface raytracer/TournamentBarrier raytracer/Vec raytracer/View  </instrumented> 
+  <instrumentedNum> 20 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 1 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 0 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "ShadowVolatile: objects" </name>                    <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>235.000</total> <count>20</count> <ave>11.7500</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 1 </threadCount> 
+  <errorTotal> 1180 </errorTotal> 
+  <distinctErrorTotal> 23 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> raytracer/JGFRayTracerBench.JGFinitialise()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFTimer.reset()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 3 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/JGFRayTracerBench.JGFapplication()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.setScene(Lraytracer/Scene;)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 3 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.createScene()Lraytracer/Scene;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/Ray.point(D)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/Vec.cross(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/JGFRayTracerBench.JGFtidyup()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/Primitive.setColor(DDD)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 64 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/TournamentBarrier.DoBarrier(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 2 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.render(Lraytracer/Interval;)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/JGFRayTracerBench.JGFrun(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 1 </count> </error>
+    </method>
+    <method>
+      <name> raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 1180 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 19462 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/raytracerlog.txt workspace/velodrome-sound/velodrome/atomizer_logs/raytracerlog.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/raytracerlog.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/raytracerlog.txt	2014-04-03 17:43:56.637715284 -0400
@@ -0,0 +1,16628 @@
+java version "1.6.0_24"
+OpenJDK Runtime Environment (IcedTea6 1.11.4) (rhel-1.49.1.11.4.el6_3-x86_64)
+OpenJDK 64-Bit Server VM (build 20.0-b12, mixed mode)
+
+[premain: Installling RoadRunner Agent...]
+[main: RoadRunner Agent Loaded.]
+[main: Running in FAST Mode]
+[RR: Creating Fresh Meta Data]
+[RR: Creating Tool Chain]
+  [RR: Creating tool loader with path [file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple/, file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools/]]
+  [RR: file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple/rrtools.properties]
+    [RR: [LOG, T, TL, S, P, N, C]]
+  [RR: 0.00200 sec]
+  [RR: file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools/rrtools.properties]
+    [RR: [HB, FT, A, LS, RS, FT_CAS, PL, BE]]
+  [RR: 0.00 sec]
+  [RR: Extending States for tools/atomizer/AtomizerTool]
+  [RR: 0.00100 sec]
+  [RR: Transforming rr/state/ShadowThread]
+  [RR: done]
+  [RR: Transforming tools/atomizer/AtomizerTool]
+  [RR: done]
+  [RR:     complete chain: tools.atomizer.AtomizerTool -> Last]
+  [RR:        enter chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:         exit chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:      acquire chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:      release chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:       access chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR: Read Fastpath code found in [Last]]
+  [RR: Write Fastpath code found in [Last]]
+[RR: 0.0290 sec]
+[RR: OPTIONS:]
+  [RR: (rr.state.agent.ThreadStateExtensionAgent) javaArgs             = JGFRayTracerBenchSizeB ]
+  [RR: (rr.state.agent.ThreadStateExtensionAgent) noDecInline          = false               ]
+  [RR: (acme.util.Util)                   quiet                = false               ]
+  [RR: (acme.util.Util)                   logs                 = log                 ]
+  [RR: (acme.util.Util)                   out                  =                     ]
+  [RR: (acme.util.Util)                   err                  =                     ]
+  [RR: (rr.RRMain)                        noinst               = false               ]
+  [RR: (rr.RRMain)                        inst                 = INST                ]
+  [RR: (rr.RRMain)                        infThreads           = 0                   ]
+  [RR: (rr.RRMain)                        args                 = []                  ]
+  [RR: (acme.util.Debug)                  d                    = []                  ]
+  [RR: (rr.RRMain$4)                      help                 = false               ]
+  [RR: (rr.tool.RR)                       toolpath             = /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools]
+  [RR: (rr.tool.RR)                       classpath            = .                   ]
+  [RR: (rr.tool.RR)                       tool                 = A                   ]
+  [RR: (rr.tool.RR)                       tools                = false               ]
+  [RR: (rr.tool.RR)                       noxml                = false               ]
+  [RR: (rr.tool.RR)                       constantGC           = false               ]
+  [RR: (rr.tool.RR)                       noFP                 = false               ]
+  [RR: (rr.tool.RR)                       noEnter              = false               ]
+  [RR: (rr.tool.RR)                       xml                  = log.xml             ]
+  [RR: (rr.tool.RR)                       pulse                =                     ]
+  [RR: (rr.tool.RR)                       maxTime              = 0                   ]
+  [RR: (rr.tool.RR)                       maxMem               = 10240               ]
+  [RR: (rr.tool.RR)                       maxTid               = 16                  ]
+  [RR: (rr.tool.RR)                       stacks               = false               ]
+  [RR: (rr.tool.RR)                       values               = false               ]
+  [RR: (rr.tool.RR)                       noTidGC              = false               ]
+  [RR: (rr.tool.RR)                       noEventReuse         = false               ]
+  [RR: (rr.loader.LoaderContext)          repository           =                     ]
+  [RR: (rr.meta.MetaDataInfoMaps)         meta                 = null                ]
+  [RR: (rr.meta.InstrumentationFilter)    methods              = [default=ACCEPT]    ]
+  [RR: (rr.meta.InstrumentationFilter)    fields               = ["-.*this\$.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    lines                = [default=ACCEPT]    ]
+  [RR: (rr.meta.InstrumentationFilter)    classes              = ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    shadowThread         = ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    noop                 = [default=ACCEPT]    ]
+  [RR: (rr.instrument.classes.ThreadDataThunkInserter) noConstructor        = false               ]
+  [RR: (rr.instrument.classes.CloneFixer) noClone              = false               ]
+  [RR: (rr.instrument.Instrumentor)       dump                 =                     ]
+  [RR: (rr.instrument.Instrumentor)       field                = FINE                ]
+  [RR: (rr.instrument.Instrumentor)       fancy                = false               ]
+  [RR: (rr.instrument.Instrumentor)       arraySites           = false               ]
+  [RR: (rr.instrument.Instrumentor)       Use TestAcquires     = false               ]
+  [RR: (rr.tool.RREventGenerator)         nojoin               = false               ]
+  [RR: (rr.tool.RREventGenerator)         multiLoader          = false               ]
+  [RR: (rr.tool.RREventGenerator)         indices              = 2147483647          ]
+  [RR: (rr.state.update.Updaters)         updaters             = SAFE                ]
+  [RR: (rr.state.ArrayStateFactory)       array                = NONE                ]
+  [RR: (rr.barrier.BarrierMonitor)        nobarrier            = false               ]
+  [RR: (rr.state.AbstractArrayStateCache) noArrayLookupOpt     = false               ]
+  [RR: (rr.instrument.methods.ThreadDataInstructionAdapter) callSites            = false               ]
+  [RR: (rr.error.ErrorMessage)            maxWarn              = 100                 ]
+  [RR: (tools.atomizer.AtomizerTool)      noProtLocks          = false               ]
+  [RR: (rr.simple.MethodMonitoringTool)   atomics              = ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT]]
+[RR: 0.00700 sec]
+[RR: Installing DefineClassListener rr.loader.InstrumentingDefineClassLoader@6016a786]
+[RR: System Class Path = [file:/home/biswass/workspace/benchmarks/javaGrande/classes/./]]
+[RR: Tool Init()]
+[RR: Running target]
+[main: ----- ----- ----- -----       Meep Meep.      ----- ----- ----- -----]
+[main: ]
+[main: Instrumenting JGFRayTracerBenchSizeB (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting harness/Callback (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Creating Free List With 16 Tids]
+[main: New Thread main with tid=0.]
+The no of threads has not been specified, defaulting to 1
+  
+[main: Instrumenting jgfutil/JGFInstrumentor (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+Java Grande Forum Thread Benchmark Suite - Version 1.0 - Section 3 - Size B
+Executing on 1 thread
+
+===== Java Grande starting =====
+[main: Instrumenting raytracer/JGFRayTracerBench (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+  [main: Replace java/lang/Thread.start()V]
+  [main: Replace java/lang/Thread.join()V]
+[main: Instrumenting jgfutil/JGFSection3 (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/RayTracer (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/Primitive (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr___$rr_normal__$rr__Original___$rr__with_ThreadState_(Lraytracer/Vec;Lrr/state/ShadowThread;)Lraytracer/Vec;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr_normal__$rr__with_ThreadState_(Lraytracer/Vec;Lrr/state/ShadowThread;)Lraytracer/Vec;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr___$rr_intersect__$rr__Original___$rr__with_ThreadState_(Lraytracer/Ray;Lrr/state/ShadowThread;)Lraytracer/Isect;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr_intersect__$rr__with_ThreadState_(Lraytracer/Ray;Lrr/state/ShadowThread;)Lraytracer/Isect;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr___$rr_toString__$rr__Original___$rr__with_ThreadState_(Lrr/state/ShadowThread;)Ljava/lang/String;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr_toString__$rr__with_ThreadState_(Lrr/state/ShadowThread;)Ljava/lang/String;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr___$rr_getCenter__$rr__Original___$rr__with_ThreadState_(Lrr/state/ShadowThread;)Lraytracer/Vec;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr_getCenter__$rr__with_ThreadState_(Lrr/state/ShadowThread;)Lraytracer/Vec;]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr___$rr_setCenter__$rr__Original___$rr__with_ThreadState_(Lraytracer/Vec;Lrr/state/ShadowThread;)V]
+  [main: Fixing Potential Orphan raytracer/Primitive.__$rr_setCenter__$rr__with_ThreadState_(Lraytracer/Vec;Lrr/state/ShadowThread;)V]
+[main: Instrumenting raytracer/Sphere (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/Barrier (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+  [main: Fixing Potential Orphan raytracer/Barrier.__$rr___$rr_DoBarrier__$rr__Original___$rr__with_ThreadState_(ILrr/state/ShadowThread;)V]
+  [main: Fixing Potential Orphan raytracer/Barrier.__$rr_DoBarrier__$rr__with_ThreadState_(ILrr/state/ShadowThread;)V]
+[main: Instrumenting raytracer/TournamentBarrier (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/Vec (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/Ray (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/Isect (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting jgfutil/JGFTimer (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.size I@jgfutil/JGFTimer.java:31
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.name Ljava/lang/String;@jgfutil/JGFTimer.java:43
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/JGFRayTracerBench.JGFrun(I)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.size I@jgfutil/JGFTimer.java:31
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.name Ljava/lang/String;@jgfutil/JGFTimer.java:43
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFTimer.reset()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.time D@jgfutil/JGFTimer.java:78
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.calls J@jgfutil/JGFTimer.java:79
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.size I@jgfutil/JGFTimer.java:31
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.name Ljava/lang/String;@jgfutil/JGFTimer.java:43
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFTimer.reset()V
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.time D@jgfutil/JGFTimer.java:78
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.calls J@jgfutil/JGFTimer.java:79
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFInstrumentor.addTimer(Ljava/lang/String;Ljava/lang/String;I)V
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.size I@jgfutil/JGFTimer.java:31
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.name Ljava/lang/String;@jgfutil/JGFTimer.java:43
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: jgfutil/JGFTimer.reset()V
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_jgfutil/JGFTimer.time D@jgfutil/JGFTimer.java:78
+##    Commit Stack: <no stack>
+##     Error Cause: wr_jgfutil/JGFTimer.calls J@jgfutil/JGFTimer.java:79
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/JGFRayTracerBench.JGFinitialise()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/RayTracer.height I@raytracer/JGFRayTracerBench.java:45
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/RayTracer.width I@raytracer/JGFRayTracerBench.java:45
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/JGFRayTracerBench.JGFapplication()V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Barrier.numThreads I@raytracer/Barrier.java:29
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/TournamentBarrier.maxBusyIter I@raytracer/TournamentBarrier.java:94
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+[main: Instrumenting raytracer/RayTracerRunner (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/Scene (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.createScene()Lraytracer/Scene;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+[main: Instrumenting raytracer/Surface (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Primitive.setColor(DDD)V
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+[main: Instrumenting raytracer/Light (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Instrumenting raytracer/View (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.setScene(Lraytracer/Scene;)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/RayTracer.lights [Lraytracer/Light;@raytracer/RayTracer.java:163
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/RayTracer.prim [Lraytracer/Primitive;@raytracer/RayTracer.java:164
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+[main: Instrumenting raytracer/Interval (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/TournamentBarrier.DoBarrier(I)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: rd_raytracer/TournamentBarrier.IsDone [Z@raytracer/TournamentBarrier.java:58
+##    Commit Stack: <no stack>
+##     Error Cause: rd_raytracer/Barrier.numThreads I@raytracer/TournamentBarrier.java:60
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.render(Lraytracer/Interval;)V
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.cross(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.comb(DLraytracer/Vec;DLraytracer/Vec;)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 1    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 2    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 3    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 4    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 5    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 6    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 7    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 8    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 9    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 10    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 11    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 12    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 13    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 14    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 15    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.intersect(Lraytracer/Ray;)Lraytracer/Isect;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 16    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 17    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 18    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 19    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 20    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 21    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 22    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 23    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 24    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 25    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.intersect(Lraytracer/Ray;D)Z
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 26    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 27    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 28    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 29    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.Shadow(Lraytracer/Ray;D)I
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 30    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 31    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 32    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 33    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 34    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 35    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 36    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 37    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 38    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 39    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 40    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 41    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 42    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 43    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 44    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 45    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 46    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 47    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 48    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.SpecularDirection(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 49    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 50    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 51    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 52    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 53    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 54    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 55    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 56    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 57    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.trace(IDLraytracer/Ray;)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Isect.t D@raytracer/Sphere.java:56
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Isect.enter I@raytracer/Sphere.java:57
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 58    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 59    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 60    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 61    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 62    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 63    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 64    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 65    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 66    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 67    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 68    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 69    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 70    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 71    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 72    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 73    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 74    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 75    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 76    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 77    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 78    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 79    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 80    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 81    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 82    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 83    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 84    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 85    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 86    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 87    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 88    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 89    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 90    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 91    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 92    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 93    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Vec.sub(Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 94    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 95    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Ray.point(D)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/Sphere.normal(Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.shade(IDLraytracer/Vec;Lraytracer/Vec;Lraytracer/Vec;Lraytracer/Isect;)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:72
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:73
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 96    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 97    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 98    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 99    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
+## 
+## =====================================================================
+## Atomicity Error
+## 
+##          Thread: 0    
+##           Blame: raytracer/RayTracer.TransDir(Lraytracer/Surface;Lraytracer/Surface;Lraytracer/Vec;Lraytracer/Vec;)Lraytracer/Vec;
+##           Count: 100    (max: 100)
+##     Enter Stack: <no stack>
+##    Commit Cause: wr_raytracer/Vec.x D@raytracer/Vec.java:55
+##    Commit Stack: <no stack>
+##     Error Cause: wr_raytracer/Vec.y D@raytracer/Vec.java:56
+##     Error Stack: <no stack>
+## =====================================================================
+## 
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/sor.xml workspace/velodrome-sound/velodrome/atomizer_logs/sor.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/sor.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/sor.xml	2014-04-03 17:43:56.639715290 -0400
@@ -0,0 +1,140 @@
+<entry>
+  <data> Mon Mar 04 12:03:22 EST 2013 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> sor.Sor 50 2 -xml  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> .:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-358.0.1.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe </value> 
+    <memPeak> 79 </memPeak> 
+    <memUsed> 44 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 1109 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 6 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 22 </time> </gc>
+  </system>
+  <instrumented> EDU/oswego/cs/dl/util/concurrent/Barrier EDU/oswego/cs/dl/util/concurrent/BrokenBarrierException EDU/oswego/cs/dl/util/concurrent/CyclicBarrier EDU/oswego/cs/dl/util/concurrent/TimeoutException sor/Sor sor/sor_first_row_odd  </instrumented> 
+  <instrumentedNum> 6 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 3 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 2 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>45.0000</total> <count>6</count> <ave>7.50000</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 3 </threadCount> 
+  <errorTotal> 200 </errorTotal> 
+  <distinctErrorTotal> 2 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> EDU/oswego/cs/dl/util/concurrent/CyclicBarrier.doBarrier(ZJ)I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> EDU/oswego/cs/dl/util/concurrent/CyclicBarrier.barrier()I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 200 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 613 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/ThreadDemo6log.txt workspace/velodrome-sound/velodrome/atomizer_logs/ThreadDemo6log.txt
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/ThreadDemo6log.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/ThreadDemo6log.txt	2014-04-03 17:43:56.638715287 -0400
@@ -0,0 +1,256 @@
+java version "1.6.0_24"
+OpenJDK Runtime Environment (IcedTea6 1.11.4) (rhel-1.49.1.11.4.el6_3-x86_64)
+OpenJDK 64-Bit Server VM (build 20.0-b12, mixed mode)
+
+[premain: Installling RoadRunner Agent...]
+[main: RoadRunner Agent Loaded.]
+[main: Running in FAST Mode]
+[RR: Creating Fresh Meta Data]
+[RR: Creating Tool Chain]
+  [RR: Creating tool loader with path [file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple/, file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools/]]
+  [RR: file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple/rrtools.properties]
+    [RR: [LOG, T, TL, S, P, N, C]]
+  [RR: 0.00100 sec]
+  [RR: file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools/rrtools.properties]
+    [RR: [HB, FT, A, LS, RS, FT_CAS, PL, BE]]
+  [RR: 0.00 sec]
+  [RR: Extending States for tools/atomizer/AtomizerTool]
+  [RR: 0.00100 sec]
+  [RR: Transforming rr/state/ShadowThread]
+  [RR: done]
+  [RR: Transforming tools/atomizer/AtomizerTool]
+  [RR: done]
+  [RR:     complete chain: tools.atomizer.AtomizerTool -> Last]
+  [RR:        enter chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:         exit chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:      acquire chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:      release chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR:       access chain: [tools.atomizer.AtomizerTool, Last]]
+  [RR: Read Fastpath code found in [Last]]
+  [RR: Write Fastpath code found in [Last]]
+[RR: 0.0290 sec]
+[RR: OPTIONS:]
+  [RR: (rr.state.agent.ThreadStateExtensionAgent) javaArgs             = atomicity.ThreadDemo6 ]
+  [RR: (rr.state.agent.ThreadStateExtensionAgent) noDecInline          = false               ]
+  [RR: (acme.util.Util)                   quiet                = false               ]
+  [RR: (acme.util.Util)                   logs                 = log                 ]
+  [RR: (acme.util.Util)                   out                  =                     ]
+  [RR: (acme.util.Util)                   err                  =                     ]
+  [RR: (rr.RRMain)                        noinst               = false               ]
+  [RR: (rr.RRMain)                        inst                 = INST                ]
+  [RR: (rr.RRMain)                        infThreads           = 0                   ]
+  [RR: (rr.RRMain)                        args                 = []                  ]
+  [RR: (acme.util.Debug)                  d                    = []                  ]
+  [RR: (rr.RRMain$4)                      help                 = false               ]
+  [RR: (rr.tool.RR)                       toolpath             = /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools]
+  [RR: (rr.tool.RR)                       classpath            = .                   ]
+  [RR: (rr.tool.RR)                       tool                 = A                   ]
+  [RR: (rr.tool.RR)                       tools                = false               ]
+  [RR: (rr.tool.RR)                       noxml                = false               ]
+  [RR: (rr.tool.RR)                       constantGC           = false               ]
+  [RR: (rr.tool.RR)                       noFP                 = false               ]
+  [RR: (rr.tool.RR)                       noEnter              = false               ]
+  [RR: (rr.tool.RR)                       xml                  = log.xml             ]
+  [RR: (rr.tool.RR)                       pulse                =                     ]
+  [RR: (rr.tool.RR)                       maxTime              = 0                   ]
+  [RR: (rr.tool.RR)                       maxMem               = 10240               ]
+  [RR: (rr.tool.RR)                       maxTid               = 16                  ]
+  [RR: (rr.tool.RR)                       stacks               = false               ]
+  [RR: (rr.tool.RR)                       values               = false               ]
+  [RR: (rr.tool.RR)                       noTidGC              = false               ]
+  [RR: (rr.tool.RR)                       noEventReuse         = false               ]
+  [RR: (rr.loader.LoaderContext)          repository           =                     ]
+  [RR: (rr.meta.MetaDataInfoMaps)         meta                 = null                ]
+  [RR: (rr.meta.InstrumentationFilter)    methods              = [default=ACCEPT]    ]
+  [RR: (rr.meta.InstrumentationFilter)    fields               = ["-.*this\$.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    lines                = [default=ACCEPT]    ]
+  [RR: (rr.meta.InstrumentationFilter)    classes              = ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    shadowThread         = ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT]]
+  [RR: (rr.meta.InstrumentationFilter)    noop                 = [default=ACCEPT]    ]
+  [RR: (rr.instrument.classes.ThreadDataThunkInserter) noConstructor        = false               ]
+  [RR: (rr.instrument.classes.CloneFixer) noClone              = false               ]
+  [RR: (rr.instrument.Instrumentor)       dump                 =                     ]
+  [RR: (rr.instrument.Instrumentor)       field                = FINE                ]
+  [RR: (rr.instrument.Instrumentor)       fancy                = false               ]
+  [RR: (rr.instrument.Instrumentor)       arraySites           = false               ]
+  [RR: (rr.instrument.Instrumentor)       Use TestAcquires     = false               ]
+  [RR: (rr.tool.RREventGenerator)         nojoin               = false               ]
+  [RR: (rr.tool.RREventGenerator)         multiLoader          = false               ]
+  [RR: (rr.tool.RREventGenerator)         indices              = 2147483647          ]
+  [RR: (rr.state.update.Updaters)         updaters             = SAFE                ]
+  [RR: (rr.state.ArrayStateFactory)       array                = NONE                ]
+  [RR: (rr.barrier.BarrierMonitor)        nobarrier            = false               ]
+  [RR: (rr.state.AbstractArrayStateCache) noArrayLookupOpt     = false               ]
+  [RR: (rr.instrument.methods.ThreadDataInstructionAdapter) callSites            = false               ]
+  [RR: (rr.error.ErrorMessage)            maxWarn              = 100                 ]
+  [RR: (tools.atomizer.AtomizerTool)      noProtLocks          = false               ]
+  [RR: (rr.simple.MethodMonitoringTool)   atomics              = ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT]]
+[RR: 0.00700 sec]
+[RR: Installing DefineClassListener rr.loader.InstrumentingDefineClassLoader@77df38fd]
+[RR: System Class Path = [file:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/./]]
+[RR: Tool Init()]
+[RR: Running target]
+[main: ----- ----- ----- -----       Meep Meep.      ----- ----- ----- -----]
+[main: ]
+[main: Instrumenting atomicity/ThreadDemo6 (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: Creating Free List With 16 Tids]
+[main: New Thread main with tid=0.]
+ThreadDemo6 started
+[main: Instrumenting atomicity/NewThread6 (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+  [main: Replace java/lang/Thread.start()V]
+[main: Instrumenting atomicity/MyObject4 (Loader=0x48D6C16C (class rr.RRMain$RRMainLoader))]
+[main: New Thread First Thread with tid=1.]
+Thread 1 writing to obj for the first time
+[main: New Thread Second Thread with tid=2.]
+Thread 2 writing to obj for the first time
+[main: New Thread Third Thread with tid=3.]
+Thread 3 writing to obj for the first time
+[RR Waiter for 3: Stopping]
+[main: New Thread Fourth Thread with tid=3.]
+Thread 4 writing to obj for the first time
+[RR Waiter for 3: Stopping]
+[RR Waiter for 2: Stopping]
+[main: ]
+[main: ----- ----- ----- -----      Thpthpthpth.     ----- ----- ----- -----]
+  [RR: Waiting for Thread Count to reach 0.  Current Count: 1]
+  [RR: Waiting for Thread Count to reach 0.  Current Count: 1]
+  [RR: Waiting for Thread Count to reach 0.  Current Count: 1]
+  [RR: Waiting for Thread Count to reach 0.  Current Count: 1]
+Thread 1 writing to obj for the second time
+  [RR: Waiting for Thread Count to reach 0.  Current Count: 1]
+  [RR: Waiting for Thread Count to reach 0.  Current Count: 1]
+[RR Waiter for 1: Stopping]
+[RR: 12.8 sec]
+[RR: Total Time: 6808]
+[RR: Tool Fini()]
+<entry>
+  <data> Mon Sep 24 12:08:11 EDT 2012 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> atomicity.ThreadDemo6  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> :/home/biswass/benchmarks/javaGrande:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-279.5.2.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe </value> 
+    <memPeak> 104 </memPeak> 
+    <memUsed> 96 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 783 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 0 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 0 </time> </gc>
+  </system>
+  <instrumented> atomicity/MyObject4 atomicity/NewThread6 atomicity/ThreadDemo6  </instrumented> 
+  <instrumentedNum> 3 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 5 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 3 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>20.0000</total> <count>3</count> <ave>6.66667</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 5 </threadCount> 
+  <errorTotal> 0 </errorTotal> 
+  <distinctErrorTotal> 0 </distinctErrorTotal> 
+  <methods>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 6808 </time> 
+</entry>
+[RR: Time = 6808]
+[RR: Exiting: 0]
diff -rupN workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/tsp.xml workspace/velodrome-sound/velodrome/atomizer_logs/tsp.xml
--- workspace/jikesrvm-3.1.3/velodrome/atomizer_logs/tsp.xml	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/atomizer_logs/tsp.xml	2014-04-03 17:43:56.640715293 -0400
@@ -0,0 +1,164 @@
+<entry>
+  <data> Mon Mar 04 12:01:02 EST 2013 </data> 
+  <mode> FAST </mode> 
+  <timeout> NO </timeout> 
+  <options>
+    <option><name> javaArgs </name>           <value> Tsp tspfiles/map16c 8 -xml  </value> </option>
+    <option><name> noDecInline </name>        <value> false </value> </option>
+    <option><name> quiet </name>              <value> false </value> </option>
+    <option><name> logs </name>               <value> log </value> </option>
+    <option><name> out </name>                <value>  </value>   </option>
+    <option><name> err </name>                <value>  </value>   </option>
+    <option><name> noinst </name>             <value> false </value> </option>
+    <option><name> inst </name>               <value> INST </value> </option>
+    <option><name> infThreads </name>         <value> 0 </value>  </option>
+    <option><name> args </name>               <value> [] </value> </option>
+    <option><name> d </name>                  <value> [] </value> </option>
+    <option><name> help </name>               <value> false </value> </option>
+    <option><name> toolpath </name>           <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/rr/simple:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/classes/tools </value> </option>
+    <option><name> classpath </name>          <value> . </value>  </option>
+    <option><name> tool </name>               <value> A </value>  </option>
+    <option><name> tools </name>              <value> false </value> </option>
+    <option><name> noxml </name>              <value> false </value> </option>
+    <option><name> constantGC </name>         <value> false </value> </option>
+    <option><name> noFP </name>               <value> false </value> </option>
+    <option><name> noEnter </name>            <value> false </value> </option>
+    <option><name> xml </name>                <value> log.xml </value> </option>
+    <option><name> pulse </name>              <value>  </value>   </option>
+    <option><name> maxTime </name>            <value> 0 </value>  </option>
+    <option><name> maxMem </name>             <value> 10240 </value> </option>
+    <option><name> maxTid </name>             <value> 16 </value> </option>
+    <option><name> stacks </name>             <value> false </value> </option>
+    <option><name> values </name>             <value> false </value> </option>
+    <option><name> noTidGC </name>            <value> false </value> </option>
+    <option><name> noEventReuse </name>       <value> false </value> </option>
+    <option><name> repository </name>         <value>  </value>   </option>
+    <option><name> meta </name>               <value> null </value> </option>
+    <option><name> methods </name>            <value> [default=ACCEPT] </value> </option>
+    <option><name> fields </name>             <value> ["-.*this\$.*", default=ACCEPT] </value> </option>
+    <option><name> lines </name>              <value> [default=ACCEPT] </value> </option>
+    <option><name> classes </name>            <value> ["-java..*", "-javax..*", "-com.sun..*", "-org.objectweb.asm..*", "-sun..*", "-rr..*", "-rrtools..*", "-acme..*", "-.*__\$rr_.*", default=ACCEPT] </value> </option>
+    <option><name> shadowThread </name>       <value> ["-.*main\(\[Ljava/lang/String;\)V.*", "-.*run\(\)V.*", "+.*\$rr__Original.*", "-.*\$rr.*", "-.*\&lt;init\&gt;.*", "-.*\&lt;clinit\&gt;.*", default=ACCEPT] </value> </option>
+    <option><name> noop </name>               <value> [default=ACCEPT] </value> </option>
+    <option><name> noConstructor </name>      <value> false </value> </option>
+    <option><name> noClone </name>            <value> false </value> </option>
+    <option><name> dump </name>               <value>  </value>   </option>
+    <option><name> field </name>              <value> FINE </value> </option>
+    <option><name> fancy </name>              <value> false </value> </option>
+    <option><name> arraySites </name>         <value> false </value> </option>
+    <option><name> Use TestAcquires </name>   <value> false </value> </option>
+    <option><name> nojoin </name>             <value> false </value> </option>
+    <option><name> multiLoader </name>        <value> false </value> </option>
+    <option><name> indices </name>            <value> 2147483647 </value> </option>
+    <option><name> updaters </name>           <value> SAFE </value> </option>
+    <option><name> array </name>              <value> NONE </value> </option>
+    <option><name> nobarrier </name>          <value> false </value> </option>
+    <option><name> noArrayLookupOpt </name>   <value> false </value> </option>
+    <option><name> callSites </name>          <value> false </value> </option>
+    <option><name> maxWarn </name>            <value> 100 </value> </option>
+    <option><name> noProtLocks </name>        <value> false </value> </option>
+    <option><name> atomics </name>            <value> ["-.*main\(\[Ljava/lang/String;\)V", "-.*run\(\)V", default=ACCEPT] </value> </option>
+    <option><name> sanity </name>             <value> false </value> </option>
+    <option><name> noInterrupt </name>        <value> false </value> </option>
+  </options>
+  <system>
+    <host> rain.cse.ohio-state.edu </host> 
+    <name> java.vm.version </name>     <value> 20.0-b12 </value> 
+    <name> java.vm.vendor </name>      <value> Sun Microsystems Inc. </value> 
+    <name> java.vm.name </name>        <value> OpenJDK 64-Bit Server VM </value> 
+    <name> java.class.path </name>     <value> .:/home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe/build/jar/rragent.jar </value> 
+    <name> os.name </name>             <value> Linux </value> 
+    <name> os.arch </name>             <value> amd64 </value> 
+    <name> os.version </name>          <value> 2.6.32-358.0.1.el6.x86_64 </value> 
+    <name> user.name </name>           <value> biswass </value> 
+    <name> user.dir </name>            <value> /home/biswass/Documents/rr/stephenfreund-RoadRunner-5ad3fbe </value> 
+    <memPeak> 98 </memPeak> 
+    <memUsed> 81 </memUsed> 
+    <memMax> 1029 </memMax> 
+    <compileTime> 1201 </compileTime> 
+    <gc> <name> PS Scavenge </name> <time> 8 </time> </gc>
+    <gc> <name> PS MarkSweep </name> <time> 19 </time> </gc>
+  </system>
+  <instrumented> PrioQElement TourElement Tsp TspSolver  </instrumented> 
+  <instrumentedNum> 4 </instrumentedNum> 
+  <skipped>  </skipped> 
+  <skippedNum> 0 </skippedNum> 
+  <sanityChecked>  </sanityChecked> 
+  <sanityCheckedNum> 0 </sanityCheckedNum> 
+  <counters>
+
+    <counter><name> "ArrayStateFactory: Size" </name>                    <value> 0 </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Move Time" </name>         <value> <total>0.00000</total> <count>0</count>  </value> </counter>
+    <counter><name> "ArrayStateFactory: Attic Hits" </name>              <value> 0 </value> </counter>
+
+    <counter><name> "Clone: Count" </name>                               <value> 0 </value> </counter>
+
+    <counter><name> "Handler: Count" </name>                             <value> 0 </value> </counter>
+
+    <counter><name> "ShadowLock: objects" </name>                        <value> 0 </value> </counter>
+
+    <counter><name> "ShadowThread: Count" </name>                        <value> 9 </value> </counter>
+    <counter><name> "ShadowThread: Max Live" </name>                     <value> 8 </value> </counter>
+    <counter><name> "ShadowThread: getCurrentThread() calls" </name>     <value> 0 </value> </counter>
+
+    <counter><name> "Time: Instrumenter" </name>                         <value> <total>61.0000</total> <count>4</count> <ave>15.2500</ave> </value> </counter>
+  </counters>
+  <tool>
+    <name> tools.atomizer.AtomizerTool </name> 
+  </tool>
+  <tool>
+    <name> Last </name> 
+  </tool>
+  <threadCount> 9 </threadCount> 
+  <errorTotal> 349 </errorTotal> 
+  <distinctErrorTotal> 8 </distinctErrorTotal> 
+  <methods>
+    <method>
+      <name> TspSolver.visit_nodes(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 58 </count> </error>
+    </method>
+    <method>
+      <name> TspSolver.calc_bound(I)I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> TspSolver.recursive_solve(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 8 </count> </error>
+    </method>
+    <method>
+      <name> TspSolver.new_tour(II)I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 100 </count> </error>
+    </method>
+    <method>
+      <name> TspSolver.Worker()V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 8 </count> </error>
+    </method>
+    <method>
+      <name> TspSolver.split_tour(I)V(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 31 </count> </error>
+    </method>
+    <method>
+      <name> TspSolver.get_tour(I)I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 22 </count> </error>
+    </method>
+    <method>
+      <name> TspSolver.find_solvable_tour()I(NullLoc) </name> 
+      <error> <name> Atomicity </name> <count> 22 </count> </error>
+    </method>
+  </methods>
+  <fields>
+  </fields>
+  <arrays>
+  </arrays>
+  <locks>
+  </locks>
+  <fieldAccesses>
+  </fieldAccesses>
+  <errorCountPerErrorType>
+    <errorType> <name> Atomicity </name> <count> 349 </count> </errorType>
+  </errorCountPerErrorType>
+  <warningsTotal> 0 </warningsTotal> 
+  <yikesTotal> 0 </yikesTotal> 
+  <failed> false </failed> 
+  <time> 1219 </time> 
+</entry>
diff -rupN workspace/jikesrvm-3.1.3/velodrome/checkForViolations.py workspace/velodrome-sound/velodrome/checkForViolations.py
--- workspace/jikesrvm-3.1.3/velodrome/checkForViolations.py	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/checkForViolations.py	2014-04-03 17:43:57.377717716 -0400
@@ -0,0 +1,41 @@
+#!/usr/bin/python
+
+import sys 
+import os
+
+dir_name = ""
+bench_name = ""
+exp_output_dir = "exp-output"
+
+def parse_arguments():
+    '''Test validity of input arguments'''
+    if len(sys.argv) != 3:
+        print "Wrong number of arguments"
+        print "Usage:python <xxx.py> <directory> <benchmark>"
+        sys.exit(1)
+    global dir_name
+    global bench_name
+    dir_name = sys.argv[1]
+    bench_name = sys.argv[2]    
+
+def change_dir():
+    '''Switch working directory to the one requested by the user'''
+    home = os.path.expanduser("~")
+    path = home + "/" + exp_output_dir + "/" + dir_name + "/" + bench_name
+    if os.path.exists(path) == False:
+        print "Invalid path"
+        sys.exit(1)
+    if os.path.isdir(path) == False:
+        print "Invalid directory"
+        sys.exit(1)
+    os.chdir(path)
+
+def main():
+    print 'Hello world!'
+    parse_arguments()
+    change_dir()
+    # Current working directory should now correspond to the 
+    # given benchmark
+
+if __name__ == '__main__':
+    main()
diff -rupN workspace/jikesrvm-3.1.3/velodrome/correctness_experiment.sh workspace/velodrome-sound/velodrome/correctness_experiment.sh
--- workspace/jikesrvm-3.1.3/velodrome/correctness_experiment.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/correctness_experiment.sh	2014-04-03 17:43:57.494718100 -0400
@@ -0,0 +1,18 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+VELODROME_DIR=$DATE"_velodrome_correctness"
+DCHECKER_DIR=$DATE"_doublechecker_correctness"
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <local | remote>"
+    exit 1
+fi
+
+DOEXP="doexp-"$1
+
+cd /home/biswass
+
+$DOEXP --project=velodrome --buildPrefix=FullAdaptive --workloadSize=small --config=BaseConfig,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --trial=10 --timeout=240 --baseName=$VELODROME_DIR
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/dc_batch_correctness.sh workspace/velodrome-sound/velodrome/dc_batch_correctness.sh
--- workspace/jikesrvm-3.1.3/velodrome/dc_batch_correctness.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/dc_batch_correctness.sh	2014-04-03 17:43:57.496718106 -0400
@@ -0,0 +1,98 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+VELODROME_DIR=$DATE"_velodrome_correctness"
+DC_SINGLERUN_DIR=$DATE"_dc_singlerun_correctness_sunshine"
+DC_MULTIRUN_ICD_DIR=$DATE"_dc_multirun_icd_correctness_sunshine"
+DC_MULTIRUN_PCD_DIR=$DATE"_dc_multirun_pcd_correctness_sunshine"
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <local | remote>"
+    exit 1
+fi
+
+DOEXP="doexp-"$1
+USER_PATH="/home/biswass/"
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+
+echo $AVD_PATH
+
+cd $USER_PATH
+
+# First execute DoubleChecker in single-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/branch-clone-application-methods avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+$DOEXP --project=avd --buildPrefix=FullAdaptive --config=BaseConfig,OctetDefault,AVDASTransactionInstrumentation,AVDASSlowPathHooks,AVDASCrossThreadEdge,AVDASCycleDetection,AVDASICD,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=2 --timeout=180 --baseName=$DC_SINGLERUN_DIR --jikesArgs=-X:gc:eagerMmapSpaces=true
+
+#$DOEXP --project=avd --buildPrefix=FullAdaptive --config=AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=1 --retryTrials=true --timeout=180
+
+# Now execute DoubleChecker ICD in multi-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+else 
+    echo "AVD directory should have been present"
+    exit 1
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/multirun-icd-doublechecker avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+$DOEXP --project=avd --buildPrefix=FullAdaptive --config=BaseConfig,OctetDefault,AVDTransactionInstrumentation,AVDSlowPathHooks,AVDCrossThreadEdge,AVDCycleDetection --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=2 --timeout=120 --baseName=$DC_MULTIRUN_ICD_DIR --jikesArgs=-X:gc:eagerMmapSpaces=true
+
+#$DOEXP --project=avd --buildPrefix=FullAdaptive --config=AVDCycleDetection --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=1 --retryTrials=true --timeout=120
+
+# Now execute DoubleChecker PCD in multi-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+else 
+    echo "AVD directory should have been present"
+    exit 1
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/multirun-pcd-doublechecker avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+$DOEXP --project=avd --buildPrefix=FullAdaptive --config=BaseConfig,OctetDefault,AVDTransactionInstrumentation,AVDSlowPathHooks,AVDCrossThreadEdge,AVDCycleDetection,AVDICD,AVDDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=2 --timeout=120 --baseName=$DC_MULTIRUN_PCD_DIR --jikesArgs=-X:gc:eagerMmapSpaces=true
+
+#$DOEXP --project=avd --buildPrefix=FullAdaptive --config=AVDDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=1 --retryTrials=true --timeout=120
+
+# Helper functions
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/dc_batch_performance.sh workspace/velodrome-sound/velodrome/dc_batch_performance.sh
--- workspace/jikesrvm-3.1.3/velodrome/dc_batch_performance.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/dc_batch_performance.sh	2014-04-03 17:43:56.965716361 -0400
@@ -0,0 +1,98 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+VELODROME_DIR=$DATE"_velodrome_performance"
+DC_SINGLERUN_DIR=$DATE"_dc_singlerun_perf_sunshine"
+DC_MULTIRUN_ICD_DIR=$DATE"_dc_multirun_icd_perf_sunshine"
+DC_MULTIRUN_PCD_DIR=$DATE"_dc_multirun_pcd_perf_sunshine"
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <local | remote>"
+    exit 1
+fi
+
+DOEXP="doexp-"$1
+USER_PATH="/home/biswass/"
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+
+echo $AVD_PATH
+
+cd $USER_PATH
+
+# First execute DoubleChecker in single-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/branch-clone-application-methods avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefault,AVDASTransactionInstrumentation,AVDASSlowPathHooks,AVDASCrossThreadEdge,AVDASCycleDetection,AVDASICD,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp,product --workloadSize=small --trial=15 --retryTrials=true --timeout=180 --baseName=$DC_SINGLERUN_DIR --jikesArgs=-X:gc:eagerMmapSpaces=true
+
+#$DOEXP --project=avd --buildPrefix=FullAdaptive --config=AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=1 --retryTrials=true --timeout=180
+
+# Now execute DoubleChecker ICD in multi-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+else 
+    echo "AVD directory should have been present"
+    exit 1
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/multirun-icd-doublechecker avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefault,AVDTransactionInstrumentation,AVDSlowPathHooks,AVDCrossThreadEdge,AVDCycleDetection --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp,product --workloadSize=small --trial=15 --retryTrials=true --timeout=180 --baseName=$DC_MULTIRUN_ICD_DIR --jikesArgs=-X:gc:eagerMmapSpaces=true
+
+#$DOEXP --project=avd --buildPrefix=FullAdaptive --config=AVDCycleDetection --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=1 --retryTrials=true --timeout=120
+
+# Now execute DoubleChecker PCD in multi-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+else 
+    echo "AVD directory should have been present"
+    exit 1
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/multirun-pcd-doublechecker avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefault,AVDTransactionInstrumentation,AVDSlowPathHooks,AVDCrossThreadEdge,AVDCycleDetection,AVDICD,AVDDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp,product --workloadSize=small --trial=15 --retryTrials=true --timeout=180 --baseName=$DC_MULTIRUN_PCD_DIR --jikesArgs=-X:gc:eagerMmapSpaces=true
+
+#$DOEXP --project=avd --buildPrefix=FullAdaptive --config=AVDDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --workloadSize=small --trial=1 --retryTrials=true --timeout=120
+
+# Helper functions
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/dc_velodrome_perf_exp_frost.sh workspace/velodrome-sound/velodrome/dc_velodrome_perf_exp_frost.sh
--- workspace/jikesrvm-3.1.3/velodrome/dc_velodrome_perf_exp_frost.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/dc_velodrome_perf_exp_frost.sh	2014-04-03 17:43:56.964716358 -0400
@@ -0,0 +1,63 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+VDROME_OUT_DIR=$DATE"_velodrome_perf_frost"
+DC_OUT_DIR=$DATE"_dc_perf_frost"
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <local | remote>"
+    exit 1
+fi
+
+DOEXP="doexp-"$1
+USER_PATH="/home/biswass/"
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+VDROME_DIR="velodromeRvmRoot"
+VDROME_PATH=$USER_PATH$VDROME_DIR
+
+cd $USER_PATH
+
+# DoubleChecker
+
+# First execute DoubleChecker in single-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/branch-clone-application-methods avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefault,AVDASCycleDetection,AVDASICD,AVDASDefault --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=25 --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+
+# Velodrome 
+
+# Delete contents of local VDROME directory
+if [ -d "$VDROME_DIR" ]; then 
+    cd $VDROME_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-clone-app-methods velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+$DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASInsertPostBarriers,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,montecarlo,moldyn,,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=25 --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/dot2pdf.sh workspace/velodrome-sound/velodrome/dot2pdf.sh
--- workspace/jikesrvm-3.1.3/velodrome/dot2pdf.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/dot2pdf.sh	2014-04-03 17:43:57.497718109 -0400
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+cd
+for i in `ls *.graph`
+do
+  OUTFILE=$i+".pdf"
+  dot -Tpdf -o $OUTFILE $i
+done
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/avrora9.txt workspace/velodrome-sound/velodrome/exclusion-list/avrora9.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/avrora9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/avrora9.txt	2014-04-03 17:43:56.968716371 -0400
@@ -0,0 +1,42 @@
+# Avrora9
+
+# Trivially left out
+Lavrora/Main;.main ([Ljava/lang/String;)V:100(0)
+Lavrora/sim/SimulatorThread;.run ()V:96(0)
+Lavrora/sim/Simulator;.start ()V:522(9)
+Lavrora/actions/Action;.run ()V:67(0)
+Lavrora/actions/SimAction;.run ([Ljava/lang/String;)V:84(0)
+Lavrora/sim/Simulation;.join ()V:505(0)
+Lavrora/sim/clock/Synchronizer;.join ()V:87(0)
+Lavrora/sim/clock/RippleSynchronizer;.join ()V:221(0)
+
+# Velodrome results
+
+Lavrora/sim/AtmelInterpreter;.start ()V:381(0)
+Lavrora/sim/clock/RippleSynchronizer;.removeNode (Lavrora/sim/Simulation$Node;)V:289(0)
+Lavrora/arch/legacy/LegacyInterpreter;.runLoop ()V:82(0)
+
+# Avrora9 seems to run okay till this point, after that there are several full heap GCs, if Velodrome is implemented
+# using strong references. It can run to completion with a weak references implementation.
+
+Lavrora/sim/AtmelInterpreter;.advanceClock (J)V:522(0)
+Lavrora/arch/legacy/LegacyInterpreter;.fastLoop ()V:251(0)
+Lavrora/arch/legacy/LegacyInterpreter;.sleepLoop ()V:244(0)
+Lavrora/sim/clock/MainClock;.skipAhead ()V:118(-2)
+Lavrora/sim/clock/MainClock;.advance (J)V:100(0)
+Lavrora/sim/clock/DeltaQueue;.advance (J)V:238(0)
+Lavrora/sim/clock/DeltaQueue;.skipAhead ()V:259(-2)
+Lavrora/sim/clock/DeltaQueue;.advanceSlow (J)V:274(0)
+Lavrora/sim/clock/DeltaQueue$Link;.fire ()V:123(-2)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.fireUnlocked (J)V:329(-2)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.fire ()V:311(-2)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.fireLocked (J)V:367(0)
+Lavrora/sim/radio/Medium$Receiver;.access$000 (Lavrora/sim/radio/Medium$Receiver;J)V:260(0)
+Lavrora/sim/radio/Medium$Receiver;.waitForNeighbors (J)V:537(-2)
+Lavrora/sim/clock/RippleSynchronizer;.waitForNeighbors (J)V:307(0)
+Lavrora/sim/clock/RippleSynchronizer;.waitFor (JLavrora/sim/clock/RippleSynchronizer$WaitLink;)V:155(0)
+Lavrora/sim/clock/RippleSynchronizer;.waitForLink (Lavrora/sim/clock/RippleSynchronizer$WaitLink;)V:179(-2)
+Lavrora/sim/radio/Medium$Receiver$Ticker;.deliverByte (J)V:378(0)
+Lavrora/sim/AtmelInterpreter;.commit ()V:1057(-2)
+Lavrora/sim/clock/RippleSynchronizer;.advance (JLavrora/sim/clock/RippleSynchronizer$WaitLink;)Lavrora/sim/clock/RippleSynchronizer$WaitLink;:124(-2)
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/eclipse6.txt workspace/velodrome-sound/velodrome/exclusion-list/eclipse6.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/eclipse6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/eclipse6.txt	2014-04-03 17:43:56.966716364 -0400
@@ -0,0 +1,250 @@
+# Eclipse6 
+
+Ldacapo/eclipse/Main;.main ([Ljava/lang/String;)V:16(0)
+Lorg/eclipse/osgi/framework/eventmgr/EventManager$EventThread;.run ()V:287(0)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager;.run ()V:333(0)
+Lorg/eclipse/debug/internal/core/OutputStreamMonitor$1;.run ()V:0(0) 
+Lorg/eclipse/debug/internal/core/InputStreamMonitor$1;.run ()V:0(0)
+Lorg/eclipse/core/internal/jobs/Worker;.run ()V:0(0)
+Lorg/eclipse/osgi/framework/internal/core/PackageAdminImpl$1;.run ()V:0(0)
+Lorg/eclipse/debug/core/model/RuntimeProcess$ProcessMonitorThread;.run ()V:0(0)
+Lorg/eclipse/core/internal/runtime/PlatformActivator$1;.run ()V:0(0)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager;.run ()V:0(0)
+Lorg/eclipse/osgi/framework/internal/core/SystemBundle$1;.run ()V:0(0)
+Lorg/eclipse/core/internal/jobs/WorkerPool;.sleep (J)V:0(0)
+
+
+# Velodrome results
+
+Lorg/eclipse/osgi/framework/eventmgr/EventManager$EventThread;.getNextEvent ()Lorg/eclipse/osgi/framework/eventmgr/EventManager$EventThread$Queued;:347(0)
+Lorg/eclipse/osgi/framework/internal/core/PackageAdminImpl;.doResolveBundles ([Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;Z)V:160(0)
+Lorg/eclipse/osgi/framework/eventmgr/EventManager;.dispatchEvent ([Lorg/eclipse/osgi/framework/eventmgr/EventListeners$ListElement;Lorg/eclipse/osgi/framework/eventmgr/EventDispatcher;ILjava/lang/Object;)V:181(0)
+Lorg/eclipse/core/internal/jobs/WorkerPool;.startJob (Lorg/eclipse/core/internal/jobs/Worker;)Lorg/eclipse/core/internal/jobs/InternalJob;:188(0)
+Lorg/eclipse/core/internal/resources/InternalWorkspaceJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:31(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/AddJarFileToIndex;.execute (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:60(0)
+Lorg/eclipse/core/internal/resources/DelayedSnapshotJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:39(0)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager$1$ProgressJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:320(0)
+Lorg/eclipse/core/internal/events/AutoBuildJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:192(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexAllProject;.execute (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:53(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.shutdown ()V:518(0)
+Lorg/eclipse/osgi/framework/internal/core/PackageAdminImpl;.processDelta ([Lorg/eclipse/osgi/service/resolver/BundleDelta;Z)[Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;:306(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.dispatchEvent (Ljava/lang/Object;Ljava/lang/Object;ILjava/lang/Object;)V:451(0)
+Lorg/eclipse/debug/internal/core/InputStreamMonitor;.write ()V:104(0)
+Lorg/eclipse/jdt/internal/launching/LaunchingPlugin$JREUpdateJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:296(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager$FlushJob;.runInWorkspace (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:63(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.save (ILorg/eclipse/core/internal/resources/Project;Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:941(0)
+Lorg/eclipse/core/internal/events/AutoBuildJob;.doBuild (Lorg/eclipse/core/runtime/IProgressMonitor;)V:129(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.startJob ()Lorg/eclipse/core/runtime/jobs/Job;:1019(0)
+Lorg/eclipse/core/internal/utils/StringPoolJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:83(0)
+Lorg/eclipse/core/runtime/adaptor/EclipseAdaptor;.frameworkStopping (Lorg/osgi/framework/BundleContext;)V:764(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.publishBundleEvent (ILorg/osgi/framework/Bundle;)V:1416(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.doSetStartLevel (ILorg/eclipse/osgi/framework/internal/core/AbstractBundle;)V:266(0)
+Lorg/eclipse/jdt/internal/launching/LaunchingPlugin$VMChanges;.doit (Lorg/eclipse/core/runtime/IProgressMonitor;)V:208(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.visitAndSnap (Lorg/eclipse/core/resources/IResource;)V:1438(0)
+Lorg/eclipse/core/internal/resources/Workspace;.broadcastBuildEvent (Ljava/lang/Object;II)V:184(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.collapseTrees ()V:221(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.doFlushCache (Lorg/eclipse/core/runtime/IProgressMonitor;[Lorg/eclipse/core/runtime/IPath;)V:204(0)
+Lorg/eclipse/core/internal/resources/Workspace;.endOperation (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;ZLorg/eclipse/core/runtime/IProgressMonitor;)V:883(0)
+Lorg/eclipse/core/internal/utils/StringPoolJob;.shareStrings ([Lorg/eclipse/core/internal/utils/IStringPoolParticipant;Lorg/eclipse/core/runtime/IProgressMonitor;)I:119(0)
+Lorg/eclipse/core/runtime/internal/adaptor/BundleStopper;.stopBundles ()V:67(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.publishBundleEventPrivileged (Lorg/osgi/framework/BundleEvent;)V:1437(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.incFWSL (ILorg/eclipse/osgi/framework/internal/core/AbstractBundle;)V:469(0)
+Lorg/eclipse/jdt/core/JavaCore;.run (Lorg/eclipse/core/resources/IWorkspaceRunnable;Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:3756(0)
+Lorg/eclipse/core/internal/resources/Resource;.getLocation ()Lorg/eclipse/core/runtime/IPath;:874(0)
+Lorg/eclipse/core/internal/jobs/WorkerPool;.endJob (Lorg/eclipse/core/internal/jobs/InternalJob;Lorg/eclipse/core/runtime/IStatus;)V:93(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.broadcastChanges (Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/internal/events/ResourceChangeEvent;Z)V:132(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.clearContentFlags (Lorg/eclipse/core/runtime/IPath;Lorg/eclipse/core/runtime/IProgressMonitor;)V:233(0)
+Lorg/eclipse/core/internal/resources/Resource;.accept (Lorg/eclipse/core/resources/IResourceProxyVisitor;I)V:41(0)
+Lorg/eclipse/core/internal/resources/Workspace;.broadcastPostChange ()V:179(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.beginRule (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:189(0)
+Lorg/eclipse/core/runtime/internal/adaptor/BundleStopper;.basicStopBundles ()V:77(0)
+Lorg/eclipse/osgi/framework/eventmgr/ListenerQueue;.dispatchEventSynchronous (ILjava/lang/Object;)V:133(0)
+Lorg/eclipse/osgi/framework/internal/core/StartLevelManager;.resumeBundles ([Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;Z)V:546(0)
+Lorg/eclipse/core/internal/resources/Workspace;.run (Lorg/eclipse/core/resources/IWorkspaceRunnable;Lorg/eclipse/core/runtime/jobs/ISchedulingRule;ILorg/eclipse/core/runtime/IProgressMonitor;)V:1710(0)
+Lorg/eclipse/core/internal/watson/ElementTreeIterator;.iterate (Lorg/eclipse/core/internal/watson/IElementContentVisitor;)V:112(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.locationFor (Lorg/eclipse/core/resources/IResource;)Lorg/eclipse/core/runtime/IPath;:423(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.notify ([Lorg/eclipse/core/internal/events/ResourceChangeListenerList$ListenerEntry;Lorg/eclipse/core/resources/IResourceChangeEvent;Z)V:260(0)
+Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;.stop ()V:404(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.dispatchEvent (Ljava/lang/Object;Ljava/lang/Object;ILjava/lang/Object;)V:1179(0)
+Lorg/eclipse/osgi/framework/internal/core/Framework;.resumeBundle (Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;)V:1012(0)
+Lorg/eclipse/core/internal/watson/ElementTreeIterator;.doIteration (Lorg/eclipse/core/internal/dtree/DataTreeNode;Lorg/eclipse/core/internal/watson/IElementContentVisitor;)V:75(0)
+Lorg/eclipse/core/internal/resources/WorkManager;.endUnprotected (I)V:159(0)
+Lorg/eclipse/core/internal/resources/Resource;.exists ()Z:783(0)
+Lorg/eclipse/core/runtime/Platform;.run (Lorg/eclipse/core/runtime/ISafeRunnable;)V:783(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleHost;.stopWorker (Z)V:385(0)
+Lorg/eclipse/core/internal/registry/EclipseBundleListener;.bundleChanged (Lorg/osgi/framework/BundleEvent;)V:68(0)
+Lorg/eclipse/osgi/framework/internal/core/AbstractBundle;.resume ()V:332(0)
+Lorg/eclipse/core/internal/resources/Resource;.getResourceInfo (ZZ)Lorg/eclipse/core/internal/resources/ResourceInfo;:973(0)
+Lorg/eclipse/core/internal/resources/Project;.internalGetDescription ()Lorg/eclipse/core/internal/resources/ProjectDescription;:617(0)
+Lorg/eclipse/core/internal/resources/Resource;.isLinked ()Z:1470(0)
+Lorg/eclipse/core/internal/jobs/OrderedLock;.acquire ()V:80(0)
+Lorg/eclipse/core/internal/resources/Resource$1;.visitElement (Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/internal/watson/IPathRequestor;Ljava/lang/Object;)Z:44(-2)
+Lorg/eclipse/core/internal/resources/Project;.isAccessible ()Z:656(0)
+Lorg/eclipse/core/internal/resources/Project;.isOpen ()Z:697(0)
+Lorg/eclipse/core/internal/runtime/InternalPlatform;.run (Lorg/eclipse/core/runtime/ISafeRunnable;)V:1042(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager$1;.visitElement (Lorg/eclipse/core/internal/watson/ElementTree;Lorg/eclipse/core/internal/watson/IPathRequestor;Ljava/lang/Object;)Z:239(-2)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.stop ()V:1031(0)
+Lorg/eclipse/core/internal/registry/EclipseBundleListener;.addBundle (Lorg/osgi/framework/Bundle;)V:99(0)
+Lorg/eclipse/core/internal/registry/ExtensionRegistry$ExtensionEventDispatcherJob;.run (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:58(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleHost;.startWorker (Z)V:282(0)
+Lorg/eclipse/core/internal/resources/Workspace;.getResourceInfo (Lorg/eclipse/core/runtime/IPath;ZZ)Lorg/eclipse/core/internal/resources/ResourceInfo;:1129(-2)
+Lorg/eclipse/core/internal/jobs/OrderedLock;.acquire (J)Z:92(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexAllProject$1;.visit (Lorg/eclipse/core/resources/IResourceProxy;)Z:135(0)
+Lorg/eclipse/core/internal/resources/WorkspaceRoot;.getProjects ()[Lorg/eclipse/core/resources/IProject;:152(0)
+Lorg/eclipse/core/internal/events/BuildManager;.createBuildersPersistentInfo (Lorg/eclipse/core/resources/IProject;)Ljava/util/ArrayList;:363(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.saveMetaInfo (Lorg/eclipse/core/runtime/MultiStatus;Lorg/eclipse/core/runtime/IProgressMonitor;)V:1069(0)
+Lorg/eclipse/core/internal/resources/Workspace;.beginOperation (Z)V:163(0)
+Lorg/eclipse/core/internal/jobs/ImplicitJobs;.begin (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;Z)V:51(0)
+Lorg/eclipse/core/internal/events/NotificationManager$2;.run ()V:276(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl$3;.run ()Ljava/lang/Object;:1033(0)
+Lorg/eclipse/core/internal/registry/EclipseBundleListener;.getBundleModel (Lorg/osgi/framework/Bundle;)Lorg/eclipse/core/internal/registry/Contribution;:153(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.start ()V:965(0)
+Lorg/eclipse/core/internal/resources/Container;.findMember (Lorg/eclipse/core/runtime/IPath;)Lorg/eclipse/core/resources/IResource;:69(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.broadcastLifecycle (ILjava/util/Map;Lorg/eclipse/core/runtime/MultiStatus;Lorg/eclipse/core/runtime/IProgressMonitor;)V:127(0)
+Lorg/eclipse/core/internal/jobs/ThreadJob;.joinRun (Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/internal/jobs/ThreadJob;:148(0)
+Lorg/eclipse/core/internal/resources/Container;.getChildren (I)[Lorg/eclipse/core/resources/IResource;:91(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessingState;.resourceChanged (Lorg/eclipse/core/resources/IResourceChangeEvent;)V:416(0)
+Lorg/eclipse/core/internal/compatibility/PluginActivator;.stop (Lorg/osgi/framework/BundleContext;)V:41(0)
+Lorg/eclipse/core/internal/events/BuildManager;.getBuildersPersistentInfo (Lorg/eclipse/core/resources/IProject;)Ljava/util/ArrayList;:489(0)
+Lorg/eclipse/core/internal/jobs/OrderedLock;.doAcquire (Lorg/eclipse/core/internal/jobs/Semaphore;J)Z:148(0)
+Lorg/eclipse/core/internal/utils/StringPoolJob$1;.run ()V:130(0)
+Lorg/eclipse/jdt/core/JavaCore;.stop (Lorg/osgi/framework/BundleContext;)V:4099(0)
+Lorg/eclipse/core/internal/registry/ExtensionsParser;.parseManifest (Lorg/osgi/util/tracker/ServiceTracker;Lorg/xml/sax/InputSource;Ljava/lang/String;Ljava/lang/String;Lorg/eclipse/core/internal/registry/RegistryObjectManager;Lorg/eclipse/core/internal/registry/Contribution;Ljava/util/ResourceBundle;)Lorg/eclipse/core/internal/registry/Contribution;:346(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl;.startActivator (Lorg/osgi/framework/BundleActivator;)V:985(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl;.parse (Lorg/xml/sax/InputSource;Lorg/xml/sax/helpers/DefaultHandler;)V:0(0)
+Lorg/eclipse/osgi/framework/internal/core/BundleContextImpl$2;.run ()Ljava/lang/Object;:990(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl$JAXPSAXParser;.parse (Lorg/xml/sax/InputSource;)V:0(0)
+Lorg/eclipse/core/internal/content/ContentTypeManager;.registryChanged (Lorg/eclipse/core/runtime/IRegistryChangeEvent;)V:151(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.endJob (Lorg/eclipse/core/internal/jobs/InternalJob;Lorg/eclipse/core/runtime/IStatus;Z)V:443(0)
+Lorg/eclipse/core/internal/jobs/Semaphore;.acquire (J)Z:27(0)
+Lorg/eclipse/core/internal/resources/CharsetManager$Listener;.resourceChanged (Lorg/eclipse/core/resources/IResourceChangeEvent;)V:163(0)
+Lorg/eclipse/core/internal/resources/Container;.findMember (Lorg/eclipse/core/runtime/IPath;Z)Lorg/eclipse/core/resources/IResource;:76(0)
+Lorg/eclipse/core/internal/resources/Resource;.getSessionProperty (Lorg/eclipse/core/runtime/QualifiedName;)Ljava/lang/Object;:980(0)
+Lorg/eclipse/core/internal/resources/SaveManager$1;.run ()V:153(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.saveMetaInfo (Lorg/eclipse/core/internal/resources/Project;Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;:1094(0)
+Lorg/eclipse/core/resources/ResourcesPlugin;.shutdown ()V:330(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.resourceChanged (Lorg/eclipse/core/resources/IResourceChangeEvent;)V:1766(0)
+Lorg/eclipse/jdt/internal/core/JavaModelManager;.shutdown ()V:2566(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexManager$1;.execute (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:591(0)
+Lorg/eclipse/update/internal/configurator/ConfigurationActivator;.start (Lorg/osgi/framework/BundleContext;)V:64(0)
+Lorg/apache/xerces/parsers/AbstractSAXParser;.parse (Lorg/xml/sax/InputSource;)V:0(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.hasSavedProject (Lorg/eclipse/core/resources/IProject;)Z:251(0)
+Lorg/eclipse/core/internal/resources/CharsetManager$Listener;.processEntryChanges (Lorg/eclipse/core/resources/IResourceDelta;Ljava/util/Set;)V:119(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.executeLifecycle (ILorg/eclipse/core/resources/ISaveParticipant;Lorg/eclipse/core/internal/resources/SaveContext;)V:316(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessingState$ProjectUpdateInfo;.updateProjectReferencesIfNecessary ()V:94(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.checkProjectsBeingAddedOrRemoved (Lorg/eclipse/core/resources/IResourceDelta;)V:357(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.createExternalArchiveDelta (Lorg/eclipse/core/runtime/IProgressMonitor;)Z:688(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.updateClasspathMarkers (Lorg/eclipse/core/resources/IResourceDelta;)V:2113(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/IndexManager;.indexDocument (Lorg/eclipse/jdt/core/search/SearchDocument;Lorg/eclipse/jdt/core/search/SearchParticipant;Lorg/eclipse/jdt/internal/core/index/Index;Lorg/eclipse/core/runtime/IPath;)V:289(-2)
+Lorg/eclipse/jdt/internal/core/search/processing/JobManager;.shutdown ()V:414(0)
+Lorg/eclipse/update/internal/configurator/ConfigurationActivator;.installBundles ()Z:139(0)
+Lorg/apache/xerces/parsers/XMLParser;.parse (Lorg/apache/xerces/xni/parser/XMLInputSource;)V:0(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.getDescriptionLocationFor (Lorg/eclipse/core/resources/IProject;)Lorg/eclipse/core/runtime/IPath;:204(0)
+Lorg/eclipse/core/internal/resources/Project;.setDescription (Lorg/eclipse/core/resources/IProjectDescription;Lorg/eclipse/core/runtime/IProgressMonitor;)V:968(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.shareStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:1154(0)
+Lorg/eclipse/core/internal/resources/Workspace;.close (Lorg/eclipse/core/runtime/IProgressMonitor;)V:314(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.updateClasspathMarkers (Lorg/eclipse/core/resources/IResourceDelta;Ljava/util/HashSet;Ljava/util/Map;Ljava/util/Map;)V:2025(0)
+Lorg/eclipse/jdt/internal/core/JavaModelManager;.saving (Lorg/eclipse/core/resources/ISaveContext;)V:2325(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getResolvedClasspath ([Lorg/eclipse/jdt/core/IClasspathEntry;Lorg/eclipse/core/runtime/IPath;ZZLjava/util/Map;)[Lorg/eclipse/jdt/core/IClasspathEntry;:2001(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.hasJavaNature (Lorg/eclipse/core/resources/IProject;)Z:224(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updateClasspathMarkers (Ljava/util/Map;Ljava/util/Map;)V:2915(0)
+Lorg/eclipse/update/internal/configurator/ConfigurationActivator;.refreshPackages ([Lorg/osgi/framework/Bundle;)V:341(0)
+Lorg/apache/xerces/parsers/XML11Configuration;.parse (Lorg/apache/xerces/xni/parser/XMLInputSource;)V:0(0)
+Lorg/eclipse/core/internal/registry/RegistryChangeEvent;.getExtensionDeltas (Ljava/lang/String;Ljava/lang/String;)[Lorg/eclipse/core/runtime/IExtensionDelta;:71(0)
+Lorg/eclipse/core/internal/resources/CharsetManager;.getPreferences (Lorg/eclipse/core/resources/IProject;Z)Lorg/osgi/service/prefs/Preferences;:215(0)
+Lorg/eclipse/core/internal/resources/Project;.hasNature (Ljava/lang/String;)Z:479(0)
+Lorg/eclipse/core/internal/resources/Project;.setDescription (Lorg/eclipse/core/resources/IProjectDescription;ILorg/eclipse/core/runtime/IProgressMonitor;)V:908(0)
+Lorg/eclipse/core/internal/resources/Workspace;.shutdown (Lorg/eclipse/core/runtime/IProgressMonitor;)V:1807(0)
+Lorg/eclipse/core/internal/watson/ElementTree;.shareStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:706(0)
+Lorg/eclipse/jdt/internal/core/ClasspathEntry;.validateClasspathEntry (Lorg/eclipse/jdt/core/IJavaProject;Lorg/eclipse/jdt/core/IClasspathEntry;ZZ)Lorg/eclipse/jdt/core/IJavaModelStatus;:1506(0)
+Lorg/eclipse/jdt/internal/core/ClasspathEntry;.validateClasspath (Lorg/eclipse/jdt/core/IJavaProject;[Lorg/eclipse/jdt/core/IClasspathEntry;Lorg/eclipse/core/runtime/IPath;)Lorg/eclipse/jdt/core/IJavaModelStatus;:1241(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.processResourceDelta (Lorg/eclipse/core/resources/IResourceDelta;)Lorg/eclipse/jdt/core/IJavaElementDelta;:1598(0)
+Lorg/eclipse/jdt/internal/core/JavaModel;.getTarget (Lorg/eclipse/core/resources/IContainer;Lorg/eclipse/core/runtime/IPath;Z)Ljava/lang/Object;:343(0)
+Lorg/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo;.rememberExternalLibTimestamps ()V:711(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.createClasspathProblemMarker (Lorg/eclipse/jdt/core/IJavaModelStatus;)V:716(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.flushClasspathProblemMarkers (ZZ)V:1165(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.readClasspathFile (ZZ)[Lorg/eclipse/jdt/core/IClasspathEntry;:2547(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updateAllCycleMarkers (Ljava/util/Map;)V:240(0)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchParticipant;.indexDocument (Lorg/eclipse/jdt/core/search/SearchDocument;Lorg/eclipse/core/runtime/IPath;)V:68(0)
+Lorg/apache/xerces/parsers/XML11Configuration;.parse (Z)Z:0(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.isDescriptionSynchronized (Lorg/eclipse/core/resources/IProject;)Z:354(0)
+Lorg/eclipse/core/internal/resources/Project;.basicSetDescription (Lorg/eclipse/core/internal/resources/ProjectDescription;I)Lorg/eclipse/core/runtime/MultiStatus;:35(0)
+Lorg/eclipse/core/internal/resources/ProjectPreferences;.nodeExists (Ljava/lang/String;)Z:129(0)
+Lorg/eclipse/core/internal/resources/Project;.writeDescription (Lorg/eclipse/core/resources/IProjectDescription;IZZ)V:1048(0)
+Lorg/eclipse/core/internal/resources/Resource;.findMarkers (Ljava/lang/String;ZI)[Lorg/eclipse/core/resources/IMarker;:802(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getOption (Ljava/lang/String;Z)Ljava/lang/String;:1536(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.readClasspathFile (ZZLjava/util/Map;)[Lorg/eclipse/jdt/core/IClasspathEntry;:2553(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updateCycleParticipants (Ljava/util/ArrayList;Ljava/util/HashSet;Lorg/eclipse/core/resources/IWorkspaceRoot;Ljava/util/HashSet;Ljava/util/Map;)V:2965(0)
+Lorg/apache/xerces/impl/XMLDocumentFragmentScannerImpl;.scanDocument (Z)Z:0(0)
+Lorg/eclipse/core/internal/dtree/DeltaDataTree;.storeStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:953(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.internalWrite (Lorg/eclipse/core/resources/IProject;Lorg/eclipse/core/resources/IProjectDescription;IZZ)Z:263(0)
+Lorg/eclipse/core/internal/resources/Marker;.delete ()V:66(-2)
+Lorg/eclipse/core/internal/resources/MarkerManager;.findMarkers (Lorg/eclipse/core/resources/IResource;Ljava/lang/String;ZI)[Lorg/eclipse/core/resources/IMarker;:224(0)
+Lorg/eclipse/core/internal/resources/Marker;.setAttributes ([Ljava/lang/String;[Ljava/lang/Object;)V:266(0)
+Lorg/eclipse/core/internal/resources/Project;.getDescription ()Lorg/eclipse/core/resources/IProjectDescription;:346(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getEclipsePreferences ()Lorg/eclipse/core/runtime/preferences/IEclipsePreferences;:1369(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getSharedProperty (Ljava/lang/String;)Ljava/lang/String;:2111(0)
+Lorg/eclipse/jdt/internal/core/search/indexing/SourceIndexer;.indexDocument ()V:51(0)
+Lorg/apache/xerces/impl/XMLDocumentFragmentScannerImpl$FragmentContentDispatcher;.dispatch (Z)Z:0(0)
+Lorg/eclipse/core/internal/registry/RegistryDelta;.getExtensionDeltas (Ljava/lang/String;)[Lorg/eclipse/core/runtime/IExtensionDelta;:37(0)
+Lorg/eclipse/core/internal/resources/LocalMetaArea;.writePrivateDescription (Lorg/eclipse/core/resources/IProject;)V:327(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.recursiveFindMarkers (Lorg/eclipse/core/runtime/IPath;Ljava/util/ArrayList;Ljava/lang/String;ZI)V:317(0)
+Lorg/eclipse/core/internal/resources/Resource;.createMarker (Ljava/lang/String;)Lorg/eclipse/core/resources/IMarker;:617(0)
+Lorg/eclipse/core/resources/ProjectScope;.getNode (Ljava/lang/String;)Lorg/eclipse/core/runtime/preferences/IEclipsePreferences;:65(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.traverseDelta (Lorg/eclipse/core/resources/IResourceDelta;ILorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;Lorg/eclipse/jdt/internal/core/DeltaProcessor$OutputsInfo;)V:1868(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.updatePreferences (Lorg/eclipse/core/runtime/preferences/IEclipsePreferences;)V:3024(-2)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchDocument;.getCharContents ()[C:51(0)
+Lorg/eclipse/jdt/internal/core/util/Util;.getResourceContentsAsByteArray (Lorg/eclipse/core/resources/IFile;)[B:995(0)
+Lorg/eclipse/core/internal/resources/File;.getContents (Z)Ljava/io/InputStream;:290(0)
+Lorg/eclipse/core/internal/resources/Marker;.getInfo ()Lorg/eclipse/core/internal/resources/MarkerInfo;:181(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.add (Lorg/eclipse/core/resources/IResource;Lorg/eclipse/core/internal/resources/MarkerInfo;)V:52(0)
+Lorg/eclipse/core/internal/resources/Workspace;.prepareOperation (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:1674(0)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchDocument;.getEncoding ()Ljava/lang/String;:63(-2)
+Lorg/eclipse/jdt/internal/core/search/JavaSearchDocument;.getLocation ()Lorg/eclipse/core/runtime/IPath;:84(0)
+Lorg/eclipse/core/internal/dtree/DataTreeNode;.storeStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:343(0)
+Lorg/eclipse/core/internal/localstore/FileSystemResourceManager;.read (Lorg/eclipse/core/resources/IFile;ZLorg/eclipse/core/runtime/IProgressMonitor;)Ljava/io/InputStream;:507(0)
+Lorg/eclipse/core/internal/resources/File;.getCharset ()Ljava/lang/String;:205(0)
+Lorg/eclipse/core/internal/resources/Marker;.getAttribute (Ljava/lang/String;)Ljava/lang/Object;:97(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.basicAdd (Lorg/eclipse/core/resources/IResource;Lorg/eclipse/core/internal/resources/MarkerSet;Lorg/eclipse/core/internal/resources/MarkerInfo;)V:79(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.findMarkerInfo (Lorg/eclipse/core/resources/IResource;J)Lorg/eclipse/core/internal/resources/MarkerInfo;:208(0)
+Lorg/eclipse/core/internal/resources/WorkManager;.checkIn (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;Lorg/eclipse/core/runtime/IProgressMonitor;)V:90(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.outputsInfo (Lorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;Lorg/eclipse/core/resources/IResource;)Lorg/eclipse/jdt/internal/core/DeltaProcessor$OutputsInfo;:1524(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.updateCurrentDeltaAndIndex (Lorg/eclipse/core/resources/IResourceDelta;ILorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;)Z:2174(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.loadPreferences ()Lorg/eclipse/core/runtime/Preferences;:2387(0)
+Lorg/eclipse/core/internal/dtree/AbstractDataTreeNode;.storeStrings (Lorg/eclipse/core/internal/utils/StringPool;)V:536(0)
+Lorg/eclipse/core/internal/resources/File;.getCharset (Z)Ljava/lang/String;:213(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.removeMarker (Lorg/eclipse/core/resources/IResource;J)V:375(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getPluginWorkingLocation ()Lorg/eclipse/core/runtime/IPath;:1796(0)
+Lorg/eclipse/core/internal/resources/File;.internalGetCharset (ZLorg/eclipse/core/internal/resources/ResourceInfo;)Ljava/lang/String;:253(0)
+Lorg/eclipse/core/internal/resources/Project;.getWorkingLocation (Ljava/lang/String;)Lorg/eclipse/core/runtime/IPath;:403(0)
+Lorg/eclipse/jdt/internal/core/JavaProject;.getOptions (Z)Ljava/util/Map;:1553(0)
+Lorg/eclipse/core/internal/resources/CharsetManager;.getCharsetFor (Lorg/eclipse/core/runtime/IPath;Z)Ljava/lang/String;:200(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.getDescriptionFor (Lorg/eclipse/core/internal/resources/File;Lorg/eclipse/core/internal/resources/ResourceInfo;)Lorg/eclipse/core/runtime/content/IContentDescription;:293(0)
+Lorg/eclipse/jdt/internal/core/DeltaProcessor;.createElement (Lorg/eclipse/core/resources/IResource;ILorg/eclipse/jdt/internal/core/DeltaProcessor$RootInfo;)Lorg/eclipse/jdt/internal/core/Openable;:566(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.readDescription (Lorg/eclipse/core/internal/resources/File;)Lorg/eclipse/core/runtime/content/IContentDescription;:388(-2)
+Lorg/eclipse/core/internal/content/ContentTypeMatcher;.getDescriptionFor (Ljava/io/InputStream;Ljava/lang/String;[Lorg/eclipse/core/runtime/QualifiedName;)Lorg/eclipse/core/runtime/content/IContentDescription;:87(0)
+Lorg/eclipse/core/internal/jobs/JobManager;.schedule (Lorg/eclipse/core/internal/jobs/InternalJob;JZ)V:840(0)
+Lorg/eclipse/core/internal/resources/MarkerManager;.changedMarkers (Lorg/eclipse/core/resources/IResource;[Lorg/eclipse/core/internal/resources/IMarkerSetElement;)V:179(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.getDescriptionFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Ljava/io/InputStream;Ljava/lang/String;[Lorg/eclipse/core/runtime/QualifiedName;)Lorg/eclipse/core/runtime/content/IContentDescription;:316(0)
+Lorg/eclipse/core/internal/resources/ContentDescriptionManager;.getContentTypeMatcher (Lorg/eclipse/core/internal/resources/Project;)Lorg/eclipse/core/runtime/content/IContentTypeMatcher;:289(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.getDescriptionFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Lorg/eclipse/core/internal/content/ILazySource;Ljava/lang/String;[Lorg/eclipse/core/runtime/QualifiedName;)Lorg/eclipse/core/runtime/content/IContentDescription;:302(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes;.getMatcherFor (Lorg/eclipse/core/internal/resources/Project;)Lorg/eclipse/core/runtime/content/IContentTypeMatcher;:196(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes;.usesContentTypePreferences (Ljava/lang/String;)Z:108(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.internalFindContentTypesFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Lorg/eclipse/core/internal/content/ILazySource;Ljava/lang/String;Z)[Lorg/eclipse/core/runtime/content/IContentType;:376(0)
+Lorg/eclipse/core/internal/content/ContentTypeMatcher;.getSpecificDescription (Lorg/eclipse/core/internal/content/BasicDescription;)Lorg/eclipse/core/runtime/content/IContentDescription;:136(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.internalFindContentTypesFor (Lorg/eclipse/core/internal/content/ContentTypeMatcher;Ljava/lang/String;Ljava/util/Comparator;)[[Lorg/eclipse/core/runtime/content/IContentType;:403(0)
+Lorg/eclipse/core/internal/preferences/AbstractScope;.equals (Ljava/lang/Object;)Z:51(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.selectMatchingByName (Lorg/eclipse/core/runtime/preferences/IScopeContext;Ljava/util/Collection;Ljava/util/Collection;Ljava/lang/String;I)Ljava/util/Set;:515(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.equals (Ljava/lang/Object;)Z:55(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.getLocation ()Lorg/eclipse/core/runtime/IPath;:73(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.getName ()Ljava/lang/String;:77(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog;.internalAccept (Lorg/eclipse/core/internal/content/ContentTypeVisitor;Lorg/eclipse/core/internal/content/ContentType;)Z:332(0)
+Lorg/eclipse/core/internal/resources/ProjectContentTypes$ProjectContentTypeSelectionPolicy;.getDelegate ()Lorg/eclipse/core/runtime/preferences/IScopeContext;:67(0)
+Lorg/eclipse/core/internal/content/ContentTypeCatalog$7;.visit (Lorg/eclipse/core/internal/content/ContentType;)I:525(0)
+Lorg/eclipse/core/internal/content/ContentType;.hasFileSpec (Lorg/eclipse/core/runtime/preferences/IScopeContext;Ljava/lang/String;I)Z:370(0)
+Lorg/eclipse/core/internal/resources/SaveManager;.shutdown (Lorg/eclipse/core/runtime/IProgressMonitor;)V:1161(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.requestNotify ()V:196(0)
+Lorg/eclipse/core/internal/events/NotificationManager;.getDelta (Lorg/eclipse/core/internal/watson/ElementTree;I)Lorg/eclipse/core/internal/events/ResourceDelta;:209(0)
+Lorg/eclipse/core/internal/resources/WorkManager;.checkOut (Lorg/eclipse/core/runtime/jobs/ISchedulingRule;)V:111(0)
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/elevator.txt workspace/velodrome-sound/velodrome/exclusion-list/elevator.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/elevator.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/elevator.txt	2014-04-03 17:43:56.968716371 -0400
@@ -0,0 +1,23 @@
+# Elevator
+
+Lelevator/Elevator;.main ([Ljava/lang/String;)V:117(0)
+# Does Velodrome include this in their count?
+Lelevator/Lift;.run ()V:60(0)
+Lelevator/Lift;.sleep (J)V:866(0)
+# This method contains a join()
+Lelevator/Elevator;.waitForLiftsToFinishOperation ()V:105(0)
+Lelevator/Lift;.join ()V:0(0)
+# This method contains a sleep, so shouldn't be reported
+Lelevator/Elevator;.begin ()V:73(0)
+
+# Velodrome results
+
+Lelevator/Lift;.doIdle ()V:79(0)
+Lelevator/Controls;.claimUp (Ljava/lang/String;I)Z:50(0)
+
+
+#Lelevator/Elevator;.Elevator (Ljava/lang/String;)V:26(0)
+#Lelevator/Controls;.claimDown (Ljava/lang/String;I)Z:66(0)
+#Lelevator/Lift;.doMoving ()V:126(0)
+#Lelevator/Controls;.pushUp (II)V:36(0)
+#Lelevator/Controls;.pushDown (II)V:24(0)
\ No newline at end of file
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/hedc.txt workspace/velodrome-sound/velodrome/exclusion-list/hedc.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/hedc.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/hedc.txt	2014-04-03 17:43:56.972716385 -0400
@@ -0,0 +1,17 @@
+# HEDC
+
+Lhedc/Tester;.main ([Ljava/lang/String;)V:48(0)
+Lhedc/Tester;.run ()V:109(0)
+
+# Does Velodrome consider this to be a violation?
+Lhedc/PooledExecutorWithInvalidate$Worker;.run ()V:297(0)
+Lhedc/Task;.run ()V:38(0)
+
+# Velodrome results
+
+Lhedc/MetaSearchRequest;.go ()V:42(0)
+Lhedc/MetaSearchImpl;.search (Ljava/util/Hashtable;Lhedc/MetaSearchRequest;)Ljava/util/List;:67(0)
+Lhedc/PooledExecutorWithInvalidate;.getTask ()Lhedc/Task;:279(0)
+
+#Lhedc/PooledExecutorWithInvalidate;.execute (Lhedc/Task;)V:414(0)
+#Lhedc/Task;.runImpl ()V:48(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/hsqldb6.txt workspace/velodrome-sound/velodrome/exclusion-list/hsqldb6.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/hsqldb6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/hsqldb6.txt	2014-04-03 17:43:56.973716388 -0400
@@ -0,0 +1,31 @@
+# Hsqldb6
+
+# Trivial
+Ldacapo/hsqldb/PseudoJDBCBench;.main ([Ljava/lang/String;)V:94(0)
+Ldacapo/hsqldb/HsqldbHarness;.iterate (Ljava/lang/String;)V:19(0)
+Ldacapo/hsqldb/HsqldbHarness;.postIteration (Ljava/lang/String;)V:23(0)
+Ldacapo/hsqldb/PseudoJDBCBench$ClientThread;.run ()V:901(0)
+Ldacapo/hsqldb/PseudoJDBCBench$MemoryWatcherThread;.join ()V:0(0)
+Ldacapo/hsqldb/PseudoJDBCBench$MemoryWatcherThread;.run ()V:0(0)
+Ldacapo/hsqldb/PseudoJDBCBench$MemoryWatcherThread;.start ()V:0(0)
+
+# Velodrome results
+
+Ldacapo/hsqldb/PseudoJDBCBench$ClientThread;.doOne (IIII)I:950(0)
+Lorg/hsqldb/jdbc/jdbcPreparedStatement;.executeUpdate ()I:0(0)
+Lorg/hsqldb/jdbc/jdbcPreparedStatement;.executeQuery ()Ljava/sql/ResultSet;:0(0)
+Lorg/hsqldb/Session;.execute (Lorg/hsqldb/Result;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Result;.setParameterData ([Ljava/lang/Object;)V:0(0)
+Lorg/hsqldb/Session;.sqlExecute (Lorg/hsqldb/Result;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Record;.<init> ()V:0(0)
+Lorg/hsqldb/Session;.sqlExecute (Lorg/hsqldb/CompiledStatement;[Ljava/lang/Object;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/Session;.sqlExecuteCompiledNoPreChecks (Lorg/hsqldb/CompiledStatement;[Ljava/lang/Object;)Lorg/hsqldb/Result;:0(0)
+Lorg/hsqldb/CompiledStatementExecutor;.execute (Lorg/hsqldb/CompiledStatement;[Ljava/lang/Object;)Lorg/hsqldb/Result;:0(0)
+
+
+
+
+
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/jython9.txt workspace/velodrome-sound/velodrome/exclusion-list/jython9.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/jython9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/jython9.txt	2014-04-03 17:43:56.974716391 -0400
@@ -0,0 +1,5 @@
+Lorg/dacapo/harness/Jython;.iterate (Ljava/lang/String;)V:48(0)
+Lorg/python/util/jython;.main ([Ljava/lang/String;)V:0(0)
+
+# Velodrome results
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/luindex9.txt workspace/velodrome-sound/velodrome/exclusion-list/luindex9.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/luindex9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/luindex9.txt	2014-04-03 17:43:56.971716382 -0400
@@ -0,0 +1,14 @@
+# Luindex9
+
+# Trivial
+Lorg/dacapo/luindex/Index;.main (Ljava/io/File;[Ljava/lang/String;)V:66(0)
+
+# Not sure about these, just blindly searched for all Thread::run() methods in the lucene library
+Lorg/apache/lucene/index/ConcurrentMergeScheduler$MergeThread;.run ()V:248(0)
+Lorg/apache/lucene/search/MultiSearcherThread;.run ()V:248(0)
+Lorg/apache/lucene/search/TimeLimitedCollector$TimerThread;.run ()V:69(0)
+
+
+# Velodrome results
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/lusearch6.txt workspace/velodrome-sound/velodrome/exclusion-list/lusearch6.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/lusearch6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/lusearch6.txt	2014-04-03 17:43:56.970716379 -0400
@@ -0,0 +1,10 @@
+#Lusearch6
+
+Ldacapo/lusearch/LusearchHarness$QueryThread;.run ()V:159(0)
+#Lorg/dacapo/lusearch/Search$QueryThread;.run ()V:176(0)
+#Lorg/dacapo/lusearch/Search$QueryProcessor;.run ()V:217(0)
+
+# Velodrome results
+
+ Ldacapo/lusearch/LusearchHarness$QueryThread;.runQuery ()V:166(0)
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/lusearch9.txt workspace/velodrome-sound/velodrome/exclusion-list/lusearch9.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/lusearch9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/lusearch9.txt	2014-04-03 17:43:56.971716382 -0400
@@ -0,0 +1,59 @@
+# Lusearch9-fixed
+
+# Need to check for specifications, lusearch harness for example
+Lorg/dacapo/lusearch/Search;.main ([Ljava/lang/String;)V:77(0) 
+Lorg/dacapo/lusearch/Search$QueryThread;.run ()V:176(0)
+Lorg/dacapo/lusearch/Search$QueryThread;.start ()V:0(0)
+Lorg/dacapo/lusearch/Search$QueryProcessor;.run ()V:0(0)
+
+# Not sure about these, just blindly searched for all Thread::run() methods in the lucene library
+Lorg/apache/lucene/index/ConcurrentMergeScheduler$MergeThread;.run ()V:248(0)
+Lorg/apache/lucene/search/MultiSearcherThread;.run ()V:248(0)
+Lorg/apache/lucene/search/TimeLimitedCollector$TimerThread;.run ()V:69(0)
+
+# Velodrome results
+
+Lorg/apache/lucene/queryParser/QueryParser;.<init> (Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;)V:157(0)
+Lorg/apache/lucene/queryParser/QueryParser;.parse (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:167(0)
+Lorg/apache/lucene/search/Searcher;.search (Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/Filter;I)Lorg/apache/lucene/search/TopDocs;:136(0)
+Lorg/dacapo/lusearch/Search$QueryProcessor;.<init> (Lorg/dacapo/lusearch/Search;Lorg/dacapo/lusearch/Search;Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ZI)V:201(0)
+Lorg/dacapo/lusearch/Search$QueryProcessor;.doPagingSearch (Lorg/apache/lucene/search/Query;)V:272(0)
+Lorg/apache/lucene/index/IndexReader;.open (Ljava/lang/String;)Lorg/apache/lucene/index/IndexReader;:206(0)
+Lorg/apache/lucene/queryParser/QueryParser;.TopLevelQuery (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1138(0)
+Lorg/apache/lucene/queryParser/QueryParser;.<init> (Lorg/apache/lucene/queryParser/CharStream;)V:1553(0)
+Lorg/apache/lucene/index/IndexReader;.open (Lorg/apache/lucene/store/Directory;ZLorg/apache/lucene/index/IndexDeletionPolicy;Lorg/apache/lucene/index/IndexCommit;Z)Lorg/apache/lucene/index/IndexReader;:316(0)
+Lorg/apache/lucene/queryParser/QueryParser;.Query (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1145(0)
+Lorg/apache/lucene/search/IndexSearcher;.search (Lorg/apache/lucene/search/Weight;Lorg/apache/lucene/search/Filter;I)Lorg/apache/lucene/search/TopDocs;:108(0)
+Lorg/apache/lucene/store/FSDirectory;.getDirectory (Ljava/lang/String;)Lorg/apache/lucene/store/FSDirectory;:139(0)
+Lorg/apache/lucene/index/DirectoryIndexReader;.open (Lorg/apache/lucene/store/Directory;ZLorg/apache/lucene/index/IndexDeletionPolicy;Lorg/apache/lucene/index/IndexCommit;Z)Lorg/apache/lucene/index/DirectoryIndexReader;:90(0)
+Lorg/apache/lucene/queryParser/QueryParser;.Clause (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1191(0)
+Lorg/apache/lucene/search/Searcher;.createWeight (Lorg/apache/lucene/search/Query;)Lorg/apache/lucene/search/Weight;:185(0)
+Lorg/apache/lucene/store/FSDirectory;.getDirectory (Ljava/io/File;Lorg/apache/lucene/store/LockFactory;)Lorg/apache/lucene/store/FSDirectory;:168(0)
+Lorg/apache/lucene/index/SegmentInfos$FindSegmentsFile;.run ()Ljava/lang/Object;:495(0)
+Lorg/apache/lucene/queryParser/QueryParser;.Term (Ljava/lang/String;)Lorg/apache/lucene/search/Query;:1254(0)
+Lorg/apache/lucene/search/Query;.weight (Lorg/apache/lucene/search/Searcher;)Lorg/apache/lucene/search/Weight;:94(0)
+Lorg/apache/lucene/index/DirectoryIndexReader$1;.doBody (Ljava/lang/String;)Ljava/lang/Object;:94(0)
+Lorg/apache/lucene/queryParser/QueryParser;.getFieldQuery (Ljava/lang/String;Ljava/lang/String;)Lorg/apache/lucene/search/Query;:515(0)
+Lorg/apache/lucene/analysis/standard/StandardAnalyzer;.reusableTokenStream (Ljava/lang/String;Ljava/io/Reader;)Lorg/apache/lucene/analysis/TokenStream;:225(0)
+Lorg/apache/lucene/index/SegmentReader;.get (ZLorg/apache/lucene/index/SegmentInfos;Lorg/apache/lucene/index/SegmentInfo;Z)Lorg/apache/lucene/index/SegmentReader;:269(0)
+Lorg/apache/lucene/index/SegmentReader;.get (ZLorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Lorg/apache/lucene/index/SegmentInfos;ZZIZ)Lorg/apache/lucene/index/SegmentReader;:298(0)
+Lorg/apache/lucene/search/TermQuery;.createWeight (Lorg/apache/lucene/search/Searcher;)Lorg/apache/lucene/search/Weight;:146(0)
+Lorg/apache/lucene/index/SegmentReader;.initialize (Lorg/apache/lucene/index/SegmentInfo;IZ)V:311(0)
+Lorg/apache/lucene/search/TermQuery$TermWeight;.<init> (Lorg/apache/lucene/search/TermQuery;Lorg/apache/lucene/search/Searcher;)V:42(0)
+Lorg/apache/lucene/store/FSDirectory;.list ()[Ljava/lang/String;:320(0)
+Lorg/apache/lucene/index/TermInfosReader;.<init> (Lorg/apache/lucene/store/Directory;Ljava/lang/String;Lorg/apache/lucene/index/FieldInfos;I)V:68(0)
+Lorg/apache/lucene/search/IndexSearcher;.doc (I)Lorg/apache/lucene/document/Document;:91(0)
+Lorg/apache/lucene/search/Similarity;.idf (Lorg/apache/lucene/index/Term;Lorg/apache/lucene/search/Searcher;)F:457(0)
+Lorg/apache/lucene/index/IndexReader;.document (I)Lorg/apache/lucene/document/Document;:636(0)
+Lorg/apache/lucene/search/IndexSearcher;.docFreq (Lorg/apache/lucene/index/Term;)I:86(0)
+Lorg/apache/lucene/index/SegmentTermEnum;.<init> (Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/index/FieldInfos;Z)V:44(0)
+Lorg/apache/lucene/index/SegmentReader;.docFreq (Lorg/apache/lucene/index/Term;)I:751(0)
+Lorg/apache/lucene/index/SegmentReader;.document (ILorg/apache/lucene/document/FieldSelector;)Lorg/apache/lucene/document/Document;:729(0)
+Lorg/apache/lucene/index/TermInfosReader;.get (Lorg/apache/lucene/index/Term;)Lorg/apache/lucene/index/TermInfo;:218(0)
+Lorg/apache/lucene/index/FieldsReader;.doc (ILorg/apache/lucene/document/FieldSelector;)Lorg/apache/lucene/document/Document;:177(0)
+Lorg/apache/lucene/index/TermInfosReader;.get (Lorg/apache/lucene/index/Term;Z)Lorg/apache/lucene/index/TermInfo;:223(0)
+Lorg/apache/lucene/index/TermInfosReader;.getThreadResources ()Lorg/apache/lucene/index/TermInfosReader$ThreadResources;:156(0)
+Lorg/apache/lucene/index/FieldsReader;.addField (Lorg/apache/lucene/document/Document;Lorg/apache/lucene/index/FieldInfo;ZZZ)V:329(0)
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/methodNames.txt workspace/velodrome-sound/velodrome/exclusion-list/methodNames.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/methodNames.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/methodNames.txt	2014-04-03 17:43:56.973716388 -0400
@@ -0,0 +1,159 @@
+
+# Java library methods
+
+Ljava/lang/Thread;.run ():742(0)
+Ljava/lang/Runnable;.run ():61(0)
+Ljava/lang/System;.exit (I)V:577(-2)
+Ljava/lang/Thread;.join ()V:0(0)
+
+# Common DaCapo benchmark methods (both 2006 & 2009)
+LMMTkCallback;.<init> ()V:0(0)
+LMMTkCallback;.start ()V:42(0)
+LMMTkCallback;.start (Ljava/lang/String;)V:14(0)
+LMMTkCallback;.stop ()V:53(0)
+LMMTkCallback;.isWarmup ()Z:0(0)
+
+Ldacapo/Callback;.start (Ljava/lang/String;)V:9(0)
+Ldacapo/Callback;.start (Ljava/lang/String;Z)V:15(0)
+Ldacapo/Callback;.complete (Ljava/lang/String;Z)V:29(0)
+Ldacapo/Callback;.stop ()V:22(0)
+Ldacapo/Callback;.complete (Ljava/lang/String;ZZ)V:35(0)
+
+Lharness/Callback;.<init> ()V:0(0)
+Lharness/Callback;.start ()V:15(0)
+Lharness/Callback;.start (Ljava/lang/String;)V:8(0)
+Lharness/Callback;.start (Ljava/lang/String;Z)V:14(0)
+Lharness/Callback;.stop ()V:22(0)
+Lharness/Callback;.complete (Ljava/lang/String;Z)V:29(0)
+Lharness/Callback;.complete (Ljava/lang/String;ZZ)V:35(0)
+Lharness/Callback;.salutation (Z)V:24(0)
+Lharness/Callback;.startWarmup ()V:0(0)
+Lharness/Callback;.stopWarmup ()V:0(0)
+Lharness/Callback;.message (ZZJ)V:0(0)
+
+LHarness;.main ([Ljava/lang/String;)V:5(0)
+
+Ldacapo/TestHarness;.main ([Ljava/lang/String;)V:110(0)
+Ldacapo/TestHarness;.runBenchmark (Ljava/io/File;Ljava/lang/String;Ldacapo/TestHarness;)V:268(0)
+Ldacapo/TestHarness;.findClass ()Ljava/lang/Class;:414(0)
+Ldacapo/TestHarness;.rmdir (Ljava/io/File;)V:376(0)
+Ldacapo/TestHarness;.printUsage ()V:351(0)
+
+# Mostly for DaCapo 2006
+Ldacapo/Benchmark;.preIteration (Ljava/lang/String;)V:182(0)
+Ldacapo/Benchmark;.startIteration ()V:204(0)
+Ldacapo/Benchmark;.postIteration (Ljava/lang/String;)V:364(0)
+Ldacapo/Benchmark;.postIterationCleanup (Ljava/lang/String;)V:375(0)
+Ldacapo/Benchmark;.run (Ldacapo/Callback;Ljava/lang/String;Z)Z:126(50)
+Ldacapo/Benchmark;.cleanup ()V:391(0)
+Ldacapo/Benchmark/Main;.main ()V:18(0)
+Ldacapo/Benchmark;.validate (Ljava/lang/String;)Z:246(0)
+Ldacapo/Benchmark;.deleteTree (Ljava/io/File;)V:519(0)
+Ldacapo/Benchmark;.stopIteration ()V:230(0)
+Ldacapo/Benchmark;.deleteFile (Ljava/io/File;)V:532(0)
+Ldacapo/Benchmark;.iterate (Ljava/lang/String;)V:222(0)
+
+LMMTkHarness;.harnessBegin ()V:41(0)
+LMMTkHarness;.harnessEnd ()V:49(0)
+
+Ldacapo/TeePrintStream;.openLog ()V:37(0)
+Ldacapo/TeePrintStream;.closeLog ()V:40(0)
+Ldacapo/TeeOutputStream;.openLog ()V:50(0)
+Ldacapo/TeeOutputStream;.closeLog ()V:54(0)
+
+# Should be for DaCapo 2009
+Lorg/dacapo/harness/TestHarness;.main ([Ljava/lang/String;)V:100(0)
+Lorg/dacapo/harness/TestHarness;.runBenchmark (Ljava/io/File;Ljava/lang/String;Lorg/dacapo/harness/TestHarness;)V:207(0)
+Lorg/dacapo/harness/CommandLineArgs;.getSize ()Ljava/lang/String;:0(0)
+Lorg/dacapo/harness/TestHarness;.getBuildVersion ()Ljava/lang/String;:0(0)
+Lorg/dacapo/harness/Benchmark;.run (Lorg/dacapo/harness/Callback;Ljava/lang/String;)Z:142(0)
+Lorg/dacapo/harness/Benchmark;.iterate (Ljava/lang/String;)V:304(0)
+Lorg/dacapo/harness/Benchmark;.preIteration (Ljava/lang/String;)V:260(0)
+Lorg/dacapo/harness/Benchmark;.startIteration ()V:282(0)
+Lorg/dacapo/harness/Benchmark;.stopIteration ()V:311(0)
+Lorg/dacapo/harness/Benchmark;.postIteration (Ljava/lang/String;)V:467(0)
+Lorg/dacapo/harness/Benchmark;.useBenchmarkClassLoader ()V:327(0)
+Lorg/dacapo/harness/Benchmark;.prepare (Ljava/lang/String;)V:0(0)
+Lorg/dacapo/harness/TeePrintStream;.openLog ()V:41(0)
+Lorg/dacapo/harness/TeePrintStream;.closeLog ()V:45(0)
+Lorg/dacapo/harness/TeeOutputStream;.openLog ()V:58(0)
+Lorg/dacapo/harness/TeeOutputStream;.closeLog ()V:62(0)
+Lorg/dacapo/harness/TeeOutputStream;.newLog ()V:50(0)
+
+Lorg/dacapo/harness/Callback;.complete (Ljava/lang/String;Z)V:192(0)
+Lorg/dacapo/harness/Callback;.stop ()V:178(0)
+Lorg/dacapo/harness/Callback;.start (Ljava/lang/String;)V:161(0)
+Lorg/dacapo/harness/Callback;.start (Ljava/lang/String;Z)V:170(0)
+Lorg/dacapo/harness/Callback;.complete (Ljava/lang/String;ZZ)V:201(0)
+
+# microbenchmarks
+
+Latomicity/test2;.main ([Ljava/lang/String;)V:5(0)
+Latomicity/ThreadDemo2;.main ([Ljava/lang/String;)V:7(0)
+Latomicity/NewThread2;.run ()V:21(0)
+Latomicity/ThreadDemo4;.main ([Ljava/lang/String;)V:8(0)
+Latomicity/NewThread4;.run ()V:24(0)
+Latomicity/ThreadDemo5;.main ([Ljava/lang/String;)V:8(0)
+Latomicity/NewThread5;.run ()V:25(0)
+Latomicity/ThreadDemo6;.main ([Ljava/lang/String;)V:5(0)
+Latomicity/NewThread6;.run ()V:34(0)
+#Latomicity/NewThread6;.access ()V:39(0)
+Latomicity/ThreadDemo7;.main ([Ljava/lang/String;)V:5(0)
+Latomicity/NewThread7;.run ()V:25(0)
+
+# ETH Zurich
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Java Grande
+
+
+
+
+
+
+
+
+
+
+
+
+# These are Java Grande SOR entries
+
+#sor/JGFSORBench.JGFkernel()V
+#sor/JGFSORBench.JGFrun(I)V");
+#sor/SOR.SORrun(D[[DI)V
+
+
+
+# Doug Lea's concurrent library, details copied from velodrome specification. Each of the following methods contain 
+# a synchronization primitive or overrides Thread::run()
+
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;.run ()V:793(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;.scanWhileIdling ()V:718(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup$InvokableFJTask;.awaitTermination ()V:611(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.checkActive (LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;J)V:534(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.invoke (Ljava/lang/Runnable;)V:214(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.setActive (LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;)V:465(0)
+LEDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup;.signalNewTask ()V:565(0) 
+LEDU/oswego/cs/dl/util/concurrent/LinkedQueue;.take ()Ljava/lang/Object;:105(0)
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/moldyn.txt workspace/velodrome-sound/velodrome/exclusion-list/moldyn.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/moldyn.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/moldyn.txt	2014-04-03 17:43:56.971716382 -0400
@@ -0,0 +1,13 @@
+# Moldyn
+LJGFMolDynBenchSizeA;.main ([Ljava/lang/String;)V:0(0)
+#Lmoldyn/JGFMolDynBenchSizeA;.main ([Ljava/lang/String;)V:29(0)
+Lmoldyn/JGFMolDynBench;.JGFrun (I)V:71(0)
+Lmoldyn/JGFMolDynBench;.JGFapplication ()V:48(0)
+Lmoldyn/JGFMolDynBench;.runiters ()V:64(0)
+Lmoldyn/md;.runiters ()V:64(0)
+Lmoldyn/mdRunner;.run ()V:68(0)
+
+# This method calls Thread.yield()
+Lmoldyn/TournamentBarrier;.DoBarrier (I)V:53(0)
+
+# Velodrome results
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/montecarlo.txt workspace/velodrome-sound/velodrome/exclusion-list/montecarlo.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/montecarlo.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/montecarlo.txt	2014-04-03 17:43:56.973716388 -0400
@@ -0,0 +1,17 @@
+# Montecarlo
+
+LJGFMonteCarloBenchSizeA;.main ([Ljava/lang/String;)V:32(0)
+Lmontecarlo/AppDemo;.runThread ()V:151(0)
+Lmontecarlo/CallAppDemo;.runiters ()V:50(0)
+Lmontecarlo/JGFMonteCarloBench;.runiters ()V:0(0)
+Lmontecarlo/JGFMonteCarloBench;.JGFapplication ()V:45(0)
+Lmontecarlo/JGFMonteCarloBench;.JGFrun (I)V:72(0)
+Lmontecarlo/AppDemoThread;.run ()V:366(0)
+
+# Velodrome results
+Lmontecarlo/PriceStock;.<init> ()V:85(0)
+Lmontecarlo/PriceStock;.run ()V:135(0)
+
+
+#Lmontecarlo/RatePath;.<init> (Lmontecarlo/MonteCarloPath;)V:0(0)
+#Lmontecarlo/PathId;.<init> ()V:0(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/philo.txt workspace/velodrome-sound/velodrome/exclusion-list/philo.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/philo.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/philo.txt	2014-04-03 17:43:56.967716367 -0400
@@ -0,0 +1,13 @@
+# Philo
+
+LPhilo;.main ([Ljava/lang/String;)V:69(0)
+LPhilo;.run ()V:49(0)
+LPhilo;.start ()V:917(0)
+LPhilo;.join ()V:675(0)
+LPhilo;.sleep (J)V:866(0)
+
+# These methods have wait/notify calls within them
+#LTable;.getForks (I)I:14(0)
+#LTable;.putForks (I)V:28(0)
+
+# Velodrome results
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/pmd9.txt workspace/velodrome-sound/velodrome/exclusion-list/pmd9.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/pmd9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/pmd9.txt	2014-04-03 17:43:56.966716364 -0400
@@ -0,0 +1,13 @@
+# Pmd9
+
+# Trivial
+Lnet/sourceforge/pmd/PMD$PmdThread;.run ()V:0(0) 
+Lnet/sourceforge/pmd/PMD;.main ([Ljava/lang/String;)V:405(0)
+
+# Velodrome results
+
+#Lnet/sourceforge/pmd/PMD;.doPMD (Lnet/sourceforge/pmd/CommandLineOptions;)V:0(0)
+#Lnet/sourceforge/pmd/PMD;.processFiles (ILnet/sourceforge/pmd/RuleSetFactory;Lnet/sourceforge/pmd/SourceType;Ljava/util/List;Lnet/sourceforge/pmd/RuleContext;Ljava/util/List;ZLjava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V:0(0)
+#Lnet/sourceforge/pmd/PMD$PmdRunnable;.call ()Ljava/lang/Object;:427(0)
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/raja.txt workspace/velodrome-sound/velodrome/exclusion-list/raja.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/raja.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/raja.txt	2014-04-03 17:43:56.967716367 -0400
@@ -0,0 +1,9 @@
+# Raja
+
+# Trivially left out
+Lraja/ui/CommandLineUI;.main ([Ljava/lang/String;)V:0(0)
+Lraja/renderer/BasicRenderer;.run ()V:53(0)
+
+# AVD results
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/raytracer.txt workspace/velodrome-sound/velodrome/exclusion-list/raytracer.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/raytracer.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/raytracer.txt	2014-04-03 17:43:56.970716379 -0400
@@ -0,0 +1,13 @@
+# Raytracer
+
+LJGFRayTracerBenchSizeA;.main ([Ljava/lang/String;)V:33(0)
+Lraytracer/JGFRayTracerBench;.JGFapplication ()V:52(0)
+Lraytracer/JGFRayTracerBench;.JGFrun (I)V:102(0)
+Ljava/lang/Thread;.run ()V:744(-2)
+Lraytracer/RayTracerRunner;.run ()V:161(0)
+# This method calls Thread.yield()
+Lraytracer/TournamentBarrier;.DoBarrier (I)V:0(0)
+
+
+# Velodrome results
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/sor.txt workspace/velodrome-sound/velodrome/exclusion-list/sor.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/sor.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/sor.txt	2014-04-03 17:43:56.972716385 -0400
@@ -0,0 +1,12 @@
+# Sor
+# These methods are trivially left out
+Lsor/Sor;.main ([Ljava/lang/String;)V:31(0)
+Lsor/sor_first_row_even;.run ()V:236(0)
+Lsor/sor_first_row_odd;.run ()V:171(0))
+
+# These methods might not be intended to be atomic since they have wait()/notify() calls in them. 
+# These are false warnings. These should not be considered.
+LEDU/oswego/cs/dl/util/concurrent/CyclicBarrier;.barrier ()I:177(0)
+LEDU/oswego/cs/dl/util/concurrent/CyclicBarrier;.doBarrier (ZJ)I:214(0)
+
+# Velodrome results
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/sunflow9.txt workspace/velodrome-sound/velodrome/exclusion-list/sunflow9.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/sunflow9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/sunflow9.txt	2014-04-03 17:43:56.969716375 -0400
@@ -0,0 +1,24 @@
+# Sunflow9
+
+# Trivial
+Lorg/sunflow/core/LightServer$1;.run ()V:202(0)
+Lorg/sunflow/core/renderer/SimpleRenderer$BucketThread;.run ()V:57(0)
+Lorg/sunflow/core/renderer/ProgressiveRenderer$SmallBucketThread;.run ()V:78(0)
+Lorg/sunflow/core/renderer/BucketRenderer$BucketThread;.run ()V:178(0)
+
+# Velodrome results
+
+Lorg/sunflow/core/Scene;.trace (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:193(0)
+Lorg/sunflow/core/LightServer;.shadePhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/image/Color;)V:260(0)
+Lorg/sunflow/core/accel/BoundingIntervalHierarchy;.intersect (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:374(0)
+Lorg/sunflow/core/shader/DiffuseShader;.scatterPhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/image/Color;)V:40(0)
+Lorg/sunflow/core/shader/GlassShader;.scatterPhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/image/Color;)V:90(0)
+Lorg/sunflow/core/InstanceList;.intersectPrimitive (Lorg/sunflow/core/Ray;ILorg/sunflow/core/IntersectionState;)V:30(0)
+Lorg/sunflow/core/ShadingState;.traceDiffusePhoton (Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:654(0)
+Lorg/sunflow/core/LightServer;.traceDiffusePhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:268(0)
+Lorg/sunflow/core/Instance;.intersect (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:133(0)
+Lorg/sunflow/core/Geometry;.intersect (Lorg/sunflow/core/Ray;Lorg/sunflow/core/IntersectionState;)V:89(0)
+Lorg/sunflow/core/ShadingState;.traceRefractionPhoton (Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:637(0)
+Lorg/sunflow/core/Geometry;.tesselate ()V:98(0)
+Lorg/sunflow/core/LightServer;.traceRefractionPhoton (Lorg/sunflow/core/ShadingState;Lorg/sunflow/core/Ray;Lorg/sunflow/image/Color;)V:292(0)
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/synchronizedBlocks.txt workspace/velodrome-sound/velodrome/exclusion-list/synchronizedBlocks.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/synchronizedBlocks.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/synchronizedBlocks.txt	2014-04-03 17:43:56.967716367 -0400
@@ -0,0 +1,39 @@
+# Hsqldb6
+
+# These are with synch blocks as transactions
+Lorg/hsqldb/Session;.commit()V:491(14)
+Lorg/hsqldb/Session;.execute (Lorg/hsqldb/Result;)Lorg/hsqldb/Result;:873(39)
+
+# Xalan9
+
+# These are with synch blocks as transactions
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;Z)V:1266(7)
+Lorg/apache/xml/dtm/ObjectFactory;.lookUpFactoryClassName(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;:294(145)
+
+# Pmd9
+
+# No violations were reported
+
+# Luindex9
+
+# No violations were reported
+
+
+# Lusearch9-fix
+ 
+# The following has a notify, do we report it?
+Lorg/dacapo/lusearch/Search$QueryProcessor;.run()V:249(128)
+
+
+# Tsp
+
+# These are with synch blocks as transactions
+LTspSolver;.get_tour (I)I:454(5)
+LTspSolver;.set_best (I[I)V:109(13)
+
+
+# Sunflow9
+
+# No violations have been reported
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/tsp.txt workspace/velodrome-sound/velodrome/exclusion-list/tsp.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/tsp.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/tsp.txt	2014-04-03 17:43:56.965716361 -0400
@@ -0,0 +1,19 @@
+# Tsp
+
+LTsp;.main ([Ljava/lang/String;)V:27(0)
+LTspSolver;.run ()V:33(0)
+
+# Velodrome results
+
+LTspSolver;.Worker ()V:37(0)
+LTspSolver;.get_tour (I)I:454(0)
+LTspSolver;.recursive_solve (I)V:473(0)
+LTspSolver;.find_solvable_tour ()I:362(0)
+LTspSolver;.visit_nodes (I)V:520(0)
+LTspSolver;.split_tour (I)V:270(0)
+LTspSolver;.set_best (I[I)V:103(0)
+
+
+# Our implementation showed these violations with map16c input file and 8 threads, but not with map15c and 4 threads
+#LTspSolver;.calc_bound (I)I:0(0)
+#LTspSolver;.new_tour (II)I:0(0)
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/xalan6.txt workspace/velodrome-sound/velodrome/exclusion-list/xalan6.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/xalan6.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/xalan6.txt	2014-04-03 17:43:56.969716375 -0400
@@ -0,0 +1,69 @@
+# Xalan6
+
+# Trivial
+Ldacapo/xalan/XalanHarness$XalanWorker;.run ()V:80(0)
+
+# Velodrome results
+
+Lorg/apache/xalan/templates/StylesheetRoot;.newTransformer ()Ljavax/xml/transform/Transformer;:212(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;)V:1107(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.<init> (Lorg/apache/xalan/templates/StylesheetRoot;)V:400(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;Z)V:1122(0)
+Lorg/apache/xalan/templates/OutputProperties;.<init> (Ljava/lang/String;)V:129(0)
+Lorg/apache/xpath/XPathContext;.<init> (Ljava/lang/Object;)V:357(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Z)V:628(0)
+Lorg/apache/xalan/templates/OutputProperties;.getDefaultMethodProperties (Ljava/lang/String;)Ljava/util/Properties;:317(0)
+Lorg/apache/xml/dtm/DTMManager;.newInstance (Lorg/apache/xml/utils/XMLStringFactory;)Lorg/apache/xml/dtm/DTMManager;:179(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformNode (I)V:1169(0)
+Lorg/apache/xml/dtm/DTMManager;.findFactory (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;:405(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getDTM (Ljavax/xml/transform/Source;ZLorg/apache/xml/dtm/DTMWSFilter;ZZ)Lorg/apache/xml/dtm/DTM;:285(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.applyTemplateToNode (Lorg/apache/xalan/templates/ElemTemplateElement;Lorg/apache/xalan/templates/ElemTemplate;I)Z:2024(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getXMLReader (Ljavax/xml/transform/Source;)Lorg/xml/sax/XMLReader;:647(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.executeChildTemplates (Lorg/apache/xalan/templates/ElemTemplateElement;Z)V:2291(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:191(0)
+Lorg/apache/xerces/jaxp/SAXParserFactoryImpl;.newSAXParser ()Ljavax/xml/parsers/SAXParser;:0(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl;.<init> (Lorg/apache/xerces/jaxp/SAXParserFactoryImpl;Ljava/util/Hashtable;Z)V:0(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:244(0)
+Lorg/apache/xalan/templates/ElemLiteralResult;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:664(0)
+Lorg/apache/xerces/jaxp/SAXParserImpl$JAXPSAXParser;.<init> (Lorg/apache/xerces/jaxp/SAXParserImpl;)V:0(0)
+Lorg/apache/xerces/parsers/SAXParser;.<init> ()V:0(0)
+Lorg/apache/xalan/templates/ElemAttribute;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:123(0)
+Lorg/apache/xalan/templates/ElemNumber;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:601(0)
+Lorg/apache/xalan/templates/AVT;.evaluate (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Ljava/lang/String;:517(0)
+Lorg/apache/xalan/templates/ElemIf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:174(0)
+Lorg/apache/xerces/parsers/SAXParser;.<init> (Lorg/apache/xerces/util/SymbolTable;Lorg/apache/xerces/xni/grammars/XMLGrammarPool;)V:0(0)
+Lorg/apache/xalan/templates/ElemElement;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:282(0)
+Lorg/apache/xalan/templates/ElemNumber;.getCountString (Lorg/apache/xalan/transformer/TransformerImpl;I)Ljava/lang/String;:840(0)
+Lorg/apache/xpath/XPath;.bool (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Z:377(0)
+Lorg/apache/xalan/templates/ElemCopy;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:138(0)
+Lorg/apache/xalan/templates/ElemChoose;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:125(-2)
+Lorg/apache/xalan/templates/ElemAttribute;.constructNode (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/apache/xalan/transformer/TransformerImpl;)V:222(0)
+Lorg/apache/xerces/parsers/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:0(0)
+Lorg/apache/xalan/templates/ElemNumber;.formatNumberList (Lorg/apache/xalan/transformer/TransformerImpl;[JI)Ljava/lang/String;:1208(0)
+Lorg/apache/xalan/templates/ElemMessage;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:160(0)
+Lorg/apache/xpath/axes/LocPathIterator;.bool (Lorg/apache/xpath/XPathContext;)Z:368(0)
+Lorg/apache/xml/dtm/ref/sax2dtm/SAX2DTM;.dispatchCharactersEvents (ILorg/xml/sax/ContentHandler;Z)V:484(0)
+Lorg/apache/xerces/parsers/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:0(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformToString (Lorg/apache/xalan/templates/ElemTemplateElement;)Ljava/lang/String;:1921(0)
+Lorg/apache/xpath/axes/LocPathIterator;.asNode (Lorg/apache/xpath/XPathContext;)I:344(0)
+Lorg/apache/xalan/templates/ElemVariable;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:286(0)
+Lorg/apache/xalan/templates/ElemValueOf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:260(0)
+Lorg/apache/xalan/templates/ElemCallTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:225(0)
+Lorg/apache/xalan/templates/ElemForEach;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:294(-2)
+Lorg/apache/xpath/operations/And;.bool (Lorg/apache/xpath/XPathContext;)Z:111(0)
+Lorg/apache/xml/utils/FastStringBuffer;.sendSAXcharacters (Lorg/xml/sax/ContentHandler;II)V:1011(-2)
+Lorg/apache/xalan/templates/ElemValueOf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:260(0)
+Lorg/apache/xpath/axes/LocPathIterator;.executeCharsToContentHandler (Lorg/apache/xpath/XPathContext;Lorg/xml/sax/ContentHandler;)V:281(0)
+Lorg/apache/xalan/templates/ElemNumber;.getFormattedNumber (Lorg/apache/xalan/transformer/TransformerImpl;ICIJLorg/apache/xml/utils/FastStringBuffer;)V:1367(0)
+Lorg/apache/xalan/templates/ElemTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:423(0)
+Lorg/apache/xalan/transformer/ResultTreeHandler;.characters ([CII)V:480(-2)
+Lorg/apache/xalan/serialize/SerializerToHTML;.characters ([CII)V:1192(-2)
+Lorg/apache/xalan/templates/ElemForEach;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:369(-2)
+Lorg/apache/xalan/templates/AVTPartXPath;.evaluate (Lorg/apache/xpath/XPathContext;Lorg/apache/xml/utils/FastStringBuffer;ILorg/apache/xml/utils/PrefixResolver;)V:175(0)
+Lorg/apache/xalan/serialize/SerializerToXML;.characters ([CII)V:1540(0)
+Lorg/apache/xpath/XPath;.execute (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Lorg/apache/xpath/objects/XObject;:300(0)
+Lorg/apache/xpath/axes/LocPathIterator;.execute (Lorg/apache/xpath/XPathContext;)Lorg/apache/xpath/objects/XObject;:255(0)
+
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/exclusion-list/xalan9.txt workspace/velodrome-sound/velodrome/exclusion-list/xalan9.txt
--- workspace/jikesrvm-3.1.3/velodrome/exclusion-list/xalan9.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/exclusion-list/xalan9.txt	2014-04-03 17:43:56.969716375 -0400
@@ -0,0 +1,87 @@
+# Xalan9
+
+# Trivial
+Lorg/dacapo/xalan/XSLTBench$XalanWorker;.run ()V:91(0)
+
+# Velodrome results
+
+Lorg/apache/xalan/templates/StylesheetRoot;.newTransformer ()Ljavax/xml/transform/Transformer;:200(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;)V:1251(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.<init> (Lorg/apache/xalan/templates/StylesheetRoot;)V:392(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;Z)V:1266(0)
+Lorg/apache/xalan/templates/OutputProperties;.<init> (Ljava/lang/String;)V:82(0)
+Lorg/apache/xpath/XPathContext;.<init> (Ljava/lang/Object;)V:337(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.createSerializationHandler (Ljavax/xml/transform/Result;)Lorg/apache/xml/serializer/SerializationHandler;:1060(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Z)V:639(0)
+Lorg/apache/xml/serializer/OutputPropertiesFactory;.getDefaultMethodProperties (Ljava/lang/String;)Ljava/util/Properties;:254(0)
+Lorg/apache/xpath/XPathContext;.<init> (Ljava/lang/Object;Z)V:349(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.createSerializationHandler (Ljavax/xml/transform/Result;Lorg/apache/xalan/templates/OutputProperties;)Lorg/apache/xml/serializer/SerializationHandler;:1087(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getDTM (Ljavax/xml/transform/Source;ZLorg/apache/xml/dtm/DTMWSFilter;ZZ)Lorg/apache/xml/dtm/DTM;:247(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformNode (I)V:1312(0)
+Lorg/apache/xpath/XPathContext;.<init> (Z)V:319(0)
+Lorg/apache/xml/serializer/SerializerFactory;.getSerializer (Ljava/util/Properties;)Lorg/apache/xml/serializer/Serializer;:96(0)
+Lorg/apache/xml/dtm/ref/DTMManagerDefault;.getXMLReader (Ljavax/xml/transform/Source;)Lorg/xml/sax/XMLReader;:601(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.applyTemplateToNode (Lorg/apache/xalan/templates/ElemTemplateElement;Lorg/apache/xalan/templates/ElemTemplate;I)Z:2133(0)
+Lorg/apache/xml/dtm/DTMManager;.newInstance (Lorg/apache/xml/utils/XMLStringFactory;)Lorg/apache/xml/dtm/DTMManager;:134(0)
+Lorg/apache/xml/serializer/ObjectFactory;.findClassLoader ()Ljava/lang/ClassLoader;:395(0)
+Lorg/apache/xml/serializer/ToHTMLStream;.<init> ()V:662(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.executeChildTemplates (Lorg/apache/xalan/templates/ElemTemplateElement;Z)V:2352(0)
+Lorg/apache/xml/dtm/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:103(0)
+Lorg/apache/xml/serializer/ToStream;.<init> ()V:184(0)
+Lorg/apache/xml/dtm/ObjectFactory;.createObject (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;:133(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:153(0)
+Lorg/apache/xml/dtm/ObjectFactory;.lookUpFactoryClass (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Class;:208(0)
+Lorg/apache/xalan/templates/ElemApplyTemplates;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:205(0)
+Lorg/apache/xml/dtm/ObjectFactory;.lookUpFactoryClassName (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;:261(0)
+Lorg/apache/xalan/templates/ElemLiteralResult;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:1303(0)
+Lorg/apache/xalan/templates/ElemIf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:130(-2)
+Lorg/apache/xalan/templates/ElemElement;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:205(0)
+Lorg/apache/xml/dtm/ObjectFactory;.findJarServiceProviderName (Ljava/lang/String;)Ljava/lang/String;:537(0)
+Lorg/apache/xalan/templates/TemplateList;.getTemplateFast (Lorg/apache/xpath/XPathContext;IILorg/apache/xml/utils/QName;IZLorg/apache/xml/dtm/DTM;)Lorg/apache/xalan/templates/ElemTemplate;:504(0)
+Lorg/apache/xpath/XPath;.bool (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Z:406(0)
+Lorg/apache/xalan/templates/ElemAttribute;.constructNode (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/apache/xalan/transformer/TransformerImpl;)V:184(0)
+Lorg/apache/xalan/templates/ElemNumber;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:560(0)
+Lorg/apache/xalan/templates/ElemCopy;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:92(0)
+Lorg/apache/xalan/templates/ElemNumber;.getCountString (Lorg/apache/xalan/transformer/TransformerImpl;I)Ljava/lang/String;:799(0)
+Lorg/apache/xpath/axes/LocPathIterator;.bool (Lorg/apache/xpath/XPathContext;)Z:320(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.transformToString (Lorg/apache/xalan/templates/ElemTemplateElement;)Ljava/lang/String;:2045(0)
+Lorg/apache/xalan/templates/ElemCallTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:196(0)
+Lorg/apache/xpath/axes/LocPathIterator;.asNode (Lorg/apache/xpath/XPathContext;)I:296(-2)
+Lorg/apache/xalan/templates/ElemNumber;.getMatchingAncestors (Lorg/apache/xpath/XPathContext;IZ)Lorg/apache/xml/utils/NodeVector;:990(0)
+Lorg/apache/xalan/templates/ElemValueOf;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:215(0)
+Lorg/apache/xalan/templates/ElemNumber;.formatNumberList (Lorg/apache/xalan/transformer/TransformerImpl;[JI)Ljava/lang/String;:1171(0)
+Lorg/apache/xalan/templates/ElemNumber;.getCountMatchPattern (Lorg/apache/xpath/XPathContext;I)Lorg/apache/xpath/XPath;:730(0)
+Lorg/apache/xalan/templates/AVT;.evaluate (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Ljava/lang/String;:490(0)
+Lorg/apache/xalan/templates/ElemChoose;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:81(0)
+Lorg/apache/xalan/templates/ElemForEach;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:259(0)
+Lorg/apache/xalan/templates/ElemTemplate;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:382(-2)
+Lorg/apache/xpath/operations/And;.bool (Lorg/apache/xpath/XPathContext;)Z:72(0)
+Lorg/apache/xml/dtm/ObjectFactory;.findClassLoader ()Ljava/lang/ClassLoader;:396(0)
+Lorg/apache/xpath/axes/LocPathIterator;.executeCharsToContentHandler (Lorg/apache/xpath/XPathContext;Lorg/xml/sax/ContentHandler;)V:236(-2)
+Lorg/apache/xalan/templates/ElemNumber;.getFormattedNumber (Lorg/apache/xalan/transformer/TransformerImpl;ICIJLorg/apache/xml/utils/FastStringBuffer;)V:1330(0)
+Lorg/apache/xalan/templates/ElemMessage;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:117(0)
+Lorg/apache/xalan/transformer/TransformerImpl;.reset ()V:486(0)
+Lorg/apache/xml/dtm/ref/DTMDefaultBase;.getNode (I)Lorg/w3c/dom/Node;:2218(0)
+Lorg/apache/xml/dtm/ref/sax2dtm/SAX2DTM;.<init> (Lorg/apache/xml/dtm/DTMManager;Ljavax/xml/transform/Source;ILorg/apache/xml/dtm/DTMWSFilter;Lorg/apache/xml/utils/XMLStringFactory;Z)V:224(0)
+Lorg/apache/xpath/axes/LocPathIterator;.asIterator (Lorg/apache/xpath/XPathContext;I)Lorg/apache/xml/dtm/DTMIterator;:267(0)
+Lorg/apache/xalan/templates/ElemForEach;.transformSelectedNodes (Lorg/apache/xalan/transformer/TransformerImpl;)V:333(0)
+Lorg/apache/xalan/templates/AVTPartXPath;.evaluate (Lorg/apache/xpath/XPathContext;Lorg/apache/xml/utils/FastStringBuffer;ILorg/apache/xml/utils/PrefixResolver;)V:135(0)
+Lorg/apache/xml/dtm/ref/sax2dtm/SAX2DTM;.<init> (Lorg/apache/xml/dtm/DTMManager;Ljavax/xml/transform/Source;ILorg/apache/xml/dtm/DTMWSFilter;Lorg/apache/xml/utils/XMLStringFactory;ZIZZ)V:253(0)
+Lorg/apache/xml/serializer/CharInfo;.getCharInfo (Ljava/lang/String;Ljava/lang/String;)Lorg/apache/xml/serializer/CharInfo;:491(0)
+Lorg/apache/xpath/XPathContext;.reset ()V:362(0)
+Lorg/apache/xalan/templates/ElemVariable;.execute (Lorg/apache/xalan/transformer/TransformerImpl;)V:243(0)
+Lorg/apache/xml/serializer/CharInfo;.getCharInfo (Ljava/lang/String;Ljava/lang/String;)Lorg/apache/xml/serializer/CharInfo;:491(0)
+Lorg/apache/xml/utils/XMLReaderManager;.getXMLReader ()Lorg/xml/sax/XMLReader;:84(0)
+Lorg/apache/xml/serializer/CharInfo;.getCharInfoBasedOnPrivilege (Ljava/lang/String;Ljava/lang/String;Z)Lorg/apache/xml/serializer/CharInfo;:462(0)
+Lorg/apache/xpath/patterns/StepPattern;.execute (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/dtm/DTM;I)Lorg/apache/xpath/objects/XObject;:386(0)
+Lorg/apache/xpath/XPath;.execute (Lorg/apache/xpath/XPathContext;ILorg/apache/xml/utils/PrefixResolver;)Lorg/apache/xpath/objects/XObject;:329(0)
+Lorg/apache/xalan/templates/ElemVariable;.getValue (Lorg/apache/xalan/transformer/TransformerImpl;I)Lorg/apache/xpath/objects/XObject;:272(0)
+Lorg/apache/xpath/axes/LocPathIterator;.execute (Lorg/apache/xpath/XPathContext;)Lorg/apache/xpath/objects/XObject;:210(0)
+Lorg/apache/xpath/axes/NodeSequence;.setRoot (ILjava/lang/Object;)V:261(0)
+Lorg/apache/xpath/axes/WalkingIterator;.setRoot (ILjava/lang/Object;)V:153(0)
+Lorg/apache/xpath/axes/FilterExprWalker;.setRoot (I)V:129(0)
+Lorg/apache/xpath/patterns/StepPattern;.executeRelativePathPattern (Lorg/apache/xpath/XPathContext;Lorg/apache/xml/dtm/DTM;I)Lorg/apache/xpath/objects/XObject;:669(0)
+Lorg/apache/xpath/Expression;.bool (Lorg/apache/xpath/XPathContext;)Z:186(0)
+Lorg/apache/xml/dtm/ref/DTMDefaultBaseTraversers;.getAxisTraverser (I)Lorg/apache/xml/dtm/DTMAxisTraverser;:107(0)
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/parseFish.sh workspace/velodrome-sound/velodrome/parseFish.sh
--- workspace/jikesrvm-3.1.3/velodrome/parseFish.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/parseFish.sh	2014-04-03 17:43:57.379717723 -0400
@@ -0,0 +1,87 @@
+#!/bin/fish
+
+# WHAT DOES THIS SCRIPT DO?
+# This script takes a benchmark name as input, finds all output.txt files in exp-output, and then 
+# extracts some strings from the output files and logs to another output file.
+
+# This work can be done more cheaply
+
+if [[ $# -ne 2 ]]
+    echo "Usage: sh <script_name> <directory_name> <benchmark_name>"
+    exit 1
+end
+
+DIR_NAME=$1
+BENCH_NAME=$2
+DIR_PATH="/exp-output/"$DIR_NAME"/"$BENCH_NAME
+SEARCH_STRING="Cycle"
+OUTPUT_FILE=$HOME"/Desktop/"$BENCH_NAME
+
+# Delete output file if it already exists
+if [[ -e "$OUTPUT_FILE" ]
+    rm $OUTPUT_FILE
+end
+
+function processFile(){
+    local file_name=$1
+    echo "FILE NAME: "$file_name
+    # Why is this not working?
+    echo "Searching $file_name" >> $OUTPUT_FILE
+    echo `grep -F "$SEARCH_STRING" $file_name` >> $OUTPUT_FILE
+    # Now add newlines for each output
+    sed -i "s|ITERATION:|\nITERATION:|g" $OUTPUT_FILE
+}
+
+# recurse() is to be called with a directory path as the parameter
+# $1 is the first parameter
+function recurse(){
+    local dir_name=$1
+    cd $dir_name
+    # We are now in $dir_name
+    # If there are no .txt files, the wild card will expand to *.txt, the following line avoids this problem
+    shopt -s nullglob
+    local file
+    # We are bothered with only "output.txt"
+    for file in *.txt
+    do
+	if [[ $file = "output.txt" ]]
+	    local file_name=$dir_name$FS$file
+	    processFile $file_name
+	end
+    done
+    # Iterate over directories if any
+    local dir
+    for dir in `ls`
+    do
+	if [[ -d $dir ]]
+ 	    local child_dir=$dir_name$FS$dir
+	    recurse $child_dir
+	end
+    done
+    cd .. # Move back to the parent
+}
+
+# START
+if [[ ! -d "$HOME$DIR_PATH" ]]; then
+    echo "Directory $HOME$DIR_PATH does not exist!"
+    exit 1
+fi
+
+#cd ~/$DIR_PATH
+
+#for file in `ls`
+#do 
+#    if [[ -d $file ]]; then
+#	top_dir_name=`pwd`$FS$file
+#	recurse $top_dir_name
+#    fi
+#done
+
+for file in `find $HOME$DIR_PATH -name output.txt`
+do
+    processFile $file
+done
+echo "OUTPUT WRITTEN TO "$OUTPUT_FILE
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/parseOutputFiles.sh workspace/velodrome-sound/velodrome/parseOutputFiles.sh
--- workspace/jikesrvm-3.1.3/velodrome/parseOutputFiles.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/parseOutputFiles.sh	2014-04-03 17:43:57.378717720 -0400
@@ -0,0 +1,88 @@
+#!/bin/bash
+
+# WHAT DOES THIS SCRIPT DO?
+# This script takes a benchmark name as input, finds all output.txt files in exp-output, and then 
+# extracts some strings from the output files and logs to another output file.
+
+# This work can be done more cheaply
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <benchmark_name>"
+    exit 1
+fi
+
+FS="/"
+# Use argument to read benchmark name
+BENCH_NAME=$1
+DIR_PATH="/exp-output/temp/"$BENCH_NAME
+SEARCH_STRING="Cycle"
+OUTPUT_FILE=$HOME$FS"Desktop"$FS$BENCH_NAME
+
+# Delete output file if it already exists
+if [[ -e "$OUTPUT_FILE" ]]; then
+    rm $OUTPUT_FILE
+fi
+
+function processFile(){
+    local file_name=$1
+    echo "FILE NAME: "$file_name
+    # Why is this not working?
+    echo "Searching $file_name" >> $OUTPUT_FILE
+    echo `grep -F "$SEARCH_STRING" $file_name` >> $OUTPUT_FILE
+    # Now add newlines for each output
+    sed -i "s|ITERATION:|\nITERATION:|g" $OUTPUT_FILE
+}
+
+# recurse() is to be called with a directory path as the parameter
+# $1 is the first parameter
+function recurse(){
+    local dir_name=$1
+    cd $dir_name
+    # We are now in $dir_name
+    # If there are no .txt files, the wild card will expand to *.txt, the following line avoids this problem
+    shopt -s nullglob
+    local file
+    # We are bothered with only "output.txt"
+    for file in *.txt
+    do
+	if [[ $file = "output.txt" ]]; then
+	    local file_name=$dir_name$FS$file
+	    processFile $file_name
+	fi
+    done
+    # Iterate over directories if any
+    local dir
+    for dir in `ls`
+    do
+	if [[ -d $dir ]]; then
+ 	    local child_dir=$dir_name$FS$dir
+	    recurse $child_dir
+	fi
+    done
+    cd .. # Move back to the parent
+}
+
+# START
+if [[ ! -d "$HOME$DIR_PATH" ]]; then
+    echo "Directory $HOME$DIR_PATH does not exist!"
+    exit 1
+fi
+
+#cd ~/$DIR_PATH
+
+#for file in `ls`
+#do 
+#    if [[ -d $file ]]; then
+#	top_dir_name=`pwd`$FS$file
+#	recurse $top_dir_name
+#    fi
+#done
+
+for file in `find $HOME$DIR_PATH -name output.txt`
+do
+    processFile $file
+done
+echo "OUTPUT WRITTEN TO "$OUTPUT_FILE
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/parseOutputStats.sh workspace/velodrome-sound/velodrome/parseOutputStats.sh
--- workspace/jikesrvm-3.1.3/velodrome/parseOutputStats.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/parseOutputStats.sh	2014-04-03 17:43:57.377717716 -0400
@@ -0,0 +1,36 @@
+#!/bin/bash
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <benchmark_name>"
+    exit 1
+fi
+
+FS="/"
+# Use argument to read benchmark name
+BENCH_NAME=$1
+DIR_PATH="/exp-output/temp/"$BENCH_NAME
+
+# START
+if [[ ! -d "$HOME$DIR_PATH" ]]; then
+    echo "Directory $HOME$DIR_PATH does not exist!"
+    exit 1
+fi
+
+cd $HOME$DIR_PATH
+
+# Get total number of nodes
+grep -r "AVDNodes" . | cut -d ' ' -f 2 | awk '{sum += $1} END {print sum/10}'
+# Get total number of regular transactions
+grep -r "AVDNumRegularTransactions" . | cut -d ' ' -f 2 | awk '{sum += $1} END {print sum/10}'
+# Get total number of unary transactions
+grep -r "AVDNumUnaryTransactions" . | cut -d ' ' -f 2 | awk '{sum += $1} END {print sum/10}'
+# Get total number of Phase 1 edges
+grep -r "AVDPhase1Edges" . | cut -d ' ' -f 2 | awk '{sum += $1} END {print sum/10}'
+# Get total number of Phase 1 cycles
+grep -r "AVDPhase1Cycles" . | cut -d ' ' -f 2 | awk '{sum += $1} END {print sum/10}'
+# Get total number of instrumented instructions in Phase 1
+grep -r "AVDNumTotalPhase1Instructions" . | cut -d ' ' -f 2 | awk '{sum += $1} END {print sum/10}'
+# Get total number of instructions logged in Phase 1
+grep -r "AVDNumPhase1InstructionsLogged" . | cut -d ' ' -f 2 | awk '{sum += $1} END {print sum/10}'
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/performance_exp_aec_frost.sh workspace/velodrome-sound/velodrome/performance_exp_aec_frost.sh
--- workspace/jikesrvm-3.1.3/velodrome/performance_exp_aec_frost.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/performance_exp_aec_frost.sh	2014-04-03 17:43:57.497718109 -0400
@@ -0,0 +1,137 @@
+#!/bin/bash
+
+#
+# This script is to do performance tests for the AEC submission. This script runs five implementations one by 
+# one and generates graphs for each of them. The benchmark names and the configurations being run in each test 
+# corresponds closely to the results reported in the first version of the paper. The code base revision on which 
+# these tests are being run also correspond to versions used for the initial submission. We have made some 
+# enhancements to the code since the submission, but we do not use the newer revisions so that the results generated 
+# hopefully closely match the ones reported in the initial submission. 
+#
+# Please feel free to contact the corresponding author at biswass@cse.ohio-state.edu with any questions or feedback.
+
+DATE=`date +"%m-%d-%y"`
+
+# Run EXP either in local mode or remote mode
+
+#if [[ $# -ne 1 ]]; then
+#    echo "Usage: sh <script_name> <local | remote>"
+#    exit 1
+#fi
+
+#DOEXP="doexp-"$1
+DOEXP="doexp-"$1
+
+# Set up directory paths
+USER=`whoami`
+USER_PATH="/home/"$USER
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+VDROME_DIR="velodromeRvmRoot"
+VDROME_PATH=$USER_PATH$VDROME_DIR
+
+cd $USER_PATH
+
+# DoubleChecker Single run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/branch-clone-application-methods-aec avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+DC_OUT_DIR=$DATE"_dc_single_run_perf_aec_frost"
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefault,AVDASICD,AVDASDefault --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+
+# DoubleChecker First run in the multi-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/first-run-doublechecker-aec avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+DC_OUT_DIR=$DATE"_dc_first_run_perf_aec_frost"
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefault,AVDCycleDetection --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+
+# DoubleChecker Second run in the multi-run mode
+
+# Delete contents of local AVD directory
+if [ -d "$AVD_DIR" ]; then
+    cd $AVD_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/second-run-doublechecker-aec avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+DC_OUT_DIR=$DATE"_dc_second_run_perf_aec_frost"
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefault,AVDICD,AVDDefault --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+
+
+# Velodrome sound version
+
+# Delete contents of local VDROME directory
+if [ -d "$VDROME_DIR" ]; then 
+    cd $VDROME_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-clone-app-methods-aec velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+VDROME_OUT_DIR=$DATE"_velodrome_sound_perf_aec_frost"
+$DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefault --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=10 --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+
+# Velodrome unsound version
+
+# Delete contents of local VDROME directory
+if [ -d "$VDROME_DIR" ]; then 
+    cd $VDROME_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-unsound-aec velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+VDROME_OUT_DIR=$DATE"_velodrome_unsound_perf_aec_frost"
+$DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeUnsynchronizedAccesses,VelodromeSynchronizedWrites --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=10 --retryTrials=true --timeout=240 --baseName=$VDROME_OUT_DIR --email=true
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/performance_experiment_frost.sh workspace/velodrome-sound/velodrome/performance_experiment_frost.sh
--- workspace/jikesrvm-3.1.3/velodrome/performance_experiment_frost.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/performance_experiment_frost.sh	2014-04-03 17:43:57.378717720 -0400
@@ -0,0 +1,37 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+VDROME_OUT_DIR=$DATE"_velodrome_performance_frost"
+DC_OUT_DIR=$DATE"_doublechecker_performance_frost"
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <local | remote>"
+    exit 1
+fi
+
+DOEXP="doexp-"$1
+USER_PATH="/home/biswass/"
+VDROME_DIR="velodromeRvmRoot"
+VDROME_PATH=$USER_PATH$VDROME_DIR
+
+cd $USER_PATH
+
+# Delete contents of local VDROME directory
+if [ -d "$VDROME_DIR" ]; then 
+    cd $VDROME_DIR
+    # Delete all files just to be sure
+    rm -rf *
+fi
+cd .. # Move up one level
+
+# Set up desired sym link
+ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-clone-application-methods velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+$DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,OctetDefault,VelodromeASInsertPostBarriers,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp,product --trial=15 --retryTrials=true --timeout=240 --baseName=$VDROME_OUT_DIR
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/performance_experiment.sh workspace/velodrome-sound/velodrome/performance_experiment.sh
--- workspace/jikesrvm-3.1.3/velodrome/performance_experiment.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/performance_experiment.sh	2014-04-03 17:43:57.496718106 -0400
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+VELODROME_DIR=$DATE"_velodrome_perf_test"
+
+if [[ $# -ne 1 ]]; then
+    echo "Usage: sh <script_name> <local | remote>"
+    exit 1
+fi
+
+DOEXP="doexp-"$1
+
+cd /home/biswass
+
+#$DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,OctetDefault,VelodromeASInsertPostBarriers,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch9-fixed,sunflow9,xalan9,pmd9,luindex9,avrora9,jython9 --tasks=sync,build,exp --trial=5 --retryTrials=true --timeout=180 
+
+$DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASInsertPostBarriers,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault,VelodromeCustom1 --bench=sor,tsp --tasks=exp,product --trial=5 --retryTrials=true --timeout=180 --baseName=$VELODROME_DIR
+
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/run_tests_local.sh workspace/velodrome-sound/velodrome/run_tests_local.sh
--- workspace/jikesrvm-3.1.3/velodrome/run_tests_local.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/run_tests_local.sh	2014-04-03 17:43:57.495718103 -0400
@@ -0,0 +1,322 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+
+# Run EXP locally
+DOEXP="doexp-local"
+
+# Set up directory paths
+USER=`whoami`
+USER_PATH="/home/"$USER
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+VDROME_DIR="velodromeRvmRoot"
+VDROME_PATH=$USER_PATH$VDROME_DIR
+OCTET_DIR="octetRvmRoot"
+OCTET_PATH=$USER_PATH$OCTET_DIR
+
+# Run 25 trials usually
+TRIALS=10
+
+cd $USER_PATH
+
+# DoubleChecker single run mode
+dc_single_run() {
+	ln -nsf workspace/dc-single-run-final avdRvmRoot
+	ls -l avdRvmRoot
+    DC_OUT_DIR=$DATE"_dc_single_run_final_perf_rain"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASSlowPathHooks,AVDASCrossThreadEdge,AVDASCycleDetection,AVDASICD,AVDASDefault --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker first run in the multi-run mode
+dc_first_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-first-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_first_run_final_perf_rain"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDCrossThreadEdge,AVDCycleDetection --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode
+dc_second_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_perf_final_rain"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDICD,AVDDefault --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version
+velodrome_sound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_final_perf_rain"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# Velodrome unsound version
+velodrome_unsound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-unsound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_unsound_final_perf_rain"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeUnsynchronizedAccesses,VelodromeSynchronizedWrites --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=240 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker with arrays
+dc_single_run_arrays() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd .. # Move up one level
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_arrays_final_perf_rain"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASICDNoCycle,AVDASICDWithArraysNoCycle --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version with arrays
+velodrome_sound_arrays() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_arrays_final_perf_rain"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefaultNoCycle,VelodromeASDefaultWithArraysNoCycle --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode with always unary instrumentation turned on
+dc_second_run_always_unaries() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_always_instr_unaries_perf_rain"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDDefault,AVDDefaultAlwaysInstrumentUnaries --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker single run during stages of iterative refinement (very start, and approximately halfway) 
+dc_single_run_iterative_refinement() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_iterative_refinement_perf_rain"
+$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASDefault,AVDIterativeRefinementStart,AVDIterativeRefinementHalfway  --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version for the second run
+velodrome_sound_second_run() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-second-run velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_second_run_final_perf_rain"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeDefault --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode with static race detection
+dc_single_run_with_static_race() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_static_race_final_perf_rain"
+    #    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASDefault,OctetDefaultStaticRaceFiltering,AVDASDefaultWithStaticRace --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASDefault,OctetDefaultStaticRaceFiltering,AVDASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version with static race detection
+velodrome_sound_with_static_race() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_static_race_final_perf_rain"
+    #    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefault,VelodromeASDefaultWithStaticRace --bench=sor,tsp,montecarlo,moldyn,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefault,VelodromeASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# Octet optimistic/pessimistic barriers with static race detection
+octet_with_static_race() {
+    # Delete contents of local Octet directory
+    if [ -d "$OCTET_DIR" ]; then 
+	cd $OCTET_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/octetRvmRoot octetRvmRoot
+ls -l octetRvmRoot
+ENDSSH
+
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_rain"
+    doexp-remote --project=octet --buildPrefix=FastAdaptive --workloadSize=small --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceDetection --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$OCTET_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode custom configurations
+dc_single_run_custom() {
+	ln -nsf workspace/dc-single-run-final avdRvmRoot
+	ls -l avdRvmRoot
+    DC_OUT_DIR=$DATE"_dc_single_run_final_custom_perf_rain"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASTransactionInstrumentation,AVDASSlowPathHooks,AVDASCrossThreadEdge --bench=sor,tsp,montecarlo,moldyn,raytracer,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Experiment execution is controlled from here
+
+#dc_single_run
+#dc_first_run
+#dc_second_run
+#velodrome_sound
+#velodrome_unsound
+#dc_single_run_arrays
+#velodrome_sound_arrays
+#dc_second_run_always_unaries
+#dc_single_run_iterative_refinement
+#velodrome_sound_second_run
+#dc_single_run_with_static_race
+#velodrome_sound_with_static_race
+#octet_with_static_race
+dc_single_run_custom
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/run_tests_remote_frost.sh workspace/velodrome-sound/velodrome/run_tests_remote_frost.sh
--- workspace/jikesrvm-3.1.3/velodrome/run_tests_remote_frost.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/run_tests_remote_frost.sh	2014-04-03 17:43:57.379717723 -0400
@@ -0,0 +1,512 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+
+# Run EXP remotely
+DOEXP="doexp-remote"
+
+# Set up directory paths
+USER=`whoami`
+USER_PATH="/home/"$USER
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+VDROME_DIR="velodromeRvmRoot"
+VDROME_PATH=$USER_PATH$VDROME_DIR
+OCTET_DIR="octetRvmRoot"
+OCTET_PATH=$USER_PATH$OCTET_DIR
+
+# Run 25 trials usually
+TRIALS=25
+
+cd $USER_PATH
+
+# DoubleChecker single run mode
+dc_single_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASSlowPathHooks,AVDASCrossThreadEdge,AVDASCycleDetection,AVDASICD,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker first run in the multi-run mode
+dc_first_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-first-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_first_run_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDCrossThreadEdge,AVDCycleDetection --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode
+dc_second_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_perf_final_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDICD,AVDDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version
+velodrome_sound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# Velodrome unsound version
+velodrome_unsound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-unsound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_unsound_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeUnsynchronizedAccesses,VelodromeSynchronizedWrites --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=240 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker with arrays
+dc_single_run_arrays() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd .. # Move up one level
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_arrays_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASICDNoCycle,AVDASICDWithArraysNoCycle --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version with arrays
+velodrome_sound_arrays() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_arrays_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefaultNoCycle,VelodromeASDefaultWithArraysNoCycle --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode with always unary instrumentation turned on
+dc_second_run_always_unaries() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_always_instr_unaries_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDDefault,AVDDefaultAlwaysInstrumentUnaries --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker single run during stages of iterative refinement (very start, and approximately halfway) 
+dc_single_run_iterative_refinement() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_iterative_refinement_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASDefault,AVDIterativeRefinementStart,AVDIterativeRefinementHalfway  --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version for the second run
+velodrome_sound_second_run() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-second-run velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_second_run_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode with static race detection
+dc_single_run_with_static_race() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    # small
+    DC_OUT_DIR=$DATE"_dc_single_run_static_race_small_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,AVDASDefault,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering,AVDASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+
+    # large
+    DC_OUT_DIR=$DATE"_dc_single_run_static_race_large_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --workloadSize=large --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+
+}
+
+# Velodrome sound version with static race detection
+velodrome_sound_with_static_race() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    # small
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_static_race_small_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,PessimisticBarriers,VelodromeASDefault,PessimisticBarriersStaticRaceFiltering,VelodromeASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+    # large
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_static_race_large_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=large --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+}
+
+# Octet optimistic/pessimistic barriers with static race detection
+octet_with_static_race() {
+    # Delete contents of local Octet directory
+    if [ -d "$OCTET_DIR" ]; then 
+	cd $OCTET_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/octetRvmRoot octetRvmRoot
+ls -l octetRvmRoot
+ENDSSH
+
+    # small
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_small_frost"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=small --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+    # large
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_large_frost"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=large --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+}
+
+# DoubleChecker single run mode for custom configurations
+dc_single_run_custom() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_inlining_test_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault,AVDASDefaultInlineOnlyBarriers,AVDASDefaultInlineOnlyTransactions,AVDASDefaultNoInline --bench=sor,tsp,moldyn,montecarlo,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+#    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run mode for custom configurations
+dc_second_run_custom() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_inlining_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDDefault,AVDDefaultInlineOnlyBarriers,AVDDefaultInlineOnlyTransactions,AVDDefaultNoInline --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+    #$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version for custom configurations
+velodrome_sound_custom() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_final_inlining_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefault,VelodromeASDefaultInlineOnlyBarriers,VelodromeASDefaultInlineOnlyTransactions,VelodromeASDefaultNoInline --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode where PCD is invoked for all transactions
+# A few benchmarks like eclipse6, xalan6, avrora9, xalan9 are left out since they run out of memory
+dc_single_run_pcd_for_all() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-pcd-on-all avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_pcd_on_all_perf_frost"
+	$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault,AVDASPCDForAll --bench=sor,tsp,moldyn,montecarlo,raytracer,hsqldb6,lusearch6,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Octet custom configurations
+octet_custom() {
+    # Delete contents of local Octet directory
+    if [ -d "$OCTET_DIR" ]; then 
+	cd $OCTET_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/octetRvmRoot octetRvmRoot
+ls -l octetRvmRoot
+ENDSSH
+
+    # small
+    OCTET_OUT_DIR=$DATE"_octet_opt_compilation_overhead_perf_small_frost"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=small --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,OctetForceUseJikesInliner --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$OCTET_OUT_DIR --email=true
+
+    # large
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_large_frost"
+    #$DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=large --tasks=sync,build --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+}
+
+# DoubleChecker single run mode with stats, ten trials
+dc_single_run_stats() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_final_stats_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=AVDStats --bench=elevator,hedc,philo,sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode with stats, ten trials
+dc_second_run_stats() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_final_stats_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=AVDStats --bench=elevator,hedc,philo,sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+}
+
+
+# Experiment execution is controlled from here
+
+#dc_single_run
+#dc_first_run
+#dc_second_run
+#velodrome_sound
+#velodrome_unsound
+#dc_single_run_arrays
+#velodrome_sound_arrays
+#dc_second_run_always_unaries
+#dc_single_run_iterative_refinement
+#velodrome_sound_second_run
+#dc_single_run_with_static_race
+#velodrome_sound_with_static_race
+#octet_with_static_race
+#dc_single_run_custom
+#dc_second_run_custom
+#velodrome_sound_custom
+#dc_single_run_pcd_for_all
+#octet_custom
+#dc_single_run_stats
+#dc_second_run_stats
diff -rupN workspace/jikesrvm-3.1.3/velodrome/run_tests_remote_mist.sh workspace/velodrome-sound/velodrome/run_tests_remote_mist.sh
--- workspace/jikesrvm-3.1.3/velodrome/run_tests_remote_mist.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/run_tests_remote_mist.sh	2014-04-03 17:43:57.495718103 -0400
@@ -0,0 +1,512 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+
+# Run EXP remotely
+DOEXP="doexp-remote"
+
+# Set up directory paths
+USER=`whoami`
+USER_PATH="/home/"$USER
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+VDROME_DIR="velodromeRvmRoot"
+VDROME_PATH=$USER_PATH$VDROME_DIR
+OCTET_DIR="octetRvmRoot"
+OCTET_PATH=$USER_PATH$OCTET_DIR
+
+# Run 25 trials usually
+TRIALS=25
+
+cd $USER_PATH
+
+# DoubleChecker single run mode
+dc_single_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_final_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASSlowPathHooks,AVDASCrossThreadEdge,AVDASCycleDetection,AVDASICD,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker first run in the multi-run mode
+dc_first_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-first-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_first_run_final_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDCrossThreadEdge,AVDCycleDetection --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode
+dc_second_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_perf_final_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDICD,AVDDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version
+velodrome_sound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_final_perf_mist"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# Velodrome unsound version
+velodrome_unsound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-unsound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_unsound_final_perf_mist"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeUnsynchronizedAccesses,VelodromeSynchronizedWrites --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=240 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker with arrays
+dc_single_run_arrays() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd .. # Move up one level
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_arrays_final_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASICDNoCycle,AVDASICDWithArraysNoCycle --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version with arrays
+velodrome_sound_arrays() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_arrays_final_perf_mist"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefaultNoCycle,VelodromeASDefaultWithArraysNoCycle --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode with always unary instrumentation turned on
+dc_second_run_always_unaries() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_always_instr_unaries_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDDefault,AVDDefaultAlwaysInstrumentUnaries --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker single run during stages of iterative refinement (very start, and approximately halfway) 
+dc_single_run_iterative_refinement() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_iterative_refinement_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASDefault,AVDIterativeRefinementStart,AVDIterativeRefinementHalfway  --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version for the second run
+velodrome_sound_second_run() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-second-run velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_second_run_final_perf_mist"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode with static race detection
+dc_single_run_with_static_race() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    # small
+    DC_OUT_DIR=$DATE"_dc_single_run_static_race_small_final_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,AVDASDefault,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering,AVDASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+
+    # large
+    DC_OUT_DIR=$DATE"_dc_single_run_static_race_large_final_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --workloadSize=large --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+
+}
+
+# Velodrome sound version with static race detection
+velodrome_sound_with_static_race() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    # small
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_static_race_small_final_perf_mist"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,PessimisticBarriers,VelodromeASDefault,PessimisticBarriersStaticRaceFiltering,VelodromeASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+    # large
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_static_race_large_final_perf_mist"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=large --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+}
+
+# Octet optimistic/pessimistic barriers with static race detection
+octet_with_static_race() {
+    # Delete contents of local Octet directory
+    if [ -d "$OCTET_DIR" ]; then 
+	cd $OCTET_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/octetRvmRoot octetRvmRoot
+ls -l octetRvmRoot
+ENDSSH
+
+    # small
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_small_mist"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=small --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+    # large
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_large_mist"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=large --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+}
+
+# DoubleChecker single run mode for custom configurations
+dc_single_run_custom() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_inlining_test_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault,AVDASDefaultInlineOnlyBarriers,AVDASDefaultInlineOnlyTransactions,AVDASDefaultNoInline --bench=sor,tsp,moldyn,montecarlo,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+#    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run mode for custom configurations
+dc_second_run_custom() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_inlining_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDDefault,AVDDefaultInlineOnlyBarriers,AVDDefaultInlineOnlyTransactions,AVDDefaultNoInline --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+    #$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version for custom configurations
+velodrome_sound_custom() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_final_inlining_perf_mist"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefault,VelodromeASDefaultInlineOnlyBarriers,VelodromeASDefaultInlineOnlyTransactions,VelodromeASDefaultNoInline --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode where PCD is invoked for all transactions
+# A few benchmarks like eclipse6, xalan6, avrora9, xalan9 are left out since they run out of memory
+dc_single_run_pcd_for_all() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-pcd-on-all avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_pcd_on_all_perf_mist"
+	$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault,AVDASPCDForAll --bench=sor,tsp,moldyn,montecarlo,raytracer,hsqldb6,lusearch6,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Octet custom configurations
+octet_custom() {
+    # Delete contents of local Octet directory
+    if [ -d "$OCTET_DIR" ]; then 
+	cd $OCTET_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/octetRvmRoot octetRvmRoot
+ls -l octetRvmRoot
+ENDSSH
+
+    # small
+    OCTET_OUT_DIR=$DATE"_octet_opt_compilation_overhead_perf_small_mist"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=small --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,OctetForceUseJikesInliner --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$OCTET_OUT_DIR --email=true
+
+    # large
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_large_mist"
+    #$DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=large --tasks=sync,build --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+}
+
+# DoubleChecker single run mode with stats, ten trials
+dc_single_run_stats() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_final_stats_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=AVDStats --bench=elevator,hedc,philo,sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode with stats, ten trials
+dc_second_run_stats() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_final_stats_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=AVDStats --bench=elevator,hedc,philo,sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+}
+
+
+# Experiment execution is controlled from here
+
+#dc_single_run
+#dc_first_run
+#dc_second_run
+#velodrome_sound
+#velodrome_unsound
+#dc_single_run_arrays
+#velodrome_sound_arrays
+#dc_second_run_always_unaries
+#dc_single_run_iterative_refinement
+#velodrome_sound_second_run
+#dc_single_run_with_static_race
+#velodrome_sound_with_static_race
+#octet_with_static_race
+#dc_single_run_custom
+dc_second_run_custom
+#velodrome_sound_custom
+#dc_single_run_pcd_for_all
+#octet_custom
+#dc_single_run_stats
+#dc_second_run_stats
diff -rupN workspace/jikesrvm-3.1.3/velodrome/run_tests_remote.sh workspace/velodrome-sound/velodrome/run_tests_remote.sh
--- workspace/jikesrvm-3.1.3/velodrome/run_tests_remote.sh	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/run_tests_remote.sh	2014-04-03 17:43:57.496718106 -0400
@@ -0,0 +1,512 @@
+#!/bin/bash
+
+DATE=`date +"%m-%d-%y"`
+
+# Run EXP remotely
+DOEXP="doexp-remote"
+
+# Set up directory paths
+USER=`whoami`
+USER_PATH="/home/"$USER
+AVD_DIR="avdRvmRoot"
+AVD_PATH=$USER_PATH$AVD_DIR
+VDROME_DIR="velodromeRvmRoot"
+VDROME_PATH=$USER_PATH$VDROME_DIR
+OCTET_DIR="octetRvmRoot"
+OCTET_PATH=$USER_PATH$OCTET_DIR
+
+# Run 25 trials usually
+TRIALS=25
+
+cd $USER_PATH
+
+# DoubleChecker single run mode
+dc_single_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASSlowPathHooks,AVDASCrossThreadEdge,AVDASCycleDetection,AVDASICD,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker first run in the multi-run mode
+dc_first_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-first-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_first_run_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDCrossThreadEdge,AVDCycleDetection --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode
+dc_second_run() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_perf_final_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDICD,AVDDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version
+velodrome_sound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASTrackMetadata,VelodromeASCrossThreadEdges,VelodromeASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# Velodrome unsound version
+velodrome_unsound() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-unsound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_unsound_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeUnsynchronizedAccesses,VelodromeSynchronizedWrites --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=240 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker with arrays
+dc_single_run_arrays() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd .. # Move up one level
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_arrays_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASICDNoCycle,AVDASICDWithArraysNoCycle --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version with arrays
+velodrome_sound_arrays() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_arrays_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefaultNoCycle,VelodromeASDefaultWithArraysNoCycle --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode with always unary instrumentation turned on
+dc_second_run_always_unaries() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_always_instr_unaries_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDDefault,AVDDefaultAlwaysInstrumentUnaries --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker single run during stages of iterative refinement (very start, and approximately halfway) 
+dc_single_run_iterative_refinement() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_iterative_refinement_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,AVDASDefault,AVDIterativeRefinementStart,AVDIterativeRefinementHalfway  --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=180 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version for the second run
+velodrome_sound_second_run() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-second-run velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_second_run_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode with static race detection
+dc_single_run_with_static_race() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    # small
+    DC_OUT_DIR=$DATE"_dc_single_run_static_race_small_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,AVDASDefault,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering,AVDASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+
+    # large
+    DC_OUT_DIR=$DATE"_dc_single_run_static_race_large_final_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --workloadSize=large --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+
+}
+
+# Velodrome sound version with static race detection
+velodrome_sound_with_static_race() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    # small
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_static_race_small_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,PessimisticBarriers,VelodromeASDefault,PessimisticBarriersStaticRaceFiltering,VelodromeASDefaultWithStaticRace --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+    # large
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_static_race_large_final_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=large --config=BaseConfig,OctetDefaultForAVD,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$VDROME_OUT_DIR --email=true
+
+}
+
+# Octet optimistic/pessimistic barriers with static race detection
+octet_with_static_race() {
+    # Delete contents of local Octet directory
+    if [ -d "$OCTET_DIR" ]; then 
+	cd $OCTET_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/octetRvmRoot octetRvmRoot
+ls -l octetRvmRoot
+ENDSSH
+
+    # small
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_small_frost"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=small --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+    # large
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_large_frost"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=large --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+}
+
+# DoubleChecker single run mode for custom configurations
+dc_single_run_custom() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_inlining_test_perf_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault,AVDASDefaultInlineOnlyBarriers,AVDASDefaultInlineOnlyTransactions,AVDASDefaultNoInline --bench=sor,tsp,moldyn,montecarlo,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+#    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run mode for custom configurations
+dc_second_run_custom() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_inlining_perf_mist"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDDefault,AVDDefaultInlineOnlyBarriers,AVDDefaultInlineOnlyTransactions,AVDDefaultNoInline --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+    #$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Velodrome sound version for custom configurations
+velodrome_sound_custom() {
+    # Delete contents of local VDROME directory
+    if [ -d "$VDROME_DIR" ]; then 
+	cd $VDROME_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/velodrome-sound-final velodromeRvmRoot
+ls -l velodromeRvmRoot
+ENDSSH
+
+    VDROME_OUT_DIR=$DATE"_velodrome_sound_final_inlining_perf_frost"
+    $DOEXP --project=velodrome --buildPrefix=FastAdaptive --workloadSize=small --config=BaseConfig,VelodromeASDefault,VelodromeASDefaultInlineOnlyBarriers,VelodromeASDefaultInlineOnlyTransactions,VelodromeASDefaultNoInline --bench=sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --trial=$TRIALS --retryTrials=true --timeout=360 --baseName=$VDROME_OUT_DIR --email=true
+}
+
+# DoubleChecker single run mode where PCD is invoked for all transactions
+# A few benchmarks like eclipse6, xalan6, avrora9, xalan9 are left out since they run out of memory
+dc_single_run_pcd_for_all() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-pcd-on-all avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_pcd_on_all_perf_frost"
+	$DOEXP --project=avd --buildPrefix=FastAdaptive --config=BaseConfig,AVDASDefault,AVDASPCDForAll --bench=sor,tsp,moldyn,montecarlo,raytracer,hsqldb6,lusearch6,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9 --tasks=sync,build,exp,product --workloadSize=small --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$DC_OUT_DIR --email=true
+}
+
+# Octet custom configurations
+octet_custom() {
+    # Delete contents of local Octet directory
+    if [ -d "$OCTET_DIR" ]; then 
+	cd $OCTET_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/octetRvmRoot octetRvmRoot
+ls -l octetRvmRoot
+ENDSSH
+
+    # small
+    OCTET_OUT_DIR=$DATE"_octet_opt_compilation_overhead_perf_small_frost"
+    $DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=small --tasks=sync,build,exp,product --config=BaseConfig,OctetDefault,OctetForceUseJikesInliner --bench=sor,tsp,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --trial=$TRIALS --retryTrials=true --timeout=120 --baseName=$OCTET_OUT_DIR --email=true
+
+    # large
+    OCTET_OUT_DIR=$DATE"_octet_pessimistic_barriers_static_race_perf_large_frost"
+    #$DOEXP --project=octet --buildPrefix=FastAdaptive --workloadSize=large --tasks=sync,build --config=BaseConfig,OctetDefault,PessimisticBarriers,OctetDefaultStaticRaceFiltering,PessimisticBarriersStaticRaceFiltering --bench=eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9,pseudojbb2000,pseudojbb2005 --trial=$TRIALS --retryTrials=true --timeout=420 --baseName=$OCTET_OUT_DIR --email=true
+
+}
+
+# DoubleChecker single run mode with stats, ten trials
+dc_single_run_stats() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-single-run-inlining avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_single_run_final_stats_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=AVDStats --bench=elevator,hedc,philo,sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+}
+
+# DoubleChecker second run in the multi-run mode with stats, ten trials
+dc_second_run_stats() {
+    # Delete contents of local AVD directory
+    if [ -d "$AVD_DIR" ]; then
+	cd $AVD_DIR
+	# Delete all files just to be sure
+	rm -rf *
+    fi
+    cd # Switch to $HOME
+
+    # Set up desired sym link
+    ssh biswass@rain.cse.ohio-state.edu <<'ENDSSH'
+bash -s
+cd $USER_PATH
+ln -nsf workspace/dc-second-run-final avdRvmRoot
+ls -l avdRvmRoot
+ENDSSH
+
+    DC_OUT_DIR=$DATE"_dc_second_run_final_stats_frost"
+    $DOEXP --project=avd --buildPrefix=FastAdaptive --config=AVDStats --bench=elevator,hedc,philo,sor,tsp,moldyn,montecarlo,raytracer,eclipse6,hsqldb6,lusearch6,xalan6,avrora9,jython9,luindex9,lusearch9-fixed,pmd9,sunflow9,xalan9 --tasks=sync,build,exp,product --workloadSize=small --trial=10 --retryTrials=true --timeout=420 --baseName=$DC_OUT_DIR --email=true
+}
+
+
+# Experiment execution is controlled from here
+
+#dc_single_run
+#dc_first_run
+#dc_second_run
+#velodrome_sound
+#velodrome_unsound
+#dc_single_run_arrays
+#velodrome_sound_arrays
+#dc_second_run_always_unaries
+#dc_single_run_iterative_refinement
+#velodrome_sound_second_run
+#dc_single_run_with_static_race
+#velodrome_sound_with_static_race
+#octet_with_static_race
+#dc_single_run_custom
+#dc_second_run_custom
+#velodrome_sound_custom
+#dc_single_run_pcd_for_all
+#octet_custom
+#dc_single_run_stats
+#dc_second_run_stats
diff -rupN workspace/jikesrvm-3.1.3/velodrome/synchronizedBlocks.txt workspace/velodrome-sound/velodrome/synchronizedBlocks.txt
--- workspace/jikesrvm-3.1.3/velodrome/synchronizedBlocks.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/synchronizedBlocks.txt	2014-04-03 17:43:57.379717723 -0400
@@ -0,0 +1,39 @@
+# Hsqldb6
+
+# These are with synch blocks as transactions
+Lorg/hsqldb/Session;.commit()V:491(14)
+Lorg/hsqldb/Session;.execute (Lorg/hsqldb/Result;)Lorg/hsqldb/Result;:873(39)
+
+# Xalan9
+
+# These are with synch blocks as transactions
+Lorg/apache/xalan/transformer/TransformerImpl;.transform (Ljavax/xml/transform/Source;Ljavax/xml/transform/Result;Z)V:1266(7)
+Lorg/apache/xml/dtm/ObjectFactory;.lookUpFactoryClassName(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;:294(145)
+
+# Pmd9
+
+# No violations were reported
+
+# Luindex9
+
+# No violations were reported
+
+
+# Lusearch9-fix
+ 
+# The following has a notify, do we report it?
+Lorg/dacapo/lusearch/Search$QueryProcessor;.run()V:249(128)
+
+
+# Tsp
+
+# These are with synch blocks as transactions
+LTspSolver;.get_tour (I)I:454(5)
+LTspSolver;.set_best (I[I)V:109(13)
+
+
+# Sunflow9
+
+# No violations have been reported
+
+
diff -rupN workspace/jikesrvm-3.1.3/velodrome/velodrome-non-atomic-methods.txt workspace/velodrome-sound/velodrome/velodrome-non-atomic-methods.txt
--- workspace/jikesrvm-3.1.3/velodrome/velodrome-non-atomic-methods.txt	1969-12-31 19:00:00.000000000 -0500
+++ workspace/velodrome-sound/velodrome/velodrome-non-atomic-methods.txt	2014-04-03 17:43:56.634715275 -0400
@@ -0,0 +1,162 @@
+	static {
+		//grep "      <name>" log/log.xml  | gawk '{print "nonAtomicMethods.add(\""$2"\");"}' | sed 's/(NullLoc)//'
+		//find . -type f -name "log.xml" | xargs grep "      <name>"   | gawk '{print "nonAtomicMethods.add(\""$3"\");"}' | sed 's/(NullLoc)//' | sort  | uniq
+		//87 methods, from Experiments-Coop/feb-20-velodrome, -r 7086
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/FJTaskRunner.run()V");
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/FJTaskRunner.scanWhileIdling()V");
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup$InvokableFJTask.awaitTermination()V");
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.checkActive(LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;J)V");
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.invoke(Ljava/lang/Runnable;)V");
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.setActive(LEDU/oswego/cs/dl/util/concurrent/FJTaskRunner;)V");
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/FJTaskRunnerGroup.signalNewTask()V");
+		nonAtomicMethods.add("EDU/oswego/cs/dl/util/concurrent/LinkedQueue.take()Ljava/lang/Object;");
+		nonAtomicMethods.add("Elevator.begin()V");
+		nonAtomicMethods.add("Elevator.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFCryptBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFLUFactBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFMolDynBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFMonteCarloBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFRayTracerBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFSORBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFSeriesBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("JGFSparseMatmultBenchSizeA.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("MetaSearchImpl.search(Ljava/util/Hashtable;LMetaSearchRequest;)Ljava/util/List;");
+		nonAtomicMethods.add("MetaSearchRequest.go()V");
+		nonAtomicMethods.add("Philo.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("Philo.run()V");
+		nonAtomicMethods.add("PooledExecutorWithInvalidate$Worker.run()V");
+		nonAtomicMethods.add("PooledExecutorWithInvalidate.addThread(LTask;)V");
+		nonAtomicMethods.add("PooledExecutorWithInvalidate.execute(LTask;)V");
+		nonAtomicMethods.add("PooledExecutorWithInvalidate.getTask()LTask;");
+		nonAtomicMethods.add("Table.getForks(I)I");
+		nonAtomicMethods.add("Tester.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("Tester.run()V");
+		nonAtomicMethods.add("cern/colt/matrix/bench/BenchmarkKernel.run(DLcern/colt/matrix/bench/TimerProcedure;)F");
+		nonAtomicMethods.add("cern/colt/matrix/bench/BenchmarkMatrix$1.apply(Lcern/colt/Timer;)V");
+		nonAtomicMethods.add("cern/colt/matrix/bench/BenchmarkMatrix.bench_dgemm([Ljava/lang/String;)V");
+		nonAtomicMethods.add("cern/colt/matrix/bench/BenchmarkMatrix.handle([Ljava/lang/String;)Z");
+		nonAtomicMethods.add("cern/colt/matrix/bench/BenchmarkMatrix.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("cern/colt/matrix/bench/BenchmarkMatrix.run(DLjava/lang/String;Lcern/colt/matrix/bench/Double2DProcedure;[Ljava/lang/String;[I[D)V");
+		nonAtomicMethods.add("cern/colt/matrix/linalg/SmpBlas.dgemm(ZZDLcern/colt/matrix/DoubleMatrix2D;Lcern/colt/matrix/DoubleMatrix2D;DLcern/colt/matrix/DoubleMatrix2D;)V");
+		nonAtomicMethods.add("crypt/IDEATest.Do()V");
+		nonAtomicMethods.add("crypt/JGFCryptBench.JGFkernel()V");
+		nonAtomicMethods.add("crypt/JGFCryptBench.JGFrun(I)V");
+		nonAtomicMethods.add("lufact/JGFLUFactBench.JGFkernel()V");
+		nonAtomicMethods.add("lufact/JGFLUFactBench.JGFrun(I)V");
+		nonAtomicMethods.add("moldyn/JGFMolDynBench.JGFapplication()V");
+		nonAtomicMethods.add("moldyn/JGFMolDynBench.JGFrun(I)V");
+		nonAtomicMethods.add("moldyn/md.runiters()V");
+		nonAtomicMethods.add("montecarlo/AppDemo.runThread()V");
+		nonAtomicMethods.add("montecarlo/CallAppDemo.runiters()V");
+		nonAtomicMethods.add("montecarlo/JGFMonteCarloBench.JGFapplication()V");
+		nonAtomicMethods.add("montecarlo/JGFMonteCarloBench.JGFrun(I)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/Main.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/admin/AdminServer.initialize(Lorg/w3c/jigsaw/daemon/ServerHandlerManager;Ljava/lang/String;Lorg/w3c/util/ObservableProperties;)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/admin/AdminServer.perform(Lorg/w3c/tools/resources/RequestInterface;)Lorg/w3c/tools/resources/ReplyInterface;");
+		nonAtomicMethods.add("org/w3c/jigsaw/daemon/ServerHandlerManager.launchServerHandler(Ljava/lang/String;Lorg/w3c/jigsaw/daemon/DaemonProperties;)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/daemon/ServerHandlerManager.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/filters/TEFilter.doEncoding(Lorg/w3c/www/http/HttpAcceptEncoding;Lorg/w3c/jigsaw/http/Reply;)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/filters/TEFilter.outgoingFilter(Lorg/w3c/tools/resources/RequestInterface;Lorg/w3c/tools/resources/ReplyInterface;)Lorg/w3c/tools/resources/ReplyInterface;");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/Client.processRequest(Lorg/w3c/jigsaw/http/Request;)Lorg/w3c/jigsaw/http/Reply;");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/Client.startConnection(Ljava/io/InputStream;Ljava/io/DataOutputStream;)Z");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/httpd.initialize(Lorg/w3c/jigsaw/daemon/ServerHandlerManager;Ljava/lang/String;Lorg/w3c/util/ObservableProperties;)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/httpd.initializeEventManager()V");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/httpd.initializeResourceSpace(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/httpd.initializeServerSocket()V");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/httpd.start()V");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/socket/SocketClient.run()V");
+		nonAtomicMethods.add("org/w3c/jigsaw/http/socket/SocketClientFactory.initialize(Lorg/w3c/jigsaw/http/httpd;)V");
+		nonAtomicMethods.add("org/w3c/tools/resources/store/StoreManagerSweeper.run()V");
+		nonAtomicMethods.add("org/w3c/tools/resources/store/StoreManagerSweeper.waitEvent()V");
+		nonAtomicMethods.add("org/w3c/tools/timers/EventManager.getNextEvent()Lorg/w3c/tools/timers/Event;");
+		nonAtomicMethods.add("org/w3c/tools/timers/EventManager.run()V");
+		nonAtomicMethods.add("org/w3c/util/CachedThread.run()V");
+		nonAtomicMethods.add("org/w3c/util/CachedThread.waitForRunner()Ljava/lang/Runnable;");
+		nonAtomicMethods.add("org/w3c/util/ThreadCache.initialize()V");
+		nonAtomicMethods.add("raja/ui/CommandLineUI.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("raytracer/JGFRayTracerBench.JGFapplication()V");
+		nonAtomicMethods.add("raytracer/JGFRayTracerBench.JGFrun(I)V");
+		nonAtomicMethods.add("series/JGFSeriesBench.JGFkernel()V");
+		nonAtomicMethods.add("series/JGFSeriesBench.JGFrun(I)V");
+		nonAtomicMethods.add("series/SeriesTest.Do()V");
+		nonAtomicMethods.add("sor/JGFSORBench.JGFkernel()V");
+		nonAtomicMethods.add("sor/JGFSORBench.JGFrun(I)V");
+		nonAtomicMethods.add("sor/SOR.SORrun(D[[DI)V");
+		nonAtomicMethods.add("sparsematmult/JGFSparseMatmultBench.JGFkernel()V");
+		nonAtomicMethods.add("sparsematmult/JGFSparseMatmultBench.JGFrun(I)V");
+		nonAtomicMethods.add("sparsematmult/SparseMatmult.test([D[D[I[I[DI[I[I)V");
+		nonAtomicMethods.add("spec/benchmarks/_205_raytrace/RayTracer.inst_main([Ljava/lang/String;)J");
+		nonAtomicMethods.add("spec/benchmarks/_205_raytrace/RayTracer.run([Ljava/lang/String;)V");
+		nonAtomicMethods.add("spec/benchmarks/_227_mtrt/Main.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("spec/benchmarks/_227_mtrt/Main.runBenchmark([Ljava/lang/String;)J");
+
+		//68 methods, from Experiments-Coop/feb-28-velodrome-extra, -r 7179
+		nonAtomicMethods.add("EmbeddingFtpServer$1.run()V");
+		nonAtomicMethods.add("EmbeddingFtpServer.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("Tsp.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("org/apache/ftpserver/command/impl/QUIT.execute(Lorg/apache/ftpserver/impl/FtpIoSession;Lorg/apache/ftpserver/impl/FtpServerContext;Lorg/apache/ftpserver/ftplet/FtpRequest;)V");
+		nonAtomicMethods.add("org/apache/ftpserver/impl/DefaultFtpHandler.messageReceived(Lorg/apache/ftpserver/impl/FtpIoSession;Lorg/apache/ftpserver/ftplet/FtpRequest;)V");
+		nonAtomicMethods.add("org/apache/ftpserver/impl/DefaultFtpServer.start()V");
+		nonAtomicMethods.add("org/apache/ftpserver/impl/DefaultFtpServer.stop()V");
+		nonAtomicMethods.add("org/apache/ftpserver/listener/nio/FtpHandlerAdapter.messageReceived(Lorg/apache/mina/core/session/IoSession;Ljava/lang/Object;)V");
+		nonAtomicMethods.add("org/apache/ftpserver/listener/nio/FtpLoggingFilter.messageReceived(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Ljava/lang/Object;)V");
+		nonAtomicMethods.add("org/apache/ftpserver/listener/nio/NioListener.start(Lorg/apache/ftpserver/impl/FtpServerContext;)V");
+		nonAtomicMethods.add("org/apache/ftpserver/listener/nio/NioListener.stop()V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain$EntryImpl$1.messageReceived(Lorg/apache/mina/core/session/IoSession;Ljava/lang/Object;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain$EntryImpl$1.messageSent(Lorg/apache/mina/core/session/IoSession;Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain$EntryImpl$1.sessionOpened(Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain$TailFilter.messageReceived(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Ljava/lang/Object;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain.callNextMessageReceived(Lorg/apache/mina/core/filterchain/IoFilterChain$Entry;Lorg/apache/mina/core/session/IoSession;Ljava/lang/Object;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain.callNextMessageSent(Lorg/apache/mina/core/filterchain/IoFilterChain$Entry;Lorg/apache/mina/core/session/IoSession;Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain.callNextSessionOpened(Lorg/apache/mina/core/filterchain/IoFilterChain$Entry;Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain.fireMessageSent(Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/DefaultIoFilterChain.fireSessionOpened()V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/IoFilterAdapter.messageSent(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/IoFilterAdapter.sessionOpened(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/core/filterchain/IoFilterEvent.fire()V");
+		nonAtomicMethods.add("org/apache/mina/core/future/DefaultIoFuture.await0(JZ)Z");
+		nonAtomicMethods.add("org/apache/mina/core/future/DefaultIoFuture.awaitUninterruptibly()Lorg/apache/mina/core/future/IoFuture;");
+		nonAtomicMethods.add("org/apache/mina/core/future/DefaultIoFuture.awaitUninterruptibly(J)Z");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoAcceptor.bindInternal(Ljava/util/List;)Ljava/util/Set;");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoAcceptor.unbind0(Ljava/util/List;)V");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoProcessor$Processor.run()V");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoProcessor.addNow(Lorg/apache/mina/core/session/AbstractIoSession;)Z");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoProcessor.fireMessageSent(Lorg/apache/mina/core/session/AbstractIoSession;Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoProcessor.flush(J)V");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoProcessor.flushNow(Lorg/apache/mina/core/session/AbstractIoSession;J)Z");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoProcessor.handleNewSessions()I");
+		nonAtomicMethods.add("org/apache/mina/core/polling/AbstractPollingIoProcessor.writeBuffer(Lorg/apache/mina/core/session/AbstractIoSession;Lorg/apache/mina/core/write/WriteRequest;ZIJ)I");
+		nonAtomicMethods.add("org/apache/mina/core/service/AbstractIoAcceptor.bind(Ljava/lang/Iterable;)V");
+		nonAtomicMethods.add("org/apache/mina/core/service/AbstractIoAcceptor.bind(Ljava/net/SocketAddress;)V");
+		nonAtomicMethods.add("org/apache/mina/core/service/AbstractIoAcceptor.unbind()V");
+		nonAtomicMethods.add("org/apache/mina/core/service/AbstractIoAcceptor.unbind(Ljava/lang/Iterable;)V");
+		nonAtomicMethods.add("org/apache/mina/core/service/AbstractIoService.dispose()V");
+		nonAtomicMethods.add("org/apache/mina/core/service/IoServiceListenerSupport.fireSessionCreated(Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/core/session/IoEvent.run()V");
+		nonAtomicMethods.add("org/apache/mina/filter/codec/ProtocolCodecFilter$ProtocolDecoderOutputImpl.flush(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/codec/ProtocolCodecFilter.messageReceived(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Ljava/lang/Object;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/ExecutorFilter.fireEvent(Lorg/apache/mina/core/filterchain/IoFilterEvent;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/ExecutorFilter.messageSent(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/ExecutorFilter.sessionOpened(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/OrderedThreadPoolExecutor$Worker.run()V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/OrderedThreadPoolExecutor$Worker.runTask(Ljava/lang/Runnable;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/OrderedThreadPoolExecutor$Worker.runTasks(Lorg/apache/mina/filter/executor/OrderedThreadPoolExecutor$SessionTasksQueue;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/OrderedThreadPoolExecutor.addWorker()V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/OrderedThreadPoolExecutor.addWorkerIfNecessary()V");
+		nonAtomicMethods.add("org/apache/mina/filter/executor/OrderedThreadPoolExecutor.execute(Ljava/lang/Runnable;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/firewall/BlacklistFilter.messageSent(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/firewall/BlacklistFilter.sessionOpened(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/logging/MdcInjectionFilter.filter(Lorg/apache/mina/core/filterchain/IoFilterEvent;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/util/CommonEventFilter.messageReceived(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Ljava/lang/Object;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/util/CommonEventFilter.messageSent(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;Lorg/apache/mina/core/write/WriteRequest;)V");
+		nonAtomicMethods.add("org/apache/mina/filter/util/CommonEventFilter.sessionOpened(Lorg/apache/mina/core/filterchain/IoFilter$NextFilter;Lorg/apache/mina/core/session/IoSession;)V");
+		nonAtomicMethods.add("org/apache/mina/util/NamePreservingRunnable.run()V");
+		nonAtomicMethods.add("spec/jbb/Company.displayResultTotals(ZZ)V");
+		nonAtomicMethods.add("spec/jbb/JBBmain.DOIT(Lspec/jbb/infra/Factory/Container;)V");
+		nonAtomicMethods.add("spec/jbb/JBBmain.DoARun(Lspec/jbb/Company;SSII)V");
+		nonAtomicMethods.add("spec/jbb/JBBmain.main([Ljava/lang/String;)V");
+		nonAtomicMethods.add("spec/jbb/JBBmain.run()V");
+		nonAtomicMethods.add("spec/jbb/JBBmain.startJBBthread(SB)V");
+		nonAtomicMethods.add("spec/jbb/JBBmain.stopJBBthread()V");
+		nonAtomicMethods.add("spec/jbb/TransactionManager.go()V");
+	}
